[["index.html", "Tillämpad Statistik Kapitel 1 Introduktion 1.1 Om statistisk programmering med R 1.2 Allmänna tips om R på kursen 1.3 Sammanfattning 1.4 Referenser", " Tillämpad Statistik Ronnie Pingel, Valentin Zulj Kapitel 1 Introduktion Detta material utgör kurslitteratur till kursen Tillämpad statistik (A5). Observera att materialet kommer att utökas under kursens gång. 1.1 Om statistisk programmering med R På denna kurs arbetar vi med R, som är ett programspråk och en miljö för statistisk dataanalys (https://www.r-project.org/) som fungerar på UNIX plattformar, Windows och MacOS. Det finns flera anledningar till att vi valt R: R är gratis och har en öppen källkod. R ger tillgång till avancerade verktyg för dataanalys och datavisualisering. Användare av R bidrar ofta med egen programkod och egna paket, vilket innebär att en omfattande mängd funktioner enkelt går att implementera. Många läroböcker skrivs med utgångspunkt från R. Online-resurserna är mycket stora. Det finns många forum där användare av R kan få hjälp (t ex https://stackoverflow.com/). R är ett av de absolut vanligaste programmen för statistisk dataanalys. (http://r4stats.com/2019/04/01/scholarly-datasci-popularity-2019/) Finns det anledningar till att inte välja R? Det finns ingen officiell support. Eftersom R bygger på användarnas bidrag finns ingen garanti att funktioner fungerar som de ska. Jämfört med andra programspråk kan R uppfattas som långsamt. För den som van vid menybaserade system (sk point-and-click) kan dessutom kodning uppfattas som en nackdel. Det finns emellertid etiska och praktiska skäl att lära sig programmera i statistikprogram (dvs att i kod skriva ange hur data ska hanteras och analyseras), och inte förlita sig på menyer. Programmering är nödvändig för att tillförlitligt upprepa (replikera) dataanalyser. På företag och på myndigheter ska kolleger kunna ta över datamaterial och tillhörande analyser och på nytt genomföra dessa med samma resultat. Samma sak gäller inom forskning, där andra forskare ska erhålla samma resultat givet samma data och analys. Notera att detta även gäller för dig själv, dvs det är inte ovanligt att som analytiker på nytt upprepa en analys. spar tid för repetativa moment, t ex om många liknande analyser ska genomföras. ger möjlighet till avancerade analyser samt frihet att utforma egna analyser. bidrar till ökad förståelse för dataanalys. Kruxet? Statistisk programmering tar längre tid att lära sig jämfört med att lära sig menybaserad datahantering och analyser! Tabell 2.1 redovisar några reflektioner över ett antal vanliga statistikprogram. Table 1.1: En jämförelse av några vanliga statistikprogram Minitab Mycket enkelt att lära sig. Används främst inom kvalitetskontroll i industri samt planering av randomiserade försök. Billigt. Begränsat urval av statistiska metoder SPSS Enkelt att lära sig. Stor spridning bland samhällsvetare och utredare. Ganska stort urval av statistiska metoder som är organiserade på ett något rörigt sätt. Krånglig programkod. Stata Enkelt att lära sig och mycket enkel programkod. Spridning bland forskare inom ekonometri och epidemiologi. Stort urval av, även de senaste, statistiska metoderna SAS Medelsvårt att lära sig, med en föråldrad programkod. Kan hantera stora dataset. Används av myndigheter, industri och forskare inom alla områden. Standard för läkemdelsbolag. Stort urval av statistiska metoder, men inte de allra senaste. Dyrt. Svårt att göra bra figurer. R Svårt att lära sig. Gratis. Flexibelt. Mycket stor spridning inom alla områden för dataanalys. Enkel programkod. Python Mycket svårt att lära sig. Gratis. Flexibelt. Stor spridning inom maskininlärning och AI. Varför är inte Excel, Open Office Calc, Google Docs och andra kalkylprogram inkluderade i jämförelsen? SVaret är enkelt. Dessa är nämligen inga statistikprogram! Ofta saknas i sådana program viktiga statistiska funktioner och dessutom är den numeriska tillförlitligheten lägre än för konventionella statistiskprogram (Keeling, K. B., &amp; Pavur, R. J., 2011). 1.2 Allmänna tips om R på kursen Det tar tid att lära sig R. Det kan även vara frustrerande, inte minst eftersom programmering är inte förlåtande vad gäller fel. Men misströsta inte, i slutändan är det värt det och är i högsta grad tidsbesparande. Här följer några tips vad gäller inlärningen och användandet av R under kursens gång: Se till att snabbt få grunderna på plats. R kommer att användas löpande under kursens gång. Arbeta aktivt med R. Programmering lär man sig genom tillämpning, inte genom att läsa. Det krävs normalt sett många timmar av aktivt arbete för att lära sig ett programspråk. Använd därför R till att lösa övningsuppgifter och att replikera exempel från föreläsningar. På så vis får du rutin vad gäller användandet av R. Använd kod som presenterats på kursen. Ändra och laborera i färdig kod för att se vad som händer. Det är inte viktigt att kunna skriva all kod utantill, däremot ska man förstå skriven kod och kunna manipulera denna för sitt syfte. Lös övningsuppgifter på följande vis: 1. Läs uppgiften och skissa därefter på papper upp en lösning, men gör inga beräkningar inte. Skriv ner antaganden och formler. 2. Lös sedan uppgiften med hjälp av beräkningar i R. Om du fastnar, studera R-koden i lösningsförslaget förstå hur hur uppgiften har lösts med hjälp R alternativt använd kod som presenterats på kursen. 3. Räkna därefter igenom uppgiften för hand. När du känner dig helt trygg med att räkna för hand kan du så småningom hoppa över detta moment. 4. Fyll i din papperslösning och avsluta med ett svar. Var inte rädd för att använda resurser på nätet. Se ovan. Kontakta lärare och lärarassistenter på kursen om ni fastnar och har frågor. Utnyttja de lärarledda sessionerna. Samarbeta och diskutera i de diskussionsforum som skapats för er studenter. På denna kurs rekommenderas att ni endast skriver kod på det sätt som det presenteras på kursen. Visserligen är R oerhört flexibelt och en uppgift går att lösa på en mängd sätt. Koden som presenteras på kursen är emellertid framtagen för att vara tydlig och tillförlitlig och syftet är att du ska bli trygg med att beräkningarna är korrekta snarare än effektiva. Slutligen, så är det bra att som läsare ha i åtanke att all beskrivning av kodens funktionalitet inte är uttömmande. Syftet är nämligen att lära ut vad som är nödvändigt för denna kurs och då behövs inte en fullständig beskrivning av till exempel vad ett verktyg i R kan göra. Lycka till! 1.3 Sammanfattning div.red{ background-color:#F5B7B1; border-radius: 5px; padding: 20px;} Du ska kunna motivera varför statistisk programmering är nödvändig för arbete med data och dataanalyser. 1.4 Referenser Keeling, K. B., &amp; Pavur, R. J. (2011). Statistical accuracy of spreadsheet software. The American Statistician, 65(4), 265-273. "],["att-börja-använda-r.html", "Kapitel 2 Att börja använda R 2.1 Installation av R och RStudio 2.2 Installation av RStudio 2.3 Första sessionen 2.4 Working directory  ett smidigt sätt att spara arbete 2.5 Paket 2.6 Sammanfattning 2.7 Övningar", " Kapitel 2 Att börja använda R body { text-align: justify} I detta kapitel ska du inledningsvis installera R samt ett gränssnitt som kallas för RStudio. RStudio kan liknas vid en avancerad textredigerare som underlättar arbetet med R. Det går visserligen alldeles utmärkt att använda R som det är, men RStudio förenklar i många avseenden programmeringen. 2.1 Installation av R och RStudio Vid programmering är det mycket viktigt att noga följa instruktioner. Du ska nu först installera R. Därefter ska du installera RStudio. 2.1.1 Installation av R på MacOS Ladda ner den senaste versionen från https://cran.r-project.org/bin/macosx/. Notera att versionen måste passa för ditt MacOS. Leta upp den version som passar till ditt MacOS om du har en äldre Mac. Ladda ner pkg-filen under Latest release. Öppna den nedladdade .pkg-filen och installera R. 2.1.2 Installation av R på Windows Gå till hemsidan av R här. Klicka på Download R (versionnummer) for Windows. Eventuellt fungerar inte den senaste versionen ditt Window om du har en äldre Windows-versions. Prova då en tidigare version av R. Du kanske även upptäcker att senaste versionnummer på Rs hemsida inte är samma som används i detta exempel eftersom det kan ha kommit senare versioner. För din del saknar just detta praktisk betydelse. Dubbelklicka på R installer för att starta installationen. Välj språk och tryck OK. Välj Next. Välj sökväg för din installation. Låt default vara. Klicka Next. För att förenkla, välj alla komponenter för installation. Klicka Next. Klicka No (accept defaults). För att lägga till R i Startmenyn, klicka bort kryssrutan nedan. Klicka Next. Välj om du vill ha genvägar. Klicka Next. Installation börjar! Starta R när den är klar. Starta R för första gången. På Windows ser det ut så här. 2.2 Installation av RStudio Av olika anledningar väljer vi att inte arbeta i R Editor utan vi väljer RStudio. Stäng därför ner R. Gå till https://rstudio.com/products/rstudio/download/}. 2 Välj RStudio Desktop Free. 3 Välj sedan den version stämmer överens med ditt operativsystem. Installera (på Windows) genom att klicka Next-&gt;Next-&gt;Install Starta RStudio. Du ska nu fått upp nedanstående. Vi ska i detalj beskriva vad de olika panelerna till höger kommer vi återkomma till när det är aktuellt. Avsluta RStudio. Om du mot förmodan inte skulle lyckas installera R och RStudio, så finns möjligheten att koppla upp sig till Statistiska institutionens datorer via fjärrskrivbordet och på så sätt få tillgång nödvändig programvara. 2.3 Första sessionen I denna session ska du bekanta dig med R och prova använda R som en miniräknare. Starta RStudio. Till vänster ska du ha en panel som heter Console. I denna panel redovisas resultat. Vad övriga paneler gör kommer vi återkomma till när det blir aktuellt. Välj i menyn File &gt; New File &gt; R Script. Ett nytt fönster (Untitled1) öppnas ovanför Console Detta är ett script-fönster eller en editor. I editorn skrivs kommandon in som sedan kan utvärderas av R. Resultaten redovisas i Console. Ha för vana att aldrig skriva kod direkt i R Console. I princip är en script-fil inte annorlunda än en vanlig textfil, förutom att filen har tillägget .R. Spara script med jämna mellanrum eftersom det är önskvärt att inte förlora sin kod ifall något oförutsett händer. Skapa därför en mapp med namnet A5Rkod på din dator. Välj File &gt; Save As och spara i A5Rkod scriptet Untitled med namnet myfirstscript.R. Efter att vi har skrivit koden i editorn måste vi meddela R att koden ska utvärderas. Kod i scriptfilen körs (exekveras) på tre olika sätt: En rad: Raden där markören är placerad körs med Ctrl+Enter (command + Enter på Mac) eller Run ovanför scriptet. Flera rader: Markera kodavsnittet och tryck Ctrl+Enter (command + Enter på Mac) eller Run. Hela scriptet: Ctrl+Shift+Enter Det finns några viktiga punkter att ha i åtanke: Om avsikten är att köra kod som sträcker sig över flera rader måste man avsluta raden innan radbrottet med räknetecken \\((+,-,*,/)\\), kommatecken \\(,\\) eller vänsterparentes \\((\\). En rad inleds aldrig med räknetecken eller kommatecken. En rad som inleds med # exekveras inte. Tecknet # används för att kommentera kod, vilket är viktigt eftersom vi då i text kan förklara vad koden gör. Skriv in nedanstående script till myfirstscript.R. Spara. # Detta är mitt första R-script som heter myfirstscript.R. # I detta script använder jag R som miniräknare samt # exekverar kod från scriptet. 1+1 1+3 2-7 2*3 4/5 3^2 Använd R som miniräknare genom att prova alla tre sätt att köra kod. Det är nödvändigt att bekanta sig med hur kod körs för att bli bekväm med att simultant arbeta i script-fönstret och se resultat i Console. Återigen, skriv aldrig i Console. 1+1 [1] 2 1+3 [1] 4 2-7 [1] -5 2*3 [1] 6 4/5 [1] 0.8 3^2 [1] 9 Matematiska funktioner, t ex kvadratroten, finns implementerade i R. Skriv sqrt(9) i scriptet och spara. Kör koden och erhåll följande i Console. sqrt(9) [1] 3 Även exponentialfunktionen \\(e^{x}\\) finns i R. Skriv exempelvis exp(3) i script-filen för att beräkna \\(e^{3}\\), spara och kör. exp(3) [1] 20.08554 Konstanten \\(\\pi\\) finns i R. Skriv pi i script-filen, spara och kör. pi [1] 3.141593 Kod finns ofta på flera rader. Anta att vi önskar beräkna \\(2 + 2+ 3+ 5\\) men att koden inte får plats på en rad utan måste delas upp på två rader. Skriv in följande rader i scriptet, spara, markera bägge raderna och kör. # Kod över 2 rader 2 + 2 + 3 + 5 Följande resultat ska presenteras i Console. # Kod över 2 rader 2 + 2 + 3 + 5 [1] 12 Kod finns ofta på flera rader. Skriv in följande rader i scriptet, spara, markera bägge raderna och kör. Jämför resultatet med punkt 6! 2 + 2 + 3 + 5 Nu utvärderas raderna var för sig, vilket inte var avsikten med analysen. 2 + 2 [1] 4 + 3 + 5 [1] 8 Grattis! Du har nu genomfört din första session i R. Scriptet ska se ut enligt nedan. Spara och stäng R. # Detta är mitt första R-script som heter myfirstscript.R. # I detta script använder jag R som miniräknare samt # exekverar kod från scriptet. 1+1 1+3 2-7 2*3 4/5 3^2 # Kvadratroten sqrt(6) # Exponentialfunktionen exp(3) # Pi pi # Kod över 2 rader 2 + 2 + 3 + 5 2 + 2 + 3 + 5 2.4 Working directory  ett smidigt sätt att spara arbete För att underlätta arbetet i RStudio är det bra att anrätta ett så kallat working directory, kort förklarat som en mapp som R kan utgå ifrån. Även om namnet working directory får det att låta komplicerat är det i grund och botten ett väldigt simpelt koncept. Ett working directory är en mapp på datorn som R använder som hem-mapp. Fördelen med ett working directory är att R alltid utgår ifrån det, vilket medför att script som sparas och figurer som laddas ner automatiskt hamnar i en förbestämd mapp, och inte i någon konstig vrå av hårddisken. Ett väl valt working directory gör det också väldigt smidigt att läsa in externa datamaterial i R, detta diskuteras i ett senare skede av introduktionen till R. Det finns två sätt att bestämma vilken mapp som ska räknas som ett workning directory. Det ena går ut på att skriva kod som anger sökvägen till mappen som är menad att vara directory, och den andra går ut på att använda menyer i RStudio för att klicka sig fram till ett directory. De båda sätten är likvärdiga, och det går bra för varje enskild person att använda det sätt som känns mest intuitivt. Faktum är att menyerna används för att generera kod som körs i Console, så i grund och botten är det samma operation som utförs. För att anrätta ett working directory är det första som behövs en mapp att använda, lämpligt är att använda mappen A5Rkod som skapades tidigare. Detta krävs oavsett vilken metod som används för att göra mappen till ett directory. För att bestämma working directory med hjälp av kod används funktionen setwd(), och för att göra mappen Statistik A5 till directory skrivs sökvägen in mellan parenteserna i funktionen. Koden som används blir alltså följande setwd(&quot;/Users/valentinzulj/Desktop/A5Rkod&quot;) Notera att sökvägen är unik för alla datorer. I just detta fall används min personliga dator, och sökvägen kommer inte att fungera på andra datorer än just min. Det är inte alltid självklart hur sökvägen till en mapp ser ut, men som tur är finns ett par knep för att snabbt komma åt sökvägen. För Mac-användare är det lättast att leta upp mappen som ska bli directory, högerklicka på den (för att få fram en lista med olika alternativ), och hålla in option-knappen på tangentbordet. När detta är gjort ändras ett alternativ till Copy namn på filen as Pathname, och genom att klicka på detta alternativ kopieras sökvägen så att den går att klistra in direkt i setwd(), exempelvis med hjälp av command + V. För Windows-användare är processen snarlik, det gäller då att hålla ner Shift-tangenten och högerklicka på mappen som ska användas, för att sedan använda alternativet Copy as Path (Kopiera sökväg). Efter det kan sökvägen klistras in i setwd() med Ctrl + V. För att bestämma directory med hjälp av menyer är det första steget att klicka på Session längst upp i RStudio. Sedan är det bara att gå till Set Working Directory och Choose Directory för att bläddra efter en mapp i datorn. Notera att en rad kod skrivs ut i Console när mappen som ska bli directory har valts, denna kod kan vara bra att kopiera och klistra in i det script som används för att göra analysen. Detta eftersom R återställer directory varje gång det stängs ner, och därför måste mappen anges varje gång R startas. Använd nu panelen som finns längst ner till höger i R (precis till höger om Console). Börja med att klicka på fliken Files, och klicka sedan på kugghjulet som har texten More bredvid sig. Välj nu alternativet Go To Working Directory i listan. När detta är gjort dyker allt innehåll i mappen som är satt som working directory upp i panelen längst ner till höger. Denna meny kan användas för att öppna script-filer i RStudio, men också för att importera datamaterial på ett smidigt sätt (mer om detta senare). 2.5 Paket En viktig styrka med R är det stora antalet tillgängliga paket utvecklade av användare. Grundinstallationen av R är nämligen tämligen begränsad vad gäller funktionalitet, men med alla paket utvidgas den statistiska verktygslådan, de grafiska möjligheterna och förmågan att hantera olika typer av data rejält. Det finns ungefär 15000 paket på The Comprehensive R Archive Network (CRAN) som är R:s arkiv för paket, för den intresserade finns en förteckning av alla paket att hitta här. Paketen på CRAN har gått igenom en speciellt typ av granskning, men det finns ytterligare tusentals paket som inte genomgått samma granskning som paketen på CRAN, till exempel på GitHub. Eftersom antalet paket är överväldigande för nybörjaren kan det vara ett stöd att känna till de vanligaste paketen. Ett förslag på en lista över viktiga paket finns här. För att installera ett paket I R finns två sätt att gå tillväga. Paket kan antingen installeras med hjälp av en snutt kod eller med hjälp av menyn i RStudio, det senare görs enkelt under Tools &gt; Install Packages. För att illustrera hur ett paket kan installeras med hjälp av kod används paketet readxl som exempel. readxl är ett bra paket att installera, eftersom det gör det möjligt att importera data som finns i excel-filer till R. För att installera paketet skrivs koden install.packages(\"readxl\") i Console och körs. Efter installationen finns paketet sparat i datorn (vilket medför att det inte behöver installeras igen, så länge R inte har uppdaterats eller installerats om). Paketet är dock inte aktiverat i R, utan det aktiveras med hjälp av koden library(\"readxl\"). När paketet har aktiverats kan dess funktionalitet utnyttjas i R. Observera att ett paket måste aktiveras på nytt varje gång RStudio öppnas, detta eftersom paketet avaktiveras varje gång R stängs ner. Paketet behöver dock bara installeras en gång. 2.6 Sammanfattning div.red{ background-color:#F5B7B1; border-radius: 5px; padding: 20px;} Du ska kunna installera R och Rstudio och starta det utan felmeddelanden. använda R som miniräknare och använda de olika metoderna för att exekvera kod i editorn. installera ett R-paket och aktivera det. 2.7 Övningar Övning 2.1 Du har ett stickprov betående av observationerna \\(4,-2,5,6,8\\). Beräkna medelvärdet. Beräkna standardavvikelsen. Beräkna variationsbredden. Beräkna det geometriska medelvärdet för de positiva värden \\(4, 5, 6, 8\\). Beräkna det geometriska medelvärdet för alla värden \\(4, -2, 5, 6, 8\\). Visa svar Medelvärdet \\(\\bar{x}\\) beräknas i R i editorn med (4 + (-2) + 5 + 6 + 8)/5 vilket i Console ger svaret ## [1] 4.2 Svar: Medelvärdet är 4.2 Standardavvikelsen \\(s\\) beräknas i R i editorn antingen genom att direkt tillämpa formeln för stickprovets standardavvikelse \\[s=\\sqrt{\\dfrac{\\sum_{i=1}^n (x_i -\\bar{x})^2}{n-1}}\\] sqrt( ( ( 4 - (4 + (-2) + 5 + 6 + 8)/5 )^2 + ( (-2) - (4 + (-2) + 5 + 6 + 8)/5 )^2 + ( 5 - (4 + (-2) + 5 + 6 + 8)/5 )^2 + ( 6 - (4 + (-2) + 5 + 6 + 8)/5 )^2 + ( 8 - (4 + (-2) + 5 + 6 + 8)/5 )^2 ) / (5-1) ) eller genom att använda beräkningsformeln \\[s=\\sqrt{\\dfrac{\\sum_{i=1}^{n}x_i ^2 - (\\sum_{i=1}^n x_i)^2/n}{n-1}}\\]. sqrt( ( 4^2 + (-2)^2 + 5^2 + 6^2 + 8^2 - (4 + (-2) + 5 + 6 + 8)^2/5 )/ (5-1) ) Oavsett formel erhålls i Console svaret ## [1] 3.768289 Svar: Standardavvikelsen är 3.768 Variationsbredden, dvs skillnaden mellan det största och det minsta värdet är 8 - (-2) ## [1] 10 Svar: Variationsbredden är är 10. Det geometriska medelvärdet \\[\\bar{x}_g=(x_1\\cdot x_2 \\cdot \\cdots \\cdot x_n)^{1/n}\\] kan i R beräknas med (4 * 5 * 6 * 8)^(1/4) ## [1] 5.566315 Svar: Det geometriska medelvärdet är 3.95. Det geometriska medelvärdet \\[\\bar{x}_g=(x_1\\cdot x_2 \\cdot \\cdots \\cdot x_n)^{1/n}\\] kan i R beräknas med (4 * (-2) * 5 * 6 * 8)^(1/5) ## [1] NaN Svar: Eftersom en observation är negativ blir NaN, vilket betyder Not a Number. Det går alltså inte att beräkna. Övning 2.2 Ett slumpmässigt urval ger följande observationer \\(0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1\\),där \\(1=Arbetslös\\) och \\(0=Förvärvsarbetande\\). Beräkna andelen arbetslösa i stickprovet. Visa svar Andelen arbetslösa beräkna i R med (0 + 1 + 1 + 0 + 0 + 0 + 0 + 0 + 1 + 0 + 1 + 0 + 1)/13 ## [1] 0.3846154 Svar: Andelen arbetslösa i stickprovet är 0.38. Övning 2.3 Kosumentpriset 2006-2011 är Table 2.1: Konsumentprisindex (KPI) 2006-2011 2006 284.2 2007 290.5 2008 300.6 2009 299.7 2010 303.5 2011 311.4 Med hur många procent har prisnivån förändrats från 2007 till 2010? Visa svar Beräkning i R ger 303.46/290.51 ## [1] 1.044577 Svar: Prisnivån har ökat med 4.5%. Övning 2.4 Denna övningar handlar om potentslagarna. Då \\(x\\) och \\(y\\) är reella och \\(a,b&gt;0\\) gäller följande likheter: \\(a^x\\cdot a^y=a^{x+y}\\) \\((a^x)^y=a^{xy}\\) \\(\\left(\\frac{a}{b}\\right)^x=\\frac{a^x}{b^x}\\) \\(\\frac{a^x}{a^y}=a^{x-y}\\) \\(a^x \\cdot b^x=(ab)^x\\) \\(a^0=1\\) Beräkna nedanstående uttryck relatera svaren till potenslagarna. \\(4^2 + 4^3\\) \\(4^2*4^3\\) \\(4^5\\) \\((4^2)^3\\) \\(4^{15}\\) \\(4^2/4^3\\) \\(4^{-1}\\) \\(4^{-2}\\) \\(1/(4^2)\\) \\(1/16\\) \\(3^4*4^4\\) \\(12^4\\) Visa svar I R kan uttrycken enkelt beräknas. 4^2 + 4^3 [1] 80 4^2*4^3 [1] 1024 4^5 [1] 1024 (4^2)^3 [1] 4096 4^15 [1] 1073741824 4^2/4^3 [1] 0.25 4^{-1} [1] 0.25 4^{-2} [1] 0.0625 1/(4^2) [1] 0.0625 1/16 [1] 0.0625 3^4*4^4 [1] 20736 12^4 [1] 20736 Vi ser att för \\(b= c\\) pga 1. \\(d= e\\) pga 2. \\(k=l\\) pga 5. Vidare gäller Övning 2.5 Den naturliga logaritmen, dvs logaritmen med basen \\(e \\approx 2.718282\\), används ofta i statistiska beräkningar. Några logaratimlagar som gäller för naturliga logaritmen är: \\(\\ln\\, \\left (x\\cdot y \\right )=\\ln\\,x+\\ln\\,y\\) \\(\\ln\\, \\left (x/ y \\right )=\\ln\\,x-\\ln\\,y\\) \\(\\ln\\,x^{a}=a\\cdot \\ln\\,x\\) \\(\\ln e = 1\\) \\(e^{\\ln x} = x\\) \\(\\ln^{e^x} = x\\) Beräkna nedanstående uttryck och relatera svaren till logaritmlagarna \\(\\ln(3*4)\\) \\(\\ln(3) + \\ln(4)\\) \\(\\ln(3/4)\\) \\(\\ln(3) - \\ln(4)\\) \\(\\ln e\\) \\(\\ln e^5\\) \\(e^{5+6}\\) \\(e^5 \\cdot e^6\\) \\(5 \\ln 5 + 6 \\ln 6\\) Visa svar I R kan uttrycken enkelt beräknas. log(3*4) [1] 2.484907 log(3) + log(4) [1] 2.484907 log(3/4) [1] -0.2876821 log(3) - log(4) [1] -0.2876821 log(exp(1)) [1] 1 log(exp(5)) [1] 5 exp(5+6) [1] 59874.14 exp(5) * exp(6) [1] 59874.14 5*log(5) + 6*log(6) [1] 18.79775 Övning 2.6 Låt observationerna \\(4,-2,5,6,8\\) vara obundet slumpmässigt urval från en normalfördelad population. Genomför en hypotesprövning på 5% signifikansnivå för att testa medelvärdet i population är skild från 1. Visa svar Vi observerar \\(x=\\{4,-2,5,6,8\\}.\\) Hypoteser: \\(H_0:\\mu=1\\) vs \\(H_1:\\mu \\neq 1\\) Antaganden: Variabeln \\(x\\) är normalfördelad i populationen. Populationsvariansen \\(\\sigma^2\\) är okänd i populationen. Vi har ett litet stickprov, \\(n=5\\). Testfunktionen ges av \\(t=\\dfrac{\\bar{x}-\\mu}{\\sqrt{s^2/n}}\\). Denna teststatistika är \\(t\\)-fördelad med \\(n-1\\) frihetsgrader om nollhypotesen är sann. Beslutregel: \\(\\alpha=0.05\\). Tvåsidigt test, förkasta därför \\(H_0\\) om \\(|t_{obs}| &gt; t_{krit} = t_{4,\\alpha/2=0.025} = 2.776\\) ( (4 + (-2) + 5 + 6 + 8)/5 - 1 )/sqrt( ( 4^2 + (-2)^2 + 5^2 + 6^2 + 8^2 - (4 + (-2) + 5 + 6 + 8)^2/5 )/ (5-1)/5 ) [1] 1.898851 Eftersom \\(t_{obs}=\\) 1.8988507 \\(&lt; 2.776 = t_{krit}\\) kan vi inte förkasta nollhypotesen. Svar: Vi kan på 5% signifikansnivå inte påvisa att medelvärdet i populationen är skilt från 1. Notera att detta inte innebär att vi visar att medelvärdet är 1. Övning 2.7 Du observerar följande datapunkter \\(x = \\{4,7,2,4,6\\}\\) och \\(y=\\{7,3, 2, 5,6\\}\\). Använd minsta-kvadratmetoden och beräkna koefficienterna \\(a\\) och \\(b\\) i regressionslinjen \\(y=a + bx\\). Använd koefficienterna och ge en prediktion för \\(y\\) givet att \\(x=7\\). Beräkna residualen för \\(x=7\\) Beräkna residualspridningen. Visa svar Riktningskoefficienten ges av \\[b=\\dfrac{\\sum_{i=1}^n(x_i-\\bar{x})(y_i-\\bar{y})}{\\sum_{i=1}^n(x_i - \\bar{x})^2}\\] # Direkt tillämpning av formeln ger ( (4 - (4 + 7 + 2 + 4 + 6)/5) * (7 - (7 + 3 + 2 + 5 + 6)/5) + (7 - (4 + 7 + 2 + 4 + 6)/5) * (3 - (7 + 3 + 2 + 5 + 6)/5) + (2 - (4 + 7 + 2 + 4 + 6)/5) * (2 - (7 + 3 + 2 + 5 + 6)/5) + (4 - (4 + 7 + 2 + 4 + 6)/5) * (5 - (7 + 3 + 2 + 5 + 6)/5) + (6 - (4 + 7 + 2 + 4 + 6)/5) * (6 - (7 + 3 + 2 + 5 + 6)/5) ) / ( (4 - (4 + 7 + 2 + 4 + 6)/5)^2 + (7 - (4 + 7 + 2 + 4 + 6)/5)^2 + (2 - (4 + 7 + 2 + 4 + 6)/5)^2 + (4 - (4 + 7 + 2 + 4 + 6)/5)^2 + (6 - (4 + 7 + 2 + 4 + 6)/5)^2 ) [1] 0.2105263 # Det går att räkna ut detta i flera steg genom att # t ex beräkna täljare och nämnare separat. # Alternativt använda beräkningsformeln ( 4*7 + 7*3 + 2*2 + 4*5 + 6*6 - (4+7+2+4+6)*(7+3+2+5+6)/5 )/ ( (4^2 + 7^2 + 2^2 + 4^2 + 6^2) - (4 + 7 + 2 + 4 + 6)^2/5 ) [1] 0.2105263 # En kommentar: Dessa beräkningar kommer förenklas betydligt i R, vilket vi ska se senare. Interceptet är \\(a=\\bar{y} - b\\bar{x}\\) (7 + 3 + 2 + 5 + 6)/5 - 0.2105*(4 + 7 + 2 + 4 + 6)/5 [1] 3.6317 Svar: Riktningskoefficienten beräknas till \\(b=0.2105\\), vilket tolkas som att om \\(x\\) ökar en enhet så ökar \\(y\\) i genomsnitt med \\(0.2105\\) enheter. Interceptet beräknas till \\(a=3.632\\), vilket tolkas som medelvärdet för \\(y\\) när \\(x=0\\). Använd koefficienterna från regressionslinjen och sätt in värdet \\(x=7\\). 3.6316 + 0.2105*7 [1] 5.1051 Svar: Prediktionen \\(\\hat{y}=\\) 5.1051. Detta är punkten på regressionslinjen när \\(x=7\\) och vår bästa gissning för det \\(y\\)-värde en individ med värdet \\(x=7\\) kommer att ha. En residual är skillnaden mellan ett predicerat värde och det faktiska observerade värdet, \\(\\hat{\\varepsilon}=y_i - \\hat{y}\\). Eftersom \\(y=3\\) när \\(x=7\\) så residualen 3 - (3.6316 + 0.2105*7) [1] -2.1051 Svar: Residualen för \\(x=7\\) är -2.1051. Residualspridningen ges av \\[s_\\varepsilon=\\sqrt{\\dfrac{\\sum_{i=1}^n(y_i - \\hat{y}_i)^2}{n-2}}= \\sqrt{\\dfrac{\\sum_{i=1}^n\\hat{\\varepsilon}_i^2}{n-2}}\\]. Vi beräknar på samma sätt som i c) övriga residualer, kvadrerar och summerar. sqrt( ( (7 - (3.6316 + 0.2105*4))^2 + (3 - (3.6316 + 0.2105*7))^2 + (2 - (3.6316 + 0.2105*2))^2 + (5 - (3.6316 + 0.2105*4))^2 + (6 - (3.6316 + 0.2105*6))^2 ) / (5 - 2) ) [1] 2.347077 Svar: Residualspridningen är 2.347 (Notera att \\(\\sum_{i=1}^n \\hat{\\varepsilon}_i^2\\) kallas för residualkvadratsumman.) Övning 2.8 Installera paketet MASS som innehåller funktioner som kan vara användbara senare på kursen. Aktivera det installerade paketet MASS. Visa svar # Installera paket install.packages(&quot;psych&quot;) # Aktivera paket library(&quot;psych&quot;) "],["data-objekt-och-funktioner.html", "Kapitel 3 Data, objekt och funktioner 3.1 Data och objekt 3.2 Vektorer 3.3 Matriser 3.4 Data frames 3.5 Funktioner 3.6 Sammanfattning 3.7 Övningar", " Kapitel 3 Data, objekt och funktioner body { text-align: justify} För att kunna arbeta med statistik och dataanalys är det viktigt att inte enbart förstå den statistiska metoden och kunna lösa problem med hjälp av en miniräknare. I praktiken är det även nödvändigt att förstå hur data hanteras, lagras och struktureras. I detta kapitel introduceras typer av data som normalt hanteras i R, sedan följer avsnitt om de olika typer av objekt som finns i R. I kapitlets slut avhandlas funktioner, dels introduceras vad en funktion är i R, dels visas hur funktioner kan användas för att hantera olika objekt. Kapitlet är mycket omfattande, men det är likväl viktigt att lära sig hantera allt som presenteras i det. Avsikten med kaptitlet är att ta upp de vanliga saker i R som används vädligt ofta generellt, men även specifikt under just denna kurs. 3.1 Data och objekt Utan data är statistik innehållslöst. På samma sätt är data grundläggande för arbete i R. De vanligaste datatyperna i R är character (text), som anges med citationstecken, t.ex. \"a\" , \"3\". numeric (decimaltal), t ex är 3, 32.1. Notera att 3 kan skrivas som 3.0. integer (heltal). 3L, 32L. Skillnaden mellan numeric och integer är att inga decimaler sparas, vilket använder mindre minne. logical (data indikerar om något är sant eller falskt, TRUE/ FALSE). Observera att dessa datatyper beskriver hur data är lagrad och hur R ska tolka data. Det säger sig kanske självt att det inte går att använda räkneoperation om data är character, till exempel. Datatyper ska inte förväxlas med de datanivåer (nominal, ordinal, intervall och kvotskala) som man normalt förknippar med statistiska analyser. Datatyper ska inte heller förväxlas med om data är diskreta, kontinuerliga, kategorier eller kvantitativa. Det är mycket viktigt för alla som arbetar med statistiska analyser av data att kunna tillämpa alla ovanstående begrepp i rätt situation. Ofta överlappar begreppen, men det är vanligt att begreppen inte gör det. Tabellen nedan ger en översikt av begreppen som används, men notera att det finns undantag från denna klassificering och det finns andra sätt att klassificera. Mätskala Variabeltyp Datatyp i R Nominal Kategori, kvalitativ Character, factor med ordered = FALSE Ordinal Kategori, kvalitativ Character, factor med ordered = TRUE Intervall Kvantitativ, kontinuerlig, heltal, diskret Numeric, integer Kvot Kvantitativ, kontinuerlig, heltal, diskret Numeric, integer Data hanteras och sparas som objekt. För att skapa ett objekt används assignment-operatorn &lt;-. Objektet sparas därmed i minnet i R, men inget resultat redovisas i Console. Om R stängs ner måste objektet skapas på nytt såvida användaren inte har angett att objektet ska sparas. I R används nästan alltid flera olika objekt samtidigt. Objekten måste därför namnges, och precis som Vid all programmering är noggrannhet a och o. Objektnamn inleds med en bokstav och får endast innehålla bokstäver, siffror, _ och .. Dessutom skiljer R på versaler och gemener. Det är inte alltid enkelt att namnge objekt, men det viktigaste är att vara konsekvent. På denna kurs rekommenderas följande principer för namngivning av objekt. Använd endast gemener. korta och logiska namn, t.ex. kan objektet population förkortas till pop. gärna understreck _ för sammanbinda långa objektnamn. Objektet ålder för kvinnor skulle kunna betecknas age_women och motsvarande för män är då age_men. inte å, ä och ö. inte namn som redan är upptagna i R, t ex exp eller log. Det tre vanligaste objekten för hantering av data är: vektorer, matriser, data frames. I närmast följande avsnitt kommer dessa objekt diskuteras mer ingående var för sig. 3.2 Vektorer En vektor är ett dataobjekt som är endimensionellt och består av \\(n\\) element. En vektor skapas med kommandot c() (Combine Values into a Vector). Anta att vi observerar värdena \\(3, -1, 1, 5, 0\\). Med hjälp av nedanstående kod skapas ett vektor-objekt med med 5 element: # Skapa din första numeriska vektor my_first_vec &lt;- c(3, -1, 1, 5, 0) Som synes anges de olika värdena åskilda av kommatecken. När en vektor skapas tolkar R kommatecken som avskiljare mellan element. Notera att inget visas i Console, men att objektet finns sparat i minnet upptäcker man i RStudio genom att observera den övre högra panelen under fliken Environment. Där listas alla objekt som finns sparade i minnet i R. För att titta på objektet exekveras kod som enbart består av objektets namn, precis som nedan. &gt; # Visa din första numeriska vektor &gt; my_first_vec &gt; [1] 3 -1 1 5 0 Du ska nu skapa ett antal vektorobjekt som sedan på olika sätt ska manipuleras. Skapa ett script som heter kap3_objekt_och_funktioner.R genom att välja File &gt; New File &gt; R Script och sedan direkt spara scriptet med File &gt; Save As i mappen A5Rkod. Skriv in koden nedan i scriptet och spara med File &gt; Save (ett alternativ är att använda Ctrl/command + S, precis som i t.ex. ett Word-dokument). Det är bra att få rutin på att ofta spara sitt script så att inte kod råkar försvinna. # Skapar två numeriska vektorer x &lt;- c(3, 1, 1, 5, 0) y &lt;- c(2, 3, 5, 6, 9) Generellt gäller i R att om \\(x\\) är en vektor bestående av \\(k\\) element \\[x = (x_1,x_2,\\ldots,x_k)\\] och \\(y\\) är en vektor bestående av \\(l\\) element \\[y = (y_1,y_2,\\ldots,y_l)\\] så skapar kommandot # Binder samman x och y till en z &lt;- c(x,y) en vektor med \\(k + l\\) element, \\[z= (x_1,x_2,\\ldots,x_k,y_1,y_2,\\ldots,y_l)=(z_1,z_2,\\ldots,z_{k+l}).\\] För att se om detta stämmer tittar vi på objekten genom att exekvera dem. Fortsätt scriptet genom att skriva in nedanstående kod. Spara och kör koden. x y z I Console ser du då följande: &gt; x &gt; [1] 3 1 1 5 0 &gt; y &gt; [1] 2 3 5 6 9 &gt; z &gt; [1] 3 1 1 5 0 2 3 5 6 9 Som synes samlar vektorn \\(z\\) alla element i \\(x\\) och alla element i \\(y\\) i en och samma vektor. Både \\(x\\), \\(y\\) och \\(z\\) är numeriska vektorer. Det går även att skapa en vektor bestående av bokstäver. För att skapa en sådan vektor (character vector) sätts de enskilda elementen inom citationstecken. Fortsätt scriptet och skriv in nedanstående kod i scriptet, spara och kör koden. # Skapar en vektor med ord nordic_countries &lt;- c(&quot;Denmark&quot;, &quot;Finland&quot;, &quot;Iceland&quot;, &quot;Norway&quot;, &quot;Sweden&quot;) nordic_countries I Console ser du då följande resultat. &gt; # Skapar en vektor med ord &gt; nordic_countries &lt;- c(&quot;Denmark&quot;, &quot;Finland&quot;, &quot;Iceland&quot;, &quot;Norway&quot;, &quot;Sweden&quot;) &gt; nordic_countries &gt; [1] &quot;Denmark&quot; &quot;Finland&quot; &quot;Iceland&quot; &quot;Norway&quot; &quot;Sweden&quot; Kombineras en numerisk och en character-vektor blir hela vektorn en character-vector. Skriv följande kod i scriptet, spara och kör koden. # Kombinera en numerisk vektor med en vektor med ord x_nordic_countries &lt;- c(x, nordic_countries ) x_nordic_countries I Console erhålls följande output och vi ser att de tidigare numeriska värdena nu omges av citationstecken. &gt; # Kombinera en numerisk vektor med en vektor med ord &gt; x_nordic_countries &lt;- c(x, nordic_countries ) &gt; x_nordic_countries &gt; [1] &quot;3&quot; &quot;1&quot; &quot;1&quot; &quot;5&quot; &quot;0&quot; &quot;Denmark&quot; &quot;Finland&quot; &gt; [8] &quot;Iceland&quot; &quot;Norway&quot; &quot;Sweden&quot; Om en numerisk vektor kombineras med en vektor med bokstäver så blir hela vektorn en character-vektor. R tolkar alltså siffrorna som bokstäver/tecken utan relation till numeriska värden. Det ser vi genom att det finns finns citationstecken kring siffrorna. Vi ska nu introducera hur man på andra sätt kan skapa vissa typer av vektorer. Skriv in nedanstående kod i scriptet och spara. Kör koden. # Skapar en vektor med värdena 1,2,3,4,5 v &lt;- 1:5 # Skapar en vektor med endast ett element u &lt;- 150 # Skapar en vektor med ett bortfall. ymis &lt;- c(3, NA, 6, 3, 6) I Console visas &gt; v &gt; [1] 1 2 3 4 5 &gt; u &gt; [1] 150 &gt; ymis &gt; [1] 3 NA 6 3 6 För att sammanfatta har vi har hittills skapat numeriska vektorer, vektorer som enbart innehåller bokstäver och vektorer som skapats genom kortkommandon. Vidare finns vektorer med bortfall, som anges som NA (Not Available). div.green{ background-color:#abd4b3; border-radius: 5px; padding: 20px;} En vektor som innehåller enbart en datatyp kallas för atomic. Detta kan vara värt att känna till eftersom eftersom det är vanligt att felmeddelande referar till just att en vektor inte är atomic. Inled en rad med # för att kommentera kod. Kommentera alltid kod!. Vid all programmering är det viktigt att förklara kod så att du själv och andra snabbt förstår vad koden gör. Det är viktigt att få rutin på att kommentera, kommentera därför även enkel kod. Nya vektorer kan skapas med räkneoperationer. Beräkningarna sker då elementvis, till exempel adderas elementvärden i en vektor till elementvärden i en annan vektor som har motsvarade position. Vektorerna måste antingen ha lika många element eller så måste en av vektorerna bestå av enbart ett element. Skriv in nedanstående i ditt script, spara och kör. # Addition av x och y x + y # Multiplikation av x och y x * y # Potenser skrivs med a^b y^2 # En konstant u adderas till alla element i vektorn x + u # Räkneoperationer med NA ger NA x + ymis # Division med 0 är ej definierat. R anger det som Inf (infinity) # eller NaN (Not a Number) om det är 0/0. x/0 # Exempel på längre räkneoperationer. # Notera att alla beräkningar är elementvisa. w &lt;- x + (y^2 - u)/v w I Console visas &gt; # Addition av x och y &gt; x + y &gt; [1] 5 4 6 11 9 &gt; # Multiplikation av x och y &gt; x * y &gt; [1] 6 3 5 30 0 &gt; # Potenser skrivs med a^b &gt; y^2 &gt; [1] 4 9 25 36 81 &gt; # En konstant u adderas till alla element i vektorn &gt; x + u &gt; [1] 153 151 151 155 150 &gt; # Räkneoperationer med NA ger NA &gt; x + ymis &gt; [1] 6 NA 7 8 6 &gt; # Division med 0 är ej definierat. R anger det som Inf (infinity) &gt; # eller NaN (Not a Number) om det är 0/0. &gt; x/0 &gt; [1] Inf Inf Inf Inf NaN &gt; # Exempel på längre räkneoperationer. &gt; # Notera att alla beräkningar är elementvisa. &gt; w &lt;- x + (y^2 - u)/v &gt; w &gt; [1] -143.00000 -69.50000 -40.66667 -23.50000 -13.80000 Ovanstående illustrerar anvädning av objekt kan medföra avsevärda förenklingar i olika beräkningar. Nu ska vi se vad som händer om elemementen består av olika antal element. Kom ihåg att vektorn \\(x\\) består av fem element, och skriv in nedanstående kod i Console och tryck enter. x + c(2,5,6) I Console visas &gt; x + c(2,5,6) &gt; Warning in x + c(2, 5, 6): longer object length is not a multiple of shorter &gt; object length &gt; [1] 5 6 7 7 5 Eftersom vektorerna har olika många element (fem respektive tre) ger R ifrån sig en varning. Eftersom additionen sker elementvis blir R förvirrat då det inte finns några värden i vektorn c(2, 5, 6) som kan adderas till element 4 och 5 i \\(x\\). Detta gäller oavsett räknesätt. Om en av vektorerna enbart innehåller ett element, kommer detta element add användas för varje element i den motsvarande vektor. Se, till exempel, koden nedan. Operationen medför att 2 subtraheras från varje element i \\(x\\) &gt; x - c(2) &gt; [1] 1 -1 -1 3 -2 3.2.1 Vektorer och indexering Ibland är det intressant eller nödvändigt att välja ut enskilda element ur en vektor. Eftersom data i praktiken alltid måste anpassas för planerade analyser är detta nödvändigt för en statistiker att kunna. Varje element i en vektor har en egen position. I vektorn \\(x = \\{3, 1, 1, 5, 0\\}\\) ligger trean på position 1, den första ettan på position 2, etc. Med hjälp av hakparenteser kan ett eller flera element i en vektor väljas ut, detta kallas i kursen för indexering. Använd nedanstående kod som exempel på detta. Skriv in nedanstående i ditt script, spara och kör. # Visa element nummer 2 i vektorn x x[2] # Visa element 2, 3 och 4 i vektorn y y[c(2,3,4)] I Console redovisas &gt; # Visa element nummer 2 i vektorn x &gt; x[2] &gt; [1] 1 &gt; # Visa element 2, 3 och 4 i vektorn y &gt; y[c(2,3,4)] &gt; [1] 3 5 6 Det går även att spara utvalda element till en ny vektor. Skriv in nedanstående i ditt script. # Spara element nummer 2 i vektorn x2 x2 &lt;- x[2] x2 # Visa element 2, 3 och 4 i vektorn y234 y234 &lt;- y[c(2,3,4)] y234 I Console redovisas &gt; # Spara element nummer 2 till vektorn x2 &gt; x2 &lt;- x[2] &gt; x2 &gt; [1] 1 &gt; # Spara element 2, 3 och 4 till vektorn y234 &gt; y234 &lt;- y[c(2,3,4)] &gt; y234 &gt; [1] 3 5 6 Det går att tillämpa negativ indexering för att exkludera angivna element. Resterande element i en vektor behålls då. Skriv in nedanstående i scriptet, spara, och kör. # Spara element nummer 1,3,4,5 till vektorn x1345 x1345 &lt;- x[-2] x1345 # Spara element 1 och 5 till vektorn y15 y15 &lt;- y[-c(2,3,4)] y15 I Console redovisas nedanstående. &gt; # Spara element nummer 1,3,4,5 till vektorn x1345 &gt; x1345 &lt;- x[-2] &gt; x1345 &gt; [1] 3 1 5 0 &gt; # Spara element 1 och 5 till vektorn y15 &gt; y15 &lt;- y[-c(2,3,4)] &gt; y15 &gt; [1] 2 9 En fördel med indexering är att det blir väldigt lätt att byta värden på olika element i en vektor. Detta blir relevant när variabler ska kodas om, eller när bortfall ska kodas på något specifikt sätt. Koden nedan byter värde på det tredje elementet i en specifik vektor Skriv i nedanstående i scriptet, spara och kör. &gt; # Ändra element 3 från 1 till 4 &gt; x_new &lt;- x # Skapar en ny vektor x_new &gt; x_new # Skriver ut den nya vektorn. Notera vilket värde element nr. 3 har. &gt; [1] 3 1 1 5 0 &gt; x_new[3] &lt;- 4 # Byter värde på element nr. 3 i x_new. Det nya värdet är 4 &gt; x_new # Skriver ut x_new igen. Notera att värdet på element nr. 3 har ändrats &gt; [1] 3 1 4 5 0 &gt; &gt; &gt; # Ändra element 3 från &quot;Iceland&quot; till 4 &gt; nordic_countries_new &lt;- nordic_countries &gt; &gt; nordic_countries_new &gt; [1] &quot;Denmark&quot; &quot;Finland&quot; &quot;Iceland&quot; &quot;Norway&quot; &quot;Sweden&quot; &gt; nordic_countries_new[3] &lt;- 4 &gt; nordic_countries_new &gt; [1] &quot;Denmark&quot; &quot;Finland&quot; &quot;4&quot; &quot;Norway&quot; &quot;Sweden&quot; Ovanstående kod illustrerar två vanliga företeelser: Vektorerna x_new och nordic_countries_new skapas på grund av att användaren ofta önskar behålla originalvektorerna x och nordic_countries. För säkerhets skull är det alltid bra att behålla ursprungsdata. Om ett numeriskt värde läggs till en vektor med bokstäver så tolkas det numeriska värdet som ett tecken, dvs \"4\". Det illustrerar vikten av vara noga med om vektorerna är numeric eller character 3.2.2 Vektorer och logiska operatorer I praktiken är det vanligt att vilja välja ut element som uppfyller vissa specifika krav ur en vektor, särskilt när variabler ska kodas om. För att underlätta denna typ indexering kan logiska operatorer operatorer användas. Logiska operatorer används för att låta R testa huruvida ett specifikt påstående är sant eller falskt. Några vanliga och viktiga logiska operatorer är: &gt; är större än. &lt; är mindre än. &gt;= större än eller lika med &lt;= mindre än eller lika med == lika med. != är ej lika med x|y \\(x\\) eller \\(y\\) x &amp; y \\(x\\) och \\(y\\) För att illustrera hur logiska operatorer används för att skriva logiska satser används ett par väldigt grundläggande exempel &gt; 2 &gt; 1 # Testar huruvida 2 är större än 1 &gt; [1] TRUE &gt; &gt; 2 &lt; 1 # Testar huruvida 2 är mindre än 1 &gt; [1] FALSE &gt; &gt; 2 == 1 # Testar huruvida 2 är lika med 1 &gt; [1] FALSE Som synes är resultaten precis vad som förväntas. div.yellow{ background-color:#FFFA94; border-radius: 5px; padding: 20px;} Övningsuppgift Antag att du har skapat objekten a &lt;- 1, b &lt;- 4, och c &lt;- \"Finland\". Utan att använda R, försök komma på huruvida följande logiska satser kommer resultera i TRUE eller FALSE a &gt; b a == b (b - 3) &lt;= a a &gt; 3 b &gt; 3 (a &gt; 2) | (b &gt; 3) (a &gt; 0) &amp; (a &lt;= 1) c == \"Norge\" c == \"Finland\" När du har ett svar till varje rad kan du skapa objekten a, b, och c och köra de logiska satserna i R för att se om du kom fram till rätt svar. Logiska operatorer kan även användas på hela vektorer, och de utvärderar då påståendet enskilt för vektorns alla element. Koden nedan exemplifierar detta &gt; c(1, 2, 3, 4, 5) &gt;= 3 &gt; [1] FALSE FALSE TRUE TRUE TRUE &gt; &gt; c(1, 2, 3, 4, 5) != 3 &gt; [1] TRUE TRUE FALSE TRUE TRUE Logiska satser kan användas för att indexera vektorer. Se koden nedan som exempel. &gt; x &gt; [1] 3 1 1 5 0 &gt; &gt; x &gt; 3 &gt; [1] FALSE FALSE FALSE TRUE FALSE &gt; &gt; x[x &gt; 3] &gt; [1] 5 Satsen x &gt; 3 visar TRUE för de element i \\(x\\) som är större än 3, och FALSE för övriga element. När en logisk sats används inuti en hakparentes tolkar R det som att användaren vill välja ut de värden för vilka den logiska satsen är sann. I den logiska satsen ovan är det bara det fjärde elementet som är TRUE, och därför väljs bara det fjärde elementet ur \\(x\\). På liknande sätt kan vektorn \\(x\\) användas för att välja ut vissa specifika värden ur vektorn \\(y\\), som i koden nedan. &gt; y &gt; [1] 2 3 5 6 9 &gt; &gt; x &gt; 3 &gt; [1] FALSE FALSE FALSE TRUE FALSE &gt; &gt; y[x &gt; 3] &gt; [1] 6 Den sista raden i kodsnutten ovan väljer ut de element i \\(y\\), för vilka motsvarande element i \\(x\\) är större än 3. Detta kan låta lite påhittat och ganska abstrakt, men denna typ av indexering fyller en viktig funktion i R. Antag, till exempel, att en forskare studerar ingångslöner för studenter som tagit examen i statsvetenskap vid UU. Forskaren frågar ett urval av gamla studenter vad de fick för ingångslön på sin första jobb efter examen och även vilken typ av examen de tog ut. Säg att informationen matas in i två vektorer, lon och examen för lön respektive examenstyp. Med hjälp av logiska operatorer är det då enkelt att göra analyser grupp för grupp, eftersom löner för studenter med masterexamen lätt kan plockas ut som lon[examen == \"master\"]. Om det är många studenter i urvalet är det mycket smidigare att göra på detta sättet än att gå igenom datamaterialet och ange vilka positioner studenterna i varje grupp har. Fler exempel på hur logiska operatorer kan användas för indexering följer nedan. Fortsätt scriptet genom att skriva in nedanstående kod. Spara och kör koden. # Visa element i vektor y som är större än 6 y[y &gt; 6] # Visa element i vektor y som är större än eller lika med 6 y[y &gt;= 6] # Visa element i vektor y från positioner där x har värden lika med 1. # (Kräver att x och y har lika många element) y[x == 1] # Visa element i vektor där x är ej lika med 1. y[x != 1] # Visa element i vektor y från positioner där nordic_countries == &quot;Finland&quot; y[nordic_countries == &quot;Finland&quot;] I Console visas &gt; # Visa element i vektor y som är större än 6 &gt; y[y &gt; 6] &gt; [1] 9 &gt; # Visa element i vektor y som är större än eller lika med 6 &gt; y[y &gt;= 6] &gt; [1] 6 9 &gt; # Visa element i vektor y från positioner där x har värden lika med 1. &gt; # (Kräver att x och y har lika många element) &gt; y[x == 1] &gt; [1] 3 5 &gt; # Visa element i vektor där x är ej lika med 1. &gt; y[x != 1] &gt; [1] 2 6 9 &gt; # Visa element i vektor y från positioner där nordic_countries == &quot;Finland&quot; &gt; y[nordic_countries == &quot;Finland&quot;] &gt; [1] 3 Precis som förut skapas i regel nya vektorer när logiska operatorer tillämpas. Skriv in nedanstående i scriptet, spara och kör koden. # Välj vektorn som är större än eller lika med 6 ysub &lt;- y[y &gt;= 6] # Skapa en binär vektor x_bin som är 1 om x är större än eller lika med 3 och 0 # om x är mindre än 3. Börja med att skapa en tom vektor med motsvarande antal element # och fyll sedan denna med saknade värden. x_bin &lt;- c(NA, NA, NA, NA, NA) x_bin[x &gt;=3] &lt;- 1 x_bin[x &lt; 3] &lt;- 0 # Skapa en tom vektor med 5 element och fyll därefter denna vektor med # data om landet är skandinaviskt eller ej scandinavia &lt;- c(NA, NA, NA, NA, NA) scandinavia[nordic_countries == &quot;Finland&quot;] &lt;- &quot;Not scandinavia&quot; scandinavia[nordic_countries == &quot;Denmark&quot;] &lt;- &quot;Scandinavia&quot; scandinavia[nordic_countries == &quot;Sweden&quot;] &lt;- &quot;Scandinavia&quot; scandinavia[nordic_countries == &quot;Norway&quot;] &lt;- &quot;Scandinavia&quot; scandinavia[nordic_countries == &quot;Iceland&quot;] &lt;- &quot;Not scandinavia&quot; scandinavia I Console visas &gt; # Välj vektorn som är större än eller lika med 6 &gt; ysub &lt;- y[y &gt;= 6] &gt; &gt; # Skapa en binär vektor x_bin som är 1 om x är större än eller lika med 3 och 0 &gt; # om x är mindre än 3. Börja med att skapa en tom vektor med motsvarande antal element &gt; # och fyll sedan denna med saknade värden. &gt; x_bin &lt;- c(NA, NA, NA, NA, NA) &gt; x_bin[x &gt;=3] &lt;- 1 &gt; x_bin[x &lt; 3] &lt;- 0 &gt; x &gt; [1] 3 1 1 5 0 &gt; x_bin &gt; [1] 1 0 0 1 0 &gt; # Skapa en tom vektor med 5 element och fyll därefter denna vektor med &gt; # data om landet är skandinaviskt eller ej &gt; scandinavia &lt;- c(NA, NA, NA, NA, NA) &gt; scandinavia[nordic_countries == &quot;Finland&quot;] &lt;- &quot;Not scandinavia&quot; &gt; scandinavia[nordic_countries == &quot;Denmark&quot;] &lt;- &quot;Scandinavia&quot; &gt; scandinavia[nordic_countries == &quot;Sweden&quot;] &lt;- &quot;Scandinavia&quot; &gt; scandinavia[nordic_countries == &quot;Norway&quot;] &lt;- &quot;Scandinavia&quot; &gt; scandinavia[nordic_countries == &quot;Iceland&quot;] &lt;- &quot;Not scandinavia&quot; &gt; scandinavia &gt; [1] &quot;Scandinavia&quot; &quot;Not scandinavia&quot; &quot;Not scandinavia&quot; &quot;Scandinavia&quot; &gt; [5] &quot;Scandinavia&quot; Ovanstående moment är viktigt. Här illustreras nämligen en grundläggande princip för skapandet av nya variabel, dvs först skapa en tom vektor som sedans fylls med information. Även om det finns alternativa kompaktare sätt att koda om vektorer (och följaktligen variabler), är det ovanstående tillvägagångssätt som rekommenderas starkt på denna kurs. Nästa steg är att använda den logiska operatorn &amp;. Skriv in nedanstående i scriptet, spara och kör koden. # Skapa en vektor z_trinary som är # 1 om z är mindre än eller lika med 1 # 2 om z är större än 1 eller mindre än eller lika med 5 # 3 om z är större än 5 z_trinary &lt;- c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA) z_trinary[z &lt;= 1] &lt;- 1 z_trinary[(z &gt; 1) &amp; (z &lt;=5)] &lt;- 2 z_trinary[z &gt; 5] &lt;- 3 z z_trinary # Skapa en binära variabler z1, z2 och z3 z1 &lt;- c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA) z1[z_trinary == 1] &lt;- 1 z1[z_trinary == 2] &lt;- 0 z1[z_trinary == 3] &lt;- 0 z2 &lt;- c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA) z2[z_trinary == 1] &lt;- 0 z2[z_trinary == 2] &lt;- 1 z2[z_trinary == 3] &lt;- 0 z3 &lt;- c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA) z3[z_trinary == 1] &lt;- 0 z3[z_trinary == 2] &lt;- 0 z3[z_trinary == 3] &lt;- 1 z1 z2 z3 I Console redovisas följande. &gt; # Skapa en vektor z_trinary som är &gt; # 1 om z är mindre än eller lika med 1 &gt; # 2 om z är större än 1 eller mindre än eller lika med 5 &gt; # 3 om z är större än 5 &gt; z_trinary &lt;- c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA) &gt; z_trinary[z &lt;= 1] &lt;- 1 &gt; z_trinary[(z &gt; 1) &amp; (z &lt;= 5)] &lt;- 2 &gt; z_trinary[z &gt; 5] &lt;- 3 &gt; z &gt; [1] 3 1 1 5 0 2 3 5 6 9 &gt; z_trinary &gt; [1] 2 1 1 2 1 2 2 2 3 3 &gt; &gt; # Skapa en binära variabler z1, z2 och z3 &gt; z1 &lt;- c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA) &gt; z1[z_trinary == 1] &lt;- 1 &gt; z1[z_trinary == 2] &lt;- 0 &gt; z1[z_trinary == 3] &lt;- 0 &gt; &gt; z2 &lt;- c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA) &gt; z2[z_trinary == 1] &lt;- 0 &gt; z2[z_trinary == 2] &lt;- 1 &gt; z2[z_trinary == 3] &lt;- 0 &gt; &gt; z3 &lt;- c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA) &gt; z3[z_trinary == 1] &lt;- 0 &gt; z3[z_trinary == 2] &lt;- 0 &gt; z3[z_trinary == 3] &lt;- 1 &gt; z1 &gt; [1] 0 1 1 0 1 0 0 0 0 0 &gt; z2 &gt; [1] 1 0 0 1 0 1 1 1 0 0 &gt; z3 &gt; [1] 0 0 0 0 0 0 0 0 1 1 Ett par viktiga punkter att komma ihåg är Arbetsgången är att en ny vektor skapas, vilken sedan fylls på. För en binär variabel skulle vi teoretiskt kunna använda operatorn !=, men detta kan dels leda till att NA i en vektor kodas till 0, dels att datatvätten blir mindre noggrann. Ovanstående metodik för att skapa ny variabler är transparent. Använd parenteser för att undvika eventuella fel, som till exempel var fallet med (z &gt; 1) &amp; (z &lt;= 5). Avslutningsvis ska vi använda den logiska operatorn |. Skriv in nedanstående i scriptet, spara och kör koden. # Om z1 = 1 eller z3 = 1, så ska w_bin = 1. # Om z2 = 1 så ska d_bin = 0. # Skapa en tom vektor w_bin d_bin &lt;- c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA) d_bin[(z1 == 1) | (z3 == 1)] &lt;- 1 d_bin[z2 == 1] &lt;- 0 z1 z2 z3 d_bin # Om landet är Norge eller Island och x &gt; 4 eller w &gt; -50 så ska vi sätta NA y_new &lt;- y y_new[( (nordic_countries == &quot;Iceland&quot;) | (nordic_countries == &quot;Norway&quot;) ) &amp; ( (x &gt; 4) | (w &gt; -50) ) ] &lt;- NA nordic_countries x y_new I Console ser vi utskrifterna. Om du inte har förstått koden, så kan du jämföra vektorerna och se varför d_bin och y_new har fått de värden som de har. &gt; # Om z1 = 1 eller z3 = 1, så ska w_bin = 1. &gt; # Om z2 = 1 så ska d_bin = 0. &gt; &gt; # Skapa en tom vektor w_bin &gt; d_bin &lt;- c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA) &gt; d_bin[(z1 == 1) | (z3 == 1)] &lt;- 1 &gt; d_bin[z2 == 1] &lt;- 0 &gt; z1 &gt; [1] 0 1 1 0 1 0 0 0 0 0 &gt; z2 &gt; [1] 1 0 0 1 0 1 1 1 0 0 &gt; z3 &gt; [1] 0 0 0 0 0 0 0 0 1 1 &gt; d_bin &gt; [1] 0 1 1 0 1 0 0 0 1 1 &gt; &gt; &gt; # Om landet är Norge eller Island och x &gt; 4 eller w &gt; -50 så ska vi sätta NA &gt; y_new &lt;- y &gt; y_new[( (nordic_countries == &quot;Iceland&quot;) | (nordic_countries == &quot;Norway&quot;) ) &amp; + ( (x &gt; 4) | (w &gt; -50) ) ] &lt;- NA &gt; nordic_countries &gt; [1] &quot;Denmark&quot; &quot;Finland&quot; &quot;Iceland&quot; &quot;Norway&quot; &quot;Sweden&quot; &gt; x &gt; [1] 3 1 1 5 0 &gt; y_new &gt; [1] 2 3 NA NA 9 Ovanstående sätt att förändra och skapa vektorer används mycket ofta i R och kan hantera mycket av den praktiska datahantering som du kommer att stöta på under denna kurs, men också ute i arbetslivet. Som tidigare nämnts finns andra sätt att åstadkomma samma resultat, som kanske till och med i specifika avseenden är bättre, men utgå på denna kurs från kod som presenteras här. Det bör nämnas att det naturligtvis finns mycket mer att lära sig om hur logiska operatorer fungerar. Till exempel skapar nedanstående kod den sista datatypen som nämndes inledningsvis, dvs logical data. Skriv in nedanstående i scriptet, spara och kör koden. # Ger en logisk vektor (x &gt; 4) ## [1] FALSE FALSE FALSE TRUE FALSE # Multiplikation med en logisk vektor 1*(x &gt; 4) ## [1] 0 0 0 1 0 4*(x &gt; 4) ## [1] 0 0 0 4 0 Spara scriptet kap3_objekt_och_funktioner.R. 3.3 Matriser En matris är ett tvådimensionellt dataobjekt bestående av rader och kolumner, till skillnad från en vektor som bara består av en rad. Notera ordningen, dvs en matris storlek anges först med rader, sedan med kolumner. Analogt med c(), som kombinerar element till en vektor, används cbind() och rbind() för att binda ihop vektorer radvis eller kolumnvis till matriser. En matris måste innehålla element av samma datatyp, vilket innebär att det inte går att binda samman numeriska vektorer med vektorer som innehåller bokstäver. En matris kan även skapas direkt med kommandot matrix() som transformerar en vektor med \\(k\\) antal element till en matris bestående motsvarande antal element fördelat på antal rader och kolumner. I regel är det enklast att använda cbind() eller rbind(), och det är dessa två som rekommenderas under denna kurs. För två vektorer \\(x\\) och \\(y\\) kommer rbind(x, y) skapa en matris där varje vektor utgör en egen rad, och cbind(x, y) skapa en matris där varje vektor utgör en rad. Såväl matriser som rbind() och cbind() förstås bäst med hjälp av exempel. Se koden nedan får ett par sådana. Fortsätt scriptet kap3_objekt_och_funktioner.R och skriv in nedanstående kod. Spara scriptet och kör. # Skapa en matris genom att binda samman x och y radvis. Matrisen får 2 rader och 5 kolumner m1 &lt;- rbind(x, y) m1 # Skapa en matris genom att binda samman x, y, n och x radvis. Matrisen får 5 rader och 4 kolumner. m2 &lt;- cbind(x, y, n, x) m2 # Skapa en matris genom att binda samman x och ymis radvis. Matrisen får 5 rader och 2 kolumner. m3 &lt;- rbind(x, ymis) m3 # Skapa med matrix() en matris med två rader och 5 kolumner. # Matrisen fylls på kolumnvis och notera att detta inte blir samma som m1. m4 &lt;- matrix(z, 2, 5) m4 # Skapa med matrix() en matris med fem rader och 2 kolumner. # I detta fall är de två första kolumnerna i m2 samma som m5. m5 &lt;- matrix(z, 5, 2) m5 I Console visas &gt; # Skapa en matris genom att binda samman x och y radvis. Matrisen får 2 rader och 5 kolumner &gt; m1 &lt;- rbind(x, y) &gt; m1 &gt; [,1] [,2] [,3] [,4] [,5] &gt; x 3 1 1 5 0 &gt; y 2 3 5 6 9 &gt; # Skapa en matris genom att binda samman x, y, n och x radvis. Matrisen får 5 rader och 4 kolumner. &gt; m2 &lt;- cbind(x, y, u, x) &gt; m2 &gt; x y u x &gt; [1,] 3 2 150 3 &gt; [2,] 1 3 150 1 &gt; [3,] 1 5 150 1 &gt; [4,] 5 6 150 5 &gt; [5,] 0 9 150 0 &gt; # Skapa en matris genom att binda samman x och ymis radvis. Matrisen får 5 rader och 2 kolumner. &gt; m3 &lt;- rbind(x, ymis) &gt; m3 &gt; [,1] [,2] [,3] [,4] [,5] &gt; x 3 1 1 5 0 &gt; ymis 3 NA 6 3 6 &gt; # Skapa med matrix() en matris med två rader och 5 kolumner. &gt; # Matrisen fylls på kolumnvis och notera att detta inte blir samma som m1. &gt; m4 &lt;- matrix(z, 2, 5) &gt; m4 &gt; [,1] [,2] [,3] [,4] [,5] &gt; [1,] 3 1 0 3 6 &gt; [2,] 1 5 2 5 9 &gt; # Skapa med matrix() en matris med fem rader och 2 kolumner. &gt; # I detta fall är de två första kolumnerna i m2 samma som m5. &gt; m5 &lt;- matrix(z, 5, 2) &gt; m5 &gt; [,1] [,2] &gt; [1,] 3 2 &gt; [2,] 1 3 &gt; [3,] 1 5 &gt; [4,] 5 6 &gt; [5,] 0 9 div.green{ background-color:#abd4b3; border-radius: 5px; padding: 20px;} Använd på denna kurs rbind() och cbind() vid skapande av matriser. Det är då mindre risk för för missförstånd var elementen hamnar i matrisen. Ibland är det, precis som var fallet med vektorer, önskvärt att välja ut ett eller flera enskilda element i en matris. Precis som tidigare används hakparenteser, men eftersom matriser har såväl rader som kolumner indexeras de på ett liter annorlunda sätt. Ta matrisen m2 från ovan som exempel. Matrisen har fem rader och fyra kolumner, och som synes kan varje element identifieras med hjälp av ett radnummer och ett kolumnnumer. Elementet längst upp till vänster, till exempel, finns på rad 1 i kolumn 1. Generellt gäller att en matris indexeras som matris[rad, kolumn]. och precis som för vektorer går det att plocka ut flera element på en gång. Se koden nedan för exempel. För åtkomst till element krävs nu, eftersom matriser består av rader och kolumner, att bägge dimensionerna anges. Först anges radnummer, sedan kolumnnummer. Skriv in nedanstående kod i scriptet, spara och kör. # Visa element på rad 2 och kolumn 3 m1[2,3] # Visa element på rad 2 och alla kolumner m1[2,] # Visa element på alla rader och kolumner 3 m1[,3] # Visa m2[c(1,2),] I Console visas &gt; # Visa element på rad 2 och kolumn 3 &gt; m1[2,3] &gt; y &gt; 5 &gt; # Visa element på rad 2 och alla kolumner &gt; m1[2,] &gt; [1] 2 3 5 6 9 &gt; # Visa element på alla rader och kolumner 3 &gt; m1[,3] &gt; x y &gt; 1 5 &gt; # Visa &gt; m2[c(1,2),] &gt; x y u x &gt; [1,] 3 2 150 3 &gt; [2,] 1 3 150 1 Notera att de mellersta raderna m1[2,] och m1[,3] lämnar en indexposition blank. I det första fallet tolkar R den tomma positionen som alla kolumner, och kommer därför välja ut hela rad två. Motsvarande gäller för det andra fallet. Precis som vad gäller vektorer går det att utföra elementvisa beräkningar. Det kräver att matriserna har samma antal rader och kolumner. Det går även att utföra räkneoperationer med en konstant. Observera att elementvis multiplikation inte är detsamma som matematikens matrismultiplikation. Det är naturligtvis inga problem att i R använda matrismultiplikation, men detta går utanför kursens avgränsning. För att exemplfiera räkneoperationer med matriser, skriv in nedanstående kod i scriptet, spara och kör. # Addera element i matris 1 med element i matris 3 m1 + m3 # Multiplicera element i matris 1 med element i matris 3. OBS! Detta är inte matrismultiplikation! m1 * m3 # Dividera element i matris 1 med en konstant u m1 / u # Nedanstående är INTE det som inom matematiken benämns inversen av en matris, utan är 1/elementvärde 1/m1 I Console visas &gt; # Addera element i matris 1 med element i matris 3 &gt; m1 + m3 &gt; [,1] [,2] [,3] [,4] [,5] &gt; x 6 2 2 10 0 &gt; y 5 NA 11 9 15 &gt; # Multiplicera element i matris 1 med element i matris 3. OBS! Detta är inte matrismultiplikation! &gt; m1 * m3 &gt; [,1] [,2] [,3] [,4] [,5] &gt; x 9 1 1 25 0 &gt; y 6 NA 30 18 54 &gt; # Dividera element i matris 1 med en konstant n &gt; m1 / u &gt; [,1] [,2] [,3] [,4] [,5] &gt; x 0.02000000 0.006666667 0.006666667 0.03333333 0.00 &gt; y 0.01333333 0.020000000 0.033333333 0.04000000 0.06 &gt; # Nedanstående är INTE det som inom matematiken benämns inversen av en matris, utan är 1/elementvärde &gt; 1/m1 &gt; [,1] [,2] [,3] [,4] [,5] &gt; x 0.3333333 1.0000000 1.0 0.2000000 Inf &gt; y 0.5000000 0.3333333 0.2 0.1666667 0.1111111 Spara scriptet kap3_objekt_och_funktioner.R. Det går att tillämpa logiska operatorer även på matriser, men den extra dimensionen gör detta omständligt. Dessutom konstaterade vi att matrisen endast kan hantera en datatyp. Därför introduceras en tredje typ av dataobjekt som bättre sätt hanterar datamaterial. Det är dock bra att känna till att vid mer avancerad användning av R är matriser dock ett mycket viktigt verktyg. 3.4 Data frames En data frame är i praktiken det vanligaste objektet för dataanalys. En data frame har två dimensioner (rader och kolumner) precis som en matris, men kan till skillnad från matrisen måste inte alla kolumner ha samma datatyp. Vad som dock krävs är att alla element i en och samma kolumn har samma datatyp. Vidare innehåller en data frame detaljerad information om exempelvis variabelnamn och variabeltyp. För att skapa en data frame används data.frame() och vi ska nu se på några exempel. Observera att en data frame även anger information om radnummer, dessa nummer är dock inte definierade som en sepearat kolumn. Skriv nedanstående kod i kap3_objekt_och_funktioner.R, spara och kör. # Skapa en data frame genom att ange vektorer df &lt;- data.frame(x, y, nordic_countries) df # Skapa en data frame genom att transformera en matris. data.frame(m3) I Console erhålls följande resultat. &gt; # Skapa en data frame genom att ange vektorer &gt; df &lt;- data.frame(x, y, nordic_countries) &gt; df &gt; x y nordic_countries &gt; 1 3 2 Denmark &gt; 2 1 3 Finland &gt; 3 1 5 Iceland &gt; 4 5 6 Norway &gt; 5 0 9 Sweden &gt; # Skapa en data frame genom att transformera en matris. &gt; data.frame(m3) &gt; X1 X2 X3 X4 X5 &gt; x 3 1 1 5 0 &gt; ymis 3 NA 6 3 6 För åtkomst till element finns nu flera alternativ och vi ska se på de två vanligaste: Precis som för matriser kan användaren använda hakparenteserna ´[]´ Genom att använda $ väljs en variabel i en dataframe. Det går sedan att använda hakparentes för att välja ett element i denna variabel. Nedanstående kod illustrerar de bägge metoderna. Skriv nedanstående kod i kap3_objekt_och_funktioner.R, spara och kör. # Visa kolumn 3 df[,3] # Visa variabeln nordic countries, dvs kolumn 3 df$nordic_countries # Visa värdet i rad 2 och kolumn 1 df[2,1] # Visa värdet för element 2 i variabeln x. df$x[2] I Console erhålls följande resultat. &gt; # Visa kolumn 3 &gt; df[,3] &gt; [1] &quot;Denmark&quot; &quot;Finland&quot; &quot;Iceland&quot; &quot;Norway&quot; &quot;Sweden&quot; &gt; df$nordic_countries &gt; [1] &quot;Denmark&quot; &quot;Finland&quot; &quot;Iceland&quot; &quot;Norway&quot; &quot;Sweden&quot; &gt; # Visa värdet i rad 2 och kolumn 1 &gt; df[2,1] &gt; [1] 1 &gt; df$x[2] &gt; [1] 1 Användning av enbart hakparentes är alltså ekvivalent med datahantering med hjälp av $ och sedan position. Även om koden med $ ofta blir längre, så blir koden mer lättförståelig jämfört med indexering för kolumn. Dessutom slipper man problemet med att indexeringen kan ändras om nya variabler adderas till det data frame man arbetar med eller om det på något annat sätt förändras. Med $ går det även enkelt att addera nya variabler till en data frame. Skriv nedanstående kod i kap3_objekt_och_funktioner.R, spara och kör. # Skapa variabeln sample_size baserat på n som bara har ett värde df$sample_size &lt;- u df # Skapa en variabel som heter ysq baserat på y i samma data frame. df$ysq &lt;- df$y^2 df # Skapa en tom variabel som heter x_cat df$x_cat &lt;- NA df I Console visas nedanstående. &gt; # Skapa variabeln sample_size baserat på n som bara har ett värde &gt; df$sample_size &lt;- u &gt; df &gt; x y nordic_countries sample_size &gt; 1 3 2 Denmark 150 &gt; 2 1 3 Finland 150 &gt; 3 1 5 Iceland 150 &gt; 4 5 6 Norway 150 &gt; 5 0 9 Sweden 150 &gt; # Skapa en variabel som heter ysq baserat på y i samma data frame. &gt; df$ysq &lt;- df$y^2 &gt; df &gt; x y nordic_countries sample_size ysq &gt; 1 3 2 Denmark 150 4 &gt; 2 1 3 Finland 150 9 &gt; 3 1 5 Iceland 150 25 &gt; 4 5 6 Norway 150 36 &gt; 5 0 9 Sweden 150 81 &gt; # Skapa en tom variabel som heter x_bin &gt; df$x_bin &lt;- NA &gt; df &gt; x y nordic_countries sample_size ysq x_bin &gt; 1 3 2 Denmark 150 4 NA &gt; 2 1 3 Finland 150 9 NA &gt; 3 1 5 Iceland 150 25 NA &gt; 4 5 6 Norway 150 36 NA &gt; 5 0 9 Sweden 150 81 NA Med $ förenklas även användningen av de logiska operatorerna och det blir enkelt att transformera variabler och även skapa mindre data frames. Skriv nedanstående kod i kap3_objekt_och_funktioner.R, spara och kör. # Ändra värdet på sample_size för Danmark från 150 till 300 df$sample_size[df$nordic_countries == &quot;Denmark&quot;] &lt;- 300 df # Ändra värden från NA till 1 i x_cat om x är större än 2 df$x_cat[x &gt; 2] &lt;- 1 df # Ändra värden från NA till 0 i x_cat om x är mindre än eller lika 2 df$x_cat[x &lt;= 2] &lt;- 0 df # Skapa ett nytt data frame som vi kallas df_sweden bestående av bara rader för Sverige df_sweden &lt;- df[df$nordic_countries== &quot;Sweden&quot;, ] df_sweden I Console visas nedanstående. &gt; # Ändra värdet på sample_size för Danmark från 150 till 300 &gt; df$sample_size[df$nordic_countries == &quot;Denmark&quot;] &lt;- 300 &gt; df &gt; x y nordic_countries sample_size ysq x_bin &gt; 1 3 2 Denmark 300 4 NA &gt; 2 1 3 Finland 150 9 NA &gt; 3 1 5 Iceland 150 25 NA &gt; 4 5 6 Norway 150 36 NA &gt; 5 0 9 Sweden 150 81 NA &gt; # Ändra värden från NA till 1 i x_cat om x är större än 2 &gt; df$x_cat[x &gt; 2] &lt;- 1 &gt; df &gt; x y nordic_countries sample_size ysq x_bin x_cat &gt; 1 3 2 Denmark 300 4 NA 1 &gt; 2 1 3 Finland 150 9 NA NA &gt; 3 1 5 Iceland 150 25 NA NA &gt; 4 5 6 Norway 150 36 NA 1 &gt; 5 0 9 Sweden 150 81 NA NA &gt; # Ändra värden från NA till 0 i x_cat om x är mindre än eller lika 2 &gt; df$x_cat[x &lt;= 2] &lt;- 0 &gt; df &gt; x y nordic_countries sample_size ysq x_bin x_cat &gt; 1 3 2 Denmark 300 4 NA 1 &gt; 2 1 3 Finland 150 9 NA 0 &gt; 3 1 5 Iceland 150 25 NA 0 &gt; 4 5 6 Norway 150 36 NA 1 &gt; 5 0 9 Sweden 150 81 NA 0 &gt; # Skapa ett nytt data frame som vi kallas df_sweden bestående av bara rader för Sverige &gt; df_sweden &lt;- df[df$nordic_countries== &quot;Sweden&quot;, ] &gt; df_sweden &gt; x y nordic_countries sample_size ysq x_bin x_cat &gt; 5 0 9 Sweden 150 81 NA 0 Vi kommer under kursens gång upprepade gånger att återkomma till data frames och titta närmare olika typer av sätt att hantera detta objekt. Vi avslutar med några grundläggande kommandon för att hantera data frames. Skriv in nedanstående i scriptet kap3_objekt_och_funktioner.R. Spara och kör. # Med names() anges namnen i ett dataframe. names(df) # Med colnames() namnges variablerna i en data frame colnames(df) &lt;- c(&quot;age&quot;, &quot;income&quot;, &quot;nordic_countries&quot;) names(df) Vi ser nu i Console att variabelnamnen har ändrats. &gt; # Med names() anges namnen i ett dataframe. &gt; names(df) &gt; [1] &quot;x&quot; &quot;y&quot; &quot;nordic_countries&quot; &quot;sample_size&quot; &gt; [5] &quot;ysq&quot; &quot;x_bin&quot; &quot;x_cat&quot; &gt; # Med colnames() namnges variablerna i en data frame &gt; colnames(df) &lt;- c(&quot;age&quot;, &quot;income&quot;, &quot;nordic_countries&quot;) &gt; names(df) &gt; [1] &quot;age&quot; &quot;income&quot; &quot;nordic_countries&quot; NA &gt; [5] NA NA NA div.green{ background-color:#abd4b3; border-radius: 5px; padding: 20px;} Hantering av data är av lättförklarliga skäl väldigt viktigt i R. Det tar inledningsvis tid att lära, men är samtidigt något som varje användare måste vara trygg med. Värt att nämna är att nästan alltid finns alternativa sätt arbeta med data i R och vad som presentas här är är endast ett alternativ. På denna kurs rekommenderas starkt att ni följer den metodik som presenteras här. Visserligen är den inte effektivast, varken i termer av beräkningstid eller längd på kod, men det är ett transparent arbetssätt som minimerar risken för att fel uppkommer. Datahanteringen är ofta en tidskrävande del i statistisk undersökning och stor noggrannhet är viktigt. Det går inte att tillräckligt betona hur betydelsefull datahanteringen är i en undersökning. En korrekt analys kräver ju korrekt data. 3.5 Funktioner En funktion utför en eller flera operationer på objekt i R. Exakt vad funktionen gör varierar från fall till fall, det vara allt från att utföra enkla räkneoperationer på data i en vektor, till komplicerade beräkningar och förändringar av data. Oftast sparas resultatet från en funktion som ett nytt objekt. En funktion har i regel också olika argument som gör det möjligt för användaren att anpassa specifika delar av funktiones verkan, till exempel har vissa funktioner argument som gör att alla beräkningar bortser från data som är NA. Den något mer avancerade R-användaren kan enkelt skapa egna funktioner, vilket är styrka eftersom R då blir väldigt flexibelt. Att skapa egna funktioner ingår emellertid inte på denna kurs utan analyserna som utförs på kursen kommer hanteras av redan implementerade funktioner i R. Denna introduktionen till funktioner är därför relativt kortfattad. Det enklaste sättet att introducera funktioner är genom ett antal exempel. Skriv in nedanstående kod i scriptet kap3_objekt_och_funktioner.R, spara och kör. # sum() är en funktion för att summera värdera i en vektor. Summan sparas i objektet summax summax &lt;- sum(x) summax # length() beräknar antalet element i en vektor och spara i objektet n n &lt;- length(x) n I Console får erhålls följande. &gt; # sum() är en funktion för att summera värdera i en vektor. Summan sparas i objektet sumx &gt; sumx &lt;- sum(x) &gt; sumx &gt; [1] 10 &gt; # length() beräknar antalet element i en vektor och spara i objektet n &gt; n &lt;- length(x) &gt; n &gt; [1] 5 Du har nu tillämpat funktionen sum() som summerar alla elementvärden i en vektor, dvs \\(\\sum_{i=1}^n x_i=x_1 + x_2 + \\cdots + x_k\\). Funktionen length() räknar antalet element i en given vektor. Med hjälp av dessa funktioner går det nu på enkelt sätt att beräkna medelvärdet, \\(\\bar{x}=\\dfrac{1}{n}\\sum_{i=1}^n x_i\\), och stickprovsvariansen, \\(s^2=\\dfrac{1}{n-1}\\sum_{i=1}^n(x_i - \\bar{x})^2\\), för \\(x\\). Notera att standardavvikelsen är \\(s = \\sqrt{s^2}\\). Skriv in nedanstående kod i scriptet kap3_objekt_och_funktioner.R, spara och kör. # Beräkna medelvärdet av en vektor sample.mean &lt;- (1/n)*sumx sample.mean # Beräkna stickprovsvarians s^2 med det sum() samt de sparade objekten xbar och n sample.variance &lt;- (1/(n-1))*sum( (x - xbar)^2 ) sample.variance I Console visas nedanstående. &gt; # Beräkna medelvärdet av en vektor &gt; sample.mean &lt;- (1/n)*sumx &gt; sample.mean &gt; [1] 2 &gt; &gt; # Beräkna stickprovsvarians s^2 med hjälp av sum() samt de sparade objekten xbar och n &gt; sample.variance &lt;- (1/(n-1))*sum( (x - sample.mean)^2 ) &gt; sample.variance &gt; [1] 4 Naturligtvis finns i R färdiga funktioner för beräkning av såväl medelvärde som stickprovsvarians. Skriv in nedanstående kod i scriptet kap3_objekt_och_funktioner.R, spara och kör. # Beräkna medelvärdet av en vektor xbar &lt;- mean(x) xbar # Beräkna stickprovsvariansen av en vektor s2 &lt;- var(x) s2 I Console visas nedanstående. &gt; # Beräkna medelvärdet av en vektor &gt; xbar &lt;- mean(x) &gt; xbar &gt; [1] 2 &gt; # Beräkna stickprovsvariansen av en vektor &gt; s2 &lt;- var(x) &gt; s2 &gt; [1] 4 Resultatet är samma som det tidigare, den enda skillnaden är att funktionerna mean() och var() förenklar ytterligare. Men vi genom genom detta också en förståelse för vilka formler som mean() och var() använder sig av. Skriv in nedanstående kod i scriptet kap3_objekt_och_funktioner.R, spara och kör. # Beräkna medelvärdet av ymis, en vektor med att bortfall ymis.mean &lt;- mean(ymis) ymis.mean # Beräkna medelvärdet av ymis, en vektor med att bortfall # ymisbar &lt;- mean(ymis, na.rm = TRUE) ymisbar I Console presenteras följande. &gt; # Beräkna medelvärdet av ymis, en vektor med att bortfall &gt; ymis.mean &lt;- mean(ymis) &gt; ymis.mean &gt; [1] NA &gt; # Beräkna medelvärdet av ymis, en vektor med att bortfall &gt; # &gt; ymisbar &lt;- mean(ymis, na.rm = TRUE) &gt; ymisbar &gt; [1] 4.5 Eftersom R ger att \\(y_1 + y_2 + NA + \\cdots + y_k = NA\\) blir även medelvärdet NA. För att komma runt detta problem kan argumentet na.rm sättas till TRUE i funktionen. När na.rm = TRUE inkluderas tar funktionen före beräkning bort saknade värden. Default-inställningen är dock att detta argument är satt till FALSE. Det innebär att medelvärdet ymisbar är beräknat på de fyra element som inte är NA. Många av funktionerna som finns i R har ett flertal argument, som alla kan användas för att påverka hur/vad funktionen räknar eller bär sig åt. I regel är det svårt att hålla reda på alla argument som finns i olika funktioner även för en person som har flera års erfarenhet av programmering i R, och det är absolut inget som krävs av studenter på denna kurs. För att underlätta tillämpning av funktioner har R en mängd hjälpfiler som lätt går att läsa i RStudio, i princip finns alltid en hjälpfil per funktion. Dessa filer innehåller information om vad funktionen gör, vanliga argument, och ibland även exempel på hur funktionen kan användas. För att få tillgång till en hjälpfil används kommandot help(), och inom parenteserna anges namet på den funktion som är av intresse. För att öppna hjälpfunktionen för mean() används koden help(mean). I nedre högra panelen i Rstudio under fliken Help visas nu information om den funktionen. I hjälpfilen står under Usage hur funktionen kan användas, alltså mean(x, ...), där de tre punkterna betyder att fler argument kan specificeras om så behövs. Under ## Default S3 method: anges funktionens grundinställningar. I koden mean(x, trim = 0, na.rm = FALSE, ...) syns alltså att argumentet trim specificeras som 0, och argumentet na.rm specificeras som FALSE om inget annat anges. Under Arguments beskrivs vad argumenten har för funktion. Till exempel står det att na.rm: a logical value indicating whether NA values should be stripped before the computation proceeds. Detta stämmer överens med det sätt na.rm användes tidigare. Hjälpfilerna är ofta svåra att förstå vid första anblick, men exemplen längst ner är i regel lite mer klargörande. På denna kurs kommer funktioner att introduceras efterhand. Funktioner är nämligen något som man lär sig genom tillämpning och inte genom att lära sig utantill i förväg. Dock kan det vara bra att ha en lista över de vanliga funktionerna så man vet vilka möjligheter som finns. En sådan lista finns att hitta här Vi börjar här med några grundläggande funktioner som är användbara. Skriv in nedanstående kod i scriptet kap3_objekt_och_funktioner.R, spara och kör. # Skapa en vektor som repeterar värde 3 fem gånger x1 &lt;- rep(3, 5) x1 # Skapa en vektor som repeterar NA fem gånger xNA &lt;- rep(NA, 5) xNA # Funktion som skapar en sekvens från 2 till 3 med steglängd 0.25 x2 &lt;- seq(from = 2, to = 3, by = 0.25) x2 # Skapa en en vektor av element som repeterats x3 &lt;- c(rep(1, 3), rep(4, 2), rep(9, 10)) x3 # Funktion för att summera information i ett objekt summary(ymis) # Funktion skapar ett histogram hist(x) # Funktion som skapar ett spridningsdiagram plot(x, y) I Console visas &gt; # Skapa en vektor som repeterar värde 3 fem gånger &gt; x1 &lt;- rep(3, 5) &gt; x1 &gt; [1] 3 3 3 3 3 &gt; # Skapa en vektor som repeterar NA 10 fem gånger &gt; xNA &lt;- rep(NA, 5) &gt; xNA &gt; [1] NA NA NA NA NA &gt; # Funktion som skapar en sekvens från 2 till 3 med steglängd 0.25 &gt; x2 &lt;- seq(from = 2, to = 3, by = 0.25) &gt; x2 &gt; [1] 2.00 2.25 2.50 2.75 3.00 &gt; # Skapa en en vektor av element som repeterats &gt; x3 &lt;- c(rep(1, 3), rep(4, 2), rep(9, 10)) &gt; x3 &gt; [1] 1 1 1 4 4 9 9 9 9 9 9 9 9 9 9 &gt; # Funktion för att summera information i ett objekt &gt; summary(ymis) &gt; Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s &gt; 3.0 3.0 4.5 4.5 6.0 6.0 1 &gt; # Funktion skapar ett histogram &gt; hist(x) &gt; # Funktion som skapar ett spridningsdiagram &gt; plot(x, y) Ett antal frekvent använda samt viktiga funktioner för dataobjekt listas här nedan. Titta igenom koden här nedan och försök förstå vad funktionerna gör. &gt; # Funktion för att beskriva datatyp &gt; class(y) &gt; [1] &quot;numeric&quot; &gt; class(nordic_countries) &gt; [1] &quot;character&quot; &gt; # Funktion för att beskriva objekt &gt; str(y) &gt; num [1:5] 2 3 5 6 9 &gt; str(nordic_countries) &gt; chr [1:5] &quot;Denmark&quot; &quot;Finland&quot; &quot;Iceland&quot; &quot;Norway&quot; &quot;Sweden&quot; &gt; # Funktion för att ta reda på storleken på matris eller data frame &gt; dim(m1) &gt; [1] 2 5 &gt; dim(df) &gt; [1] 5 7 &gt; dim(df)[1] &gt; [1] 5 &gt; dim(df)[2] &gt; [1] 7 &gt; # Funktion för att beräkna längden av en vektor &gt; length(x) &gt; [1] 5 &gt; # Funktionen ls() listar alla objekt i minnet &gt; ls() &gt; [1] &quot;d_bin&quot; &quot;df&quot; &quot;df_sweden&quot; &gt; [4] &quot;m1&quot; &quot;m2&quot; &quot;m3&quot; &gt; [7] &quot;m4&quot; &quot;m5&quot; &quot;my_first_vec&quot; &gt; [10] &quot;n&quot; &quot;nordic_countries&quot; &quot;nordic_countries_new&quot; &gt; [13] &quot;s2&quot; &quot;sample.mean&quot; &quot;sample.variance&quot; &gt; [16] &quot;scandinavia&quot; &quot;sumx&quot; &quot;u&quot; &gt; [19] &quot;v&quot; &quot;w&quot; &quot;x&quot; &gt; [22] &quot;x_bin&quot; &quot;x_new&quot; &quot;x_nordic_countries&quot; &gt; [25] &quot;x1&quot; &quot;x1345&quot; &quot;x2&quot; &gt; [28] &quot;x3&quot; &quot;xbar&quot; &quot;xNA&quot; &gt; [31] &quot;y&quot; &quot;y_new&quot; &quot;y15&quot; &gt; [34] &quot;y234&quot; &quot;ymis&quot; &quot;ymis.mean&quot; &gt; [37] &quot;ymisbar&quot; &quot;ysub&quot; &quot;z&quot; &gt; [40] &quot;z_trinary&quot; &quot;z1&quot; &quot;z2&quot; &gt; [43] &quot;z3&quot; &gt; # Funktionen rm() raderar ett objekt &gt; rm(y) &gt; # Se om objektet y finns kvar &gt; ls() &gt; [1] &quot;d_bin&quot; &quot;df&quot; &quot;df_sweden&quot; &gt; [4] &quot;m1&quot; &quot;m2&quot; &quot;m3&quot; &gt; [7] &quot;m4&quot; &quot;m5&quot; &quot;my_first_vec&quot; &gt; [10] &quot;n&quot; &quot;nordic_countries&quot; &quot;nordic_countries_new&quot; &gt; [13] &quot;s2&quot; &quot;sample.mean&quot; &quot;sample.variance&quot; &gt; [16] &quot;scandinavia&quot; &quot;sumx&quot; &quot;u&quot; &gt; [19] &quot;v&quot; &quot;w&quot; &quot;x&quot; &gt; [22] &quot;x_bin&quot; &quot;x_new&quot; &quot;x_nordic_countries&quot; &gt; [25] &quot;x1&quot; &quot;x1345&quot; &quot;x2&quot; &gt; [28] &quot;x3&quot; &quot;xbar&quot; &quot;xNA&quot; &gt; [31] &quot;y_new&quot; &quot;y15&quot; &quot;y234&quot; &gt; [34] &quot;ymis&quot; &quot;ymis.mean&quot; &quot;ymisbar&quot; &gt; [37] &quot;ysub&quot; &quot;z&quot; &quot;z_trinary&quot; &gt; [40] &quot;z1&quot; &quot;z2&quot; &quot;z3&quot; Avslutningsvis finns en viktig funktion som används för att radera alla objekt. Det är rm(list = ls()). Var försiktig med denna funktion eftersom alla objekt i minnet försvinner! Emellertid är god idé inleda ett script för en dataanlys med denna kod för att säkerställa att minnet är tomt innan ny data läses in. På så vis undviker vi konflkter mellan objekt. Förslagsvis används denna funktion inför varje ny övningsuppgift, såvida inte uppgiftern bygger på information från tidigare uppgifter. 3.6 Sammanfattning div.red{ background-color:#F5B7B1; border-radius: 5px; padding: 20px;} Du ska kunna känna till de viktigaste datatyperna som R arbetar med. känna till de tre olika typerna av dataobjekt. genomföra enklare datahantering, till exempel förändra ett specifikt elements värde i ett dataobjekt eller att med logiska operationer välja ut data från ett objekt. genomföra logiska operationer på vektorer och data frames. använda $ i data frames. tillämpa några vanliga funktioner i R samt även informera dig om vad en funktion gör genom att använda hjälp-filen. div.green{ background-color:#abd4b3; border-radius: 5px; padding: 20px;} Bortfall komplicerar analyser och kodas på olika sätt. Det hanteras separat i kapitlet om bortfall. På denna kurs används baspaketen i R för datahantering. I R-universumet finns även en uppsättning paket som tillhör det så kallade tidyverse(). Här finns paket med en mängd funktioner som förenklar avancerad datahantering betydligt och som också följer en logik som många uppskattar. På denna kurs och för de flesta användare är dock baspaketen i R fullt tillräckligt. Kategorivariabler kallas faktorer och kommer att hanteras utförligt i kapitlet om faktorer. Att ha en förståelse för hur man hanterar faktorer är nödvändigt inom all dataanlys. I R används även typiska programmeringssatser innehållande for, if, else, while. Detta är emellertid inte något som vi kommer att arbeta med på denna kurs. 3.7 Övningar Övning 3.1 Du har ett stickprov betående av observationerna \\(4,-2,5,6,8\\). Beräkna medelvärdet. Beräkna standardavvikelsen. Beräkna variationsbredden. Beräkna det geometriska medelvärdet för de positiva värden \\(4, 5, 6, 8\\). Beräkna det geometriska medelvärdet för alla värden \\(4, -2, 5, 6, 8\\). Visa svar # Töm minnet inför denna Övning 3.1 rm(list = ls()) x &lt;- c(4,-2,5,6,8) mean(x) [1] 4.2 Svar: Medelvärdet är 4.2 Standardavvikelsen \\(s=\\sqrt{\\dfrac{\\sum_{i=1}^n (x_i -\\bar{x})^2}{n-1}}\\) beräknas med sd(x) [1] 3.768289 Svar: Standardavvikelsen är 3.768 Variationsbredden, dvs skillnaden mellan det största och det minsta värdet är max(x) - min(x) ## [1] 10 Svar: Variationsbredden är är 10. Det geometriska medelvärdet \\(\\bar{x}_g=(x_1\\cdot x_2 \\cdot \\cdots \\cdot x_n)^{1/n}\\) kan i R beräknas med # Välj enbart positiva värden xpos &lt;- x[x &gt; 0] # Du kan beräkna det geometriska medelvärdet med exp( mean(log(xpos)) ) ## [1] 5.566315 # Alternativt kan du funktionen geometric.mean() # i paketet psych. Aktivera paketet och beräkna. library(&quot;psych&quot;) geometric.mean(xpos) ## [1] 5.566315 Svar: Det geometriska medelvärdet är 3.95. Det geometriska medelvärdet \\[\\bar{x}_g=(x_1\\cdot x_2 \\cdot \\cdots \\cdot x_n)^{1/n}\\] kan i R beräknas med (4 * (-2) * 5 * 6 * 8)^(1/5) ## [1] NaN geometric.mean(x) ## Warning in log(x): NaNs produced ## [1] 5.566315 Svar: Eftersom en observation är negativ blir NaN, vilket betyder Not a Number. Det går alltså inte att beräkna. Övning 3.2 Ett slumpmässigt urval ger följande observationer \\(0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1\\),där \\(1=Arbetslös\\) och \\(0=Förvärvsarbetande\\). Beräkna andelen arbetslösa i stickprovet. Visa svar Andelen arbetslösa beräkna i R med # Töm minnet inför denna Övning 3.2 rm(list = ls()) x &lt;- c(0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1) mean(x) ## [1] 0.3846154 Svar: Andelen arbetslösa i stickprovet är 0.38. Övning 3.3 Kosumentpriset 2006-2011 är Table 3.1: Konsumentprisindex (KPI) 2006-2011 2006 284.2 2007 290.5 2008 300.6 2009 299.7 2010 303.5 2011 311.4 Med hur många procent har prisnivån förändrats från 2007 till 2010? Visa svar Beräkning i R ger # Töm minnet inför denna Övning 3.2 rm(list = ls()) year &lt;- c(2006, 2007, 2008, 2009, 2010, 2011) kpi &lt;- c(284.22, 290.51, 300.61, 299.66, 303.46, 311.423) percent_change &lt;- 100*(kpi[year == 2010]/kpi[year == 2007])-100 Svar: Prisnivån har ökat med 4.458%. Övning 3.4 Låt observationerna \\(4,-2,5,6,8\\) vara obundet slumpmässigt urval från en normalfördelad population. Genomför en hypotesprövning på 5% signifikansnivå för att testa medelvärdet i population är skild från 1. Visa svar Vi observerar \\(x=\\{4,-2,5,6,8\\}.\\) Hypoteser: \\(H_0:\\mu=1\\) vs \\(H_1:\\mu \\neq 1\\) Antaganden: Variabeln \\(x\\) är normalfördelad i populationen. Populationsvariansen \\(\\sigma^2\\) är okänd i populationen. Vi har ett litet stickprov, \\(n=5\\). Testfunktionen ges av \\(t=\\dfrac{\\bar{x}-\\mu}{\\sqrt{s^2/n}}\\). Denna teststatistika är \\(t\\)-fördelad med \\(n-1\\) frihetsgrader om nollhypotesen är sann. Beslutregel: \\(\\alpha=0.05\\). Tvåsidigt test, förkasta därför \\(H_0\\) om \\(|t_{obs}| &gt; t_{krit} = t_{4,\\alpha/2=0.025} = 2.776\\) # Töm minnet inför uppgift 3.4 rm(list = ls()) # Vi ska lösa uppgiften först illusterat med objekt i R # Sedan löser vi den med den inbyggda funktionen för t-test # Bestäm värden som ska in i testfunktionen x &lt;- c(4,-2,5,6,8) n &lt;- length(x) xbar &lt;- mean (x) s2 &lt;- var(x) mu &lt;- 1 # Beräkna testfunktionen tobs &lt;- (xbar - mu)/sqrt(s2/n) # Se var testfunktionensvärde hamnar i en t-fördelning med n-1 frihetsgrader # Funktionen pt() ger för ett givet t-värde vänstersvanssannolikheter i en t-fördelning med n-1 frihetsgrader # Eftersom vi vill ha sannolikheten i högra svansen måste vi därför ta 1-pt(). # Slutligen, eftersom mothypotesen är två-sidig multipliceras p-värdet med 2. p_value &lt;- 2*(1 - pt(tobs, (n-1))) p_value [1] 0.1304116 t.test(x, mu = 1) One Sample t-test data: x t = 1.8989, df = 4, p-value = 0.1304 alternative hypothesis: true mean is not equal to 1 95 percent confidence interval: -0.4789485 8.8789485 sample estimates: mean of x 4.2 t.test(x, mu = 1)$p.value [1] 0.1304116 Svar: Efterom \\(p=0.13\\) kan vi på 5% signifikansnivå inte påvisa att medelvärdet i populationen är skilt från 1. Notera att detta inte innebär att vi visar att medelvärdet är 1. Övning 3.5 Du observerar följande vektorer \\(x = \\{4,7,2,4,6,NA,89\\}\\) och \\(y=\\{7,3, 2, 5,6, 5 , 7\\}\\) och \\(z=\\{Alfa, bravo, Charlie, delta, Echo, Foxtrot, Golf\\}\\) Använd indexering för att summera element 2 och 3 i \\(x\\) med element 6 och 7 i \\(y\\). Använd indexering för att ändra NA i \\(x\\) till 999. Använd indexering för att korrigera så att bravo och delta inleds med versaler. Exkludera Echo och Foxtrot från \\(z\\). Visa svar # Töm minnet inför uppgift 3.5 rm(list = ls()) # a) x &lt;- c(4,7,2,4,6,NA,89) y &lt;- c(7,3,2,5,6,5,7) sumxy &lt;- x[c(2,3)] + y[c(6,7)] sumxy [1] 12 9 # b) x[6] &lt;- 999 x [1] 4 7 2 4 6 999 89 # c) z &lt;- c(&quot;Alfa&quot;, &quot;Bravo&quot;, &quot;Charlie&quot;, &quot;Delta&quot;, &quot;Echo&quot;, &quot;Foxtrot&quot;, &quot;Golf&quot;) z[2] &lt;- &quot;Bravo&quot; z[4] &lt;- &quot;Delta&quot; z [1] &quot;Alfa&quot; &quot;Bravo&quot; &quot;Charlie&quot; &quot;Delta&quot; &quot;Echo&quot; &quot;Foxtrot&quot; &quot;Golf&quot; # d) zsub &lt;- z[-c(5,6)] zsub [1] &quot;Alfa&quot; &quot;Bravo&quot; &quot;Charlie&quot; &quot;Delta&quot; &quot;Golf&quot; Övning 3.6 Du observerar följande datapunkter \\(x = \\{4,7,2,4,6\\}\\) och \\(y=\\{7,3, 2, 5,6\\}\\). Använd minsta-kvadratmetoden och beräkna koefficienterna \\(a\\) och \\(b\\) i regressionslinjen \\(y=a + bx\\). Använd koefficienterna och ge en prediktion för \\(y\\) givet att \\(x=7\\). Beräkna residualen för \\(x=7\\) Beräkna residualspridningen. Visa svar Riktningskoefficienten ges av \\[b=\\dfrac{\\sum_{i=1}^n(x_i-\\bar{x})(y_i-\\bar{y})}{\\sum_{i=1}^n(x_i - \\bar{x})^2}\\] och interceptet ges av \\[ a = \\bar{y} - b \\bar{x}\\]. Vi tillämpar formlerna i R. # Töm minnet inför uppgift 3.5 rm(list = ls()) x &lt;- c(4,7,2,4,6) y &lt;- c(7,3, 2, 5,6) xbar &lt;- mean(x) ybar &lt;- mean(y) b &lt;- sum( (x - xbar)*(y - ybar))/sum( (x - xbar)^2) b [1] 0.2105263 a &lt;- ybar - b*xbar a [1] 3.631579 # Det finns en inbyggd funktion i R för regressionsanalys, vilken används senare på kursen. Svar: Riktningskoefficienten beräknas till \\(b=0.2105\\), vilket tolkas som att om \\(x\\) ökar en enhet så ökar \\(y\\) i genomsnitt med \\(0.2105\\) enheter. Interceptet beräknas till \\(a=3.632\\), vilket tolkas som medelvärdet för \\(y\\) när \\(x=0\\). Notera att det i beräkningarna Använd koefficienterna från regressionslinjen och sätt in värdet \\(x=7\\). xp &lt;- 7 yhat &lt;- a + b*xp yhat [1] 5.105263 Svar: Prediktionen \\(\\hat{y}=\\) 5.105. Detta är punkten på regressionslinjen när \\(x=7\\) och vår bästa gissning för det \\(y\\)-värde en individ med värdet \\(x=7\\) kommer att ha. En residual är skillnaden mellan ett predicerat värde och det faktiska observerade värdet, \\(\\hat{\\varepsilon}=y_i - \\hat{y}\\). Eftersom \\(y=3\\) när \\(x=7\\) så residualen residual &lt;- y[x == xp] - yhat Svar: Residualen för \\(x=7\\) är -2.105. Residualspridningen ges av \\[s_\\varepsilon=\\sqrt{\\dfrac{\\sum_{i=1}^n(y_i - \\hat{y}_i)^2}{n-2}}= \\sqrt{\\dfrac{\\sum_{i=1}^n\\hat{\\varepsilon}_i^2}{n-2}}\\]. Vi beräknar på samma sätt som i c) övriga residualer, kvadrerar och summerar. residuals &lt;- y - (3.6316 + 0.2105*x) n &lt;- length(residuals) residual_spridning &lt;- sqrt( sum(residuals^2)/(n-2) ) residual_spridning [1] 2.347077 Svar: Residualspridningen är 2.347 (Notera att \\(\\sum_{i=1}^n \\varepsilon_i^2\\) kallas för residualkvadratsumman.) Övning 3.7 Du observerar följande data frame income &lt;- c(4,7,2,3,6,7,8,6) education &lt;- c(&quot;Low&quot;, &quot;Medium&quot;, &quot;Low&quot;, &quot;High&quot;, &quot;High&quot;, &quot;Low&quot;, &quot;Medium&quot;, &quot;High&quot;) df &lt;- data.frame(income, education) Skapa en ny variabel som heter high_edu som tar värdet 1 om education är High och 0 annars. Visa svar # Töm minnet inför uppgift 3.6 rm(list = ls()) income &lt;- c(4,7,2,3,6,7,8,6) education &lt;- c(&quot;Low&quot;, &quot;Medium&quot;, &quot;Low&quot;, &quot;High&quot;, &quot;High&quot;, &quot;Low&quot;, &quot;Medium&quot;, &quot;High&quot;) df &lt;- data.frame(income, education) df$high_edu &lt;- NA df$high_edu[df$education == &quot;High&quot;] &lt;- 1 df$high_edu[df$education == &quot;Low&quot;] &lt;- 0 df$high_edu[df$education == &quot;Medium&quot;] &lt;- 0 df income education high_edu 1 4 Low 0 2 7 Medium 0 3 2 Low 0 4 3 High 1 5 6 High 1 6 7 Low 0 7 8 Medium 0 8 6 High 1 Övning 3.8 Ett oljebolag är intresserat av att för ett äldre bostadsområde med \\(2\\,000\\) hus skatta andelen hus utan oljeeldning. Sakkunskapen säger att det sanna antalet hus utan oljeeldning är mellan 300 och 800 stycken. Precisionskravet är formulerat så att ett 95% konfidensintervall för andelen hus utan oljeeldning inte får bli längre än 0.05 procentenheter. Beräkna urvalsstorleken vid OSU om dragningen sker med återläggning. Visa svar Mål: Beräkna den nödvändiga stickprovsstorleken \\(n\\) om längden för ett 95% konfidensintervall för andelen i populationen får vara maximalt 0.05. Parameter: \\(p\\) = andelen hus utan oljeeldning i populationen. Estimator: \\(\\hat{p}\\) = andelen hus utan oljeeldning i stickprovet. Förutsättningar: OSU-MÅ ger att \\(E(\\hat{p})=p\\). Detta säger oss att andelen i stickprovprovet kan skatta andelen i populationen väntevärdesriktigt. \\(V(\\hat{p})=\\frac{p(1-p)}{n}\\). Detta är variansen i andelsestimatorns samplingfördelning. Vi antar att \\(p=\\dfrac{800}{2000}=0.4\\) eftersom detta ger störst varians givet den information vi har. Vi utgår från att \\(np(1-p)&gt;5\\) kommer att vara uppfyllt. Vi måste sedan kontrollera att antagandet faktiskt är uppfyllt! Annars gäller inte CGS och approximativ normalfördelning. Precisionskravet i termer av konfidensintervallets längd kan nu formuleras \\[ 0.05\\geq 2\\cdot 1.96\\sqrt{\\frac{0.4(1-0.4)}{n}}. \\] Det går att ändra värdena på \\(n\\) i R för att se vilket \\(n\\) som ger vår önskade minsta stickprovsstorlek. Vi vill att uttrycket nedan ska vara lika med eller mindre än 0.05. # Töm minnet inför uppgift 3.7 rm(list = ls()) n &lt;- seq(10, 10000, 1) p &lt;- 0.4 # Z-värdet från fördelning N(0,1) med sannolikheten 0.025 i högre svansen. z &lt;- qnorm(0.975) # Längden för ett konfidensintervall ges av följande formel: KIlength &lt;- 2 * z * sqrt( ( p*(1-p) ) / n ) # Illustration över olika KIlength för olika värden stickprovsstorlekar n plot(n, KIlength, type = &quot;l&quot;) # Välj den minsta stickprovsstorleken som uppfyller precisionskravet KIlength &lt; 0.05 min( n[KIlength &lt; 0.05] ) [1] 1476 Svar: För att uppnå precisionskravet behövs ett stickprov med minst 1476 hus. Glöm inte att kontrollera CGS: \\(np(1-p)=1476\\cdot 0.4(1-0.4)=354.24 &gt; 5\\) så antagandet är uppfyllt. Det går även att lösa denna uppgift algebraiskt, genom att lösa ut $n i formeln ovan. Övning 3.9 En rikstäckande butikskedja säljer bland annat kompletta datorpaket. För ett visst paket tillåter man butikscheferna att själva sätta priset. För att centralt i företaget få en uppfattning om hur efterfrågan påverkas av priset gör man ett slumpmässigt urval om åtta butiker och inhämtar uppgifter om pris och försäljning under den närmast föregående månaden: pris &lt;- c(5500, 6000, 6500, 6000, 5000, 6500, 4500, 5000) antal &lt;- c(41, 38, 35, 40, 44, 38, 45, 42) Beräkna korrelationskoefficienten. Visa svar Korrelationskoefficentens ges av \\[r=\\dfrac{\\sum_{i=1}^n(x_i - \\bar{x})(y_i-\\bar{y})}{\\sqrt{\\sum_{i=1}^n(x_i - \\bar{x})^2 \\sum_{i=1}^n(y_i - \\bar{y})^2}}.\\] Vi kan enkelt tillämpa formeln. # Töm minnet inför uppgift 3.8 rm(list = ls()) x &lt;- c(5500, 6000, 6500, 6000, 5000, 6500, 4500, 5000) y &lt;- c(41, 38, 35, 40, 44, 38, 45, 42) xbar &lt;- mean(x) ybar &lt;- mean(y) sdx &lt;- sd(x) sdy &lt;- sd(y) r &lt;- sum( (x - xbar)*(y - ybar) ) /sqrt( sum( (x - xbar)^2)*sum( (y - ybar)^2) ) r [1] -0.9426412 Svar: Pearsons produktmomentkorrelationskoefficient är \\(-0.94\\), vilket tyder på ett mkt starkt negativt samband mellan pris och antal. Övning 3.10 Betrakta nedanstående vektor: some_letters &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;B&quot;, &quot;D&quot;, &quot;A&quot;, &quot;D&quot;, &quot;A&quot;) Använd R för att räkna hur många B det finns i vektorn. Visa svar # Töm minnet inför uppgift 3.8 rm(list = ls()) some_letters &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;B&quot;, &quot;D&quot;, &quot;A&quot;, &quot;D&quot;, &quot;A&quot;) length( some_letters[some_letters == &quot;B&quot;] ) [1] 2 Övning 3.11 Betrakta nedanstående vektorer: some_numbers &lt;- c(&quot;1&quot;, &quot;3&quot;, &quot;1&quot;, &quot;3&quot;, &quot;3&quot;) some_numbers_and_letters &lt;- c(&quot;2&quot;, &quot;4&quot;, &quot;-1&quot;, &quot;3&quot;, &quot;3&quot;, &quot;A&quot;, &quot;D&quot;) Använd R för att summera alla värdena i respektive vektor. Tips: Använd funktionen as.numeric(). Visa svar # Töm minnet inför uppgift 3.10 rm(list = ls()) some_numbers &lt;- c(&quot;1&quot;, &quot;3&quot;, &quot;1&quot;, &quot;3&quot;, &quot;3&quot;) some_numerics &lt;- as.numeric( some_numbers ) class(some_numbers) [1] &quot;character&quot; class(some_numerics) [1] &quot;numeric&quot; sum(some_numerics) [1] 11 some_numbers_and_letters &lt;- c(&quot;2&quot;, &quot;4&quot;, &quot;-1&quot;, &quot;3&quot;, &quot;3&quot;, &quot;A&quot;, &quot;D&quot;) some_numerics_2 &lt;- as.numeric(some_numbers_and_letters) Warning: NAs introduced by coercion sum(some_numerics_2, na.rm = TRUE) [1] 11 Övning 3.12 Betrakta nedanstående vektorer. x1 &lt;- c(0.39, 0.76, -1.25, 0.28, 0.60, 0.66, 0.94, -0.18, -0.26, -1.83, -1.13, 0.45, 0.11, -1.03, 1.06, -0.08, 1.68, -1.02, 1.36, 1.58) x2 &lt;- c(-1.0, 1.5, 0.2, -0.5, -1.1, -0.2, -1.0, -1.3, -1.6, -1.2, -0.4, -1.3, -0.3, -0.7, 0.7, -2.5, -1.0, 2.1, 1.3, -1.3) x3 &lt;- c(5.94, -2.38, -0.16, 0.44, 0.70, 2.54, 2.12, 8.33, 0.57, 1.24, 0.05, -1.78, 2.53, -1.60, 2.77, 0.26, 1.48, 1.10, -8.00, 4.57) Skapa variabeln \\(x = x_1 + x_2 + x_3\\). Skapa variabeln \\(z\\), där \\(z=1\\) om \\(x &lt; 0\\), \\(z=2\\) om \\(0 \\leq x &lt; 5\\) och \\(z=3\\) om \\(x \\geq 5\\). Skapa de binära variblerna \\(v_1\\) som är 1 om \\(x_1 &gt; 0\\) och 0 annars, \\(v_2\\) som är 1 om \\(x_2 &gt; 0\\) och 0 annars, och \\(v_3\\) som är 1 om \\(x_3 &gt; 0\\) och 0 annars Skapa variabeln \\(v = v_1 + v_2 + v_3\\) som är en summa av de binära variablerna. Skapa en frekvenstabell för \\(v\\). Visa svar # Töm minnet inför uppgift 3.10 rm(list = ls()) x1 &lt;- c(0.39, 0.76, -1.25, 0.28, 0.60, 0.66, 0.94, -0.18, -0.26, -1.83, -1.13, 0.45, 0.11, -1.03, 1.06, -0.08, 1.68, -1.02, 1.36, 1.58) x2 &lt;- c(-1.0, 1.5, 0.2, -0.5, -1.1, -0.2, -1.0, -1.3, -1.6, -1.2, -0.4, -1.3, -0.3, -0.7, 0.7, -2.5, -1.0, 2.1, 1.3, -1.3) x3 &lt;- c(5.94, -2.38, -0.16, 0.44, 0.70, 2.54, 2.12, 8.33, 0.57, 1.24, 0.05, -1.78, 2.53, -1.60, 2.77, 0.26, 1.48, 1.10, -8.00, 4.57) # a) x &lt;- x1 + x2 + x3 # b) # Skapa en variabeln som består av NA som är lika lång som x z &lt;- rep(NA, length(x)) z[x &lt; 0] &lt;- 1 z[(x &gt;= 0) &amp; (x &lt; 5) ] &lt;- 2 z[x &gt; 10] &lt;- 3 z [1] NA 1 1 2 2 2 2 NA 1 1 1 1 2 1 2 1 2 2 1 2 # c) v1 &lt;- rep(NA, length(x1)) v1[x1 &gt; 0] &lt;- 1 v1[x1 &lt;= 0] &lt;- 0 v2 &lt;- rep(NA, length(x2)) v2[x2 &gt; 0] &lt;- 1 v2[x2 &lt;= 0] &lt;- 0 v3 &lt;- rep(NA, length(x3)) v3[x3 &gt; 0] &lt;- 1 v3[x3 &lt;= 0] &lt;- 0 # d) v &lt;- v1 + v2 + v3 v [1] 2 2 1 2 2 2 2 1 1 1 1 1 2 0 3 1 2 2 2 2 # e) sumv0 &lt;- sum(v == 0) sumv1 &lt;- sum(v == 1) sumv2 &lt;- sum(v == 2) sumv3 &lt;- sum(v == 3) frequencies &lt;- c(sumv0, sumv1, sumv2, sumv3) values &lt;- c(0, 1, 2, 3) frequency.table &lt;- cbind(values, frequencies) frequency.table values frequencies [1,] 0 1 [2,] 1 7 [3,] 2 11 [4,] 3 1 # Det finns i R också en inbyggd funktion table(), som vi ska använda oss av senare på kursen. Övning 3.13 Denna övning syftar till att förtydliga skillnaden mellan ett par summor som används ofta i statistiken, dessa är \\(\\sum_{i = 1}^{n}x_{i}^{2}\\) och \\(\\left(\\sum_{i = 1}^{n} x_{i}\\right)^{2}\\). Företäll dig att du har dragit ett stickprov av något slag, och att du samlat informationen i ditt stickprov i vektorn x &lt;- c(2, 4, 5, 3, 8, 4) Föreställ dig även att du vill beräkna standardavvikelsen i vektorn, men att du inte känner till funktionen sd(). Därför behöver du beräkna de båda summorna som presenteras ovan. Din uppgift är nu att Beräkna de båda summorna manuellt i R, utan att använda funktionen sum() Visa svar Börja med att rensa minnet och mata in vektorn i R rm(list = ls()) # Rensar minnet x &lt;- c(2, 4, 5, 3, 8, 4) # Matar in vektor I beräkningen av \\(\\sum_{i = 1}^{n}x_{i}^{2}\\) är det viktigt att komma ihåg att kvadreringen sker först, och summeringen sedan. Summan räknas alltså ut som # Kvadrera elementen först, summera sen x[1]^(2) + x[2]^(2) + x[3]^(2) + x[4]^(2) + x[5]^(2) + x[6]^(2) ## [1] 134 I beräkningen av \\(\\left(\\sum_{i = 1}^{n} x_{i}\\right)^{2}\\) sitter summan inom parenteser, och därför sker summering här innan kvadrering. Summan beräknas som # Summera elementen först, kvadrera sen (x[1] + x[2] + x[3] + x[4] + x[5] + x[6])^(2) ## [1] 676 Förenkla nu beräkningarna i a genom att använda sum() och räkna på vektorerna i sin helhet Visa svar Kom ihåg att \\(\\sum_{i = 1}^{n}x_{i}^{2}\\) kräver kvadrering innan summering. Börja därför med att kvadrera alla element i x. Resultatet blir x^(2) # Ser att elementen kvadreras var för sig ## [1] 4 16 25 9 64 16 För att slutföra beräkningen av den första summan återstår bara att stoppa in ovanstående uttryck i summeringsfunktionen sum(x^(2)) # Summerar över kvadrerade x ## [1] 134 Som synes blir resultatet samma som i a, men koden är mer kompakt och lättare att skriva För att beräkna den andra summan summeras värdena först, och sedan kvadreras hela summan. Detta innebär att kvadraten i detta fall måste sättas utanför summeringsfunktionen, precis som i koden här nedan x # Skriver ut x ## [1] 2 4 5 3 8 4 sum(x) # Summerar över alla x ## [1] 26 (sum(x))^(2) # Summerar alla x och kvadrerar summan ## [1] 676 Beräkningen ger samma resultat som i a, men koden är återigen mer kompakt och lättare att skriva Övning 3.14 Denna uppgift rör beräkningen av en stickprovsvarians, och syftar till att tydliggöra att likheten \\[ \\frac{\\sum_{i = 1}^{n}(x_{i} - \\bar{x})^{2}}{n-1} = \\frac{\\sum_{i = 1}^{n}x_{i}^{2} - \\frac{\\left(\\sum_{i = 1}^{n} x_{i}\\right)^{2}}{n}}{n-1} \\] faktiskt håller. Uttrycket till vänster kan, genom några delsteg, skrivas om och bli uttrycket som står till höger om likhetstecknet. Din uppgift är nu att beräkna värdet på varje del i utvecklingen, och på så sätt se att uttrycken är lika. Betrakta samma stickprov som i uppgift 3.13 x &lt;- c(2, 4, 5, 3, 8, 4) och utför följande beräkningar: Beräkna stickprovsmedelvärdet för x, och även antal element som finns i vektorn Visa svar Börja med att rensa minnet och mata in vektorn i R rm(list = ls()) # Rensar minnet x &lt;- c(2, 4, 5, 3, 8, 4) # Matar in vektor Medelvärdet beräknas nu som x_streck &lt;- mean(x) x_streck ## [1] 4.333333 och antalet element som n &lt;- length(x) n ## [1] 6 Beräkna värdet på \\(\\frac{1}{n - 1} \\sum_{i = 1}^{n} (x_{i} - \\bar{x})^{2}\\) Visa svar Använd \\(n\\) och \\(\\bar{x}\\) från a, och kom ihåg att kvadrering sker innan summan beräknas (1/(n-1)) * sum((x - x_streck)^(2)) ## [1] 4.266667 Beräkna värdet på \\(\\frac{1}{n - 1} \\sum_{i = 1}^{n} (x_{i} - \\bar{x})(x_{i} - \\bar{x})\\) Visa svar Ta bort kvadraten och multiplicera \\((x_{i} - \\bar{x})\\) med sig självt (1/(n-1)) * sum((x - x_streck) * (x - x_streck)) ## [1] 4.266667 Beräkna värdet på \\(\\frac{1}{n-1}\\sum_{i = 1}^{n} \\left(x_{i}^{2} - 2x_{i} \\bar{x} + \\bar{x}^{2} \\right)\\) Visa svar Multiplicera ut parenteserna innanför summan (1/(n-1)) * sum(x^(2) - 2*x*x_streck + x_streck^(2)) ## [1] 4.266667 Beräkna värdet på \\(\\frac{1}{n-1}\\left(\\left(\\sum_{i = 1}^{n} x_{i}^{2}\\right) - 2n\\bar{x} \\cdot \\bar{x} + n\\bar{x}^{2} \\right)\\) Visa svar Notera att summan enbart opererar på \\(x_{i}^{2}\\) (1/(n-1)) * (sum(x^(2)) - 2*n*x_streck*x_streck + n*x_streck^(2)) ## [1] 4.266667 Beräkna värdet på \\(\\frac{1}{n-1}\\left(\\left(\\sum_{i = 1}^{n} x_{i}^{2}\\right) - 2n\\bar{x}^{2} + n\\bar{x}^{2} \\right)\\) Visa svar Notera att summan enbart opererar på \\(x_{i}^{2}\\) (1/(n-1)) * (sum(x^(2)) - 2*n*x_streck^(2) + n*x_streck^(2)) ## [1] 4.266667 Beräkna värdet på \\(\\frac{1}{n-1}\\left(\\left(\\sum_{i = 1}^{n} x_{i}^{2}\\right) - n\\bar{x}^{2} \\right)\\) Visa svar Notera att summan enbart opererar på \\(x_{i}^{2}\\) (1/(n-1)) * (sum(x^(2)) - n*x_streck^(2)) ## [1] 4.266667 Beräkna värdet på \\(\\frac{\\sum_{i = 1}^{n} x_{i}^{2} - \\frac{\\left(\\sum_{i = 1}^{n} x_{i} \\right)^{2}}{n} }{n-1}\\) Visa svar Notera att summan enbart opererar på \\(x_{i}^{2}\\) (sum(x^(2)) - (sum(x)^(2))/n)/(n - 1) ## [1] 4.266667 Kontrollera att beräkningarna stämmer genom att jämföra med funktionen var() Visa svar Notera att summan enbart summerar över \\(x_{i}^{2}\\) var(x) ## [1] 4.266667 "],["läsa-in-och-spara-data.html", "Kapitel 4 Läsa in och spara data 4.1 Principer för organiserade datamaterial 4.2 Läsa in datamaterial med hjälp av kod 4.3 Läsa in datamaterial med hjälp av menyerna i RStudio 4.4 Spara datamaterial med hjälp av R 4.5 Övningar", " Kapitel 4 Läsa in och spara data body { text-align: justify} Avsikten med detta kapitel är att beskriva principerna för hur datamaterial är organiserade, hur datamaterial bör organiseras samt presentera de vanligaste formaten för att att importera och exportera data i R. För nybörjaren i R kan det vara uppmuntrande att känna till att datainläsning i en del fall kan vara omständligt och frustrerande, framförallt om datamaterialet inte är organiserat på ett konsekvent sätt. Misströsta därför inte ifall det dyker upp svårigheter. Det krävs mycket erfarenhet för att blir trygg med att arbeta med data. På denna kurs rekommenderas två format för att importera och spara datamaterial: textfiler (.txt eller .csv), vilket innebär att data sparas i textformat. R Data format (.RDS), vilket är det dataformat som R använder. I praktiken är det däremot nödvändigt att kunna importera och spara filer i Excel-format (.xlsx eller motsvarande), detta på grund av att många icke-statistiker använder Excel för att handskas med och analysera data. Vad gäller import och export av dataformat som är kopplade till andra statistikprogram (så som SAS, SPSS, Minitab) finns R-paket (t.ex. foreign och haven) avsedda för detta. När det gäller hantering av stora dataset (\\(&gt;10\\) Gigabyte i storlek) kan paket som data.table vara till hjälp. 4.1 Principer för organiserade datamaterial För att göra det så lätt som möjligt att importera och handskas med data i R är det en bra idé att följa principen om tidy data. Tidy kan i denna mening översättas som städat eller organiserat, och innebär att datamaterialet är strukturerat på ett specifikt sätt som gör det lätt att hantera. Hadley Wickham, som är chefsforskare på RStudio och adjungerad professor i statistik vid bland annat Standforduniversitetet i USA, har tagit fram tre regler som bör följas för att få ett städat datamaterial. Dessa är att Varje variabel måste ha en egen kolumn Varje observation måste ha sin egen rad Varje värde måste ha sin egen cell. På grund av det sätt som R  och i stort sett alla andra statistikprogram  arbetar med data blir risken för felberäkningar eller förvirringar mindre när ett datamaterial är strukturerat efter de tre punkterna som ges ovan. Som synes är data organiserat så att varje kolumn hör till en enskild variabel, varje rad hör till en enskild individ (observation), och varje cell hör till ett enskilt värde. För göra detta mer konkret kan det vara värt att betrakta en situation där du som analytiker blir ombedd att analysera ett datamaterial som har med Stockholms bostadsmarknad att göra. I detta datamaterial finns observationer som rör 1500 olika lägenheter i Stockholms innerstad, och informationen som delges är boarea, antal rum, avstånd till närmsta tunnelbana, avstånd till vattnet, och månadsavgift. Enligt principerna för städade datamaterial bör information för en specifik lägenhet finnas på en enskild rad. Varje rad bör även korsas av fem olika kolumner, som var och en innehåller information gällande en specifik variabel. På så sätt kommer varje cell i datamaterialet innehålla ett enskilt värde, och det kommer utan problem gå att utgöra vilken lägenhet samt vilken variabel varje cell hör till. För att ytterligare klargöra skillnaden mellan datamaterial som är städade och datamaterial som inte är städade följer ett par tabeller här nedan. Studera gärna dessa en stund, och fundera kring varför varje tabell innehåller ett städat/ostädat datamaterial. Boarea Rum, T-bana Vatten Avgift 52 2, 400 1500 3300 24 1, 150 2500 3967 Datamaterialet som presenteras i tabellen ovan är inte tidy, detta eftersom variablerna Rum och T-bana står skrivna i samma kolum, vilket medför att varje cell inte innehåller ett enskilt värde. För att förstå varför denna typ av struktur kan vara problematisk, fundera på hur du, med hjälp av kod, skulle kunna plocka ut enbart antalet rum i andra raden. df[2, 2] skulle inte fungera eftersom du då skulle få ut avståndet till närmsta tunnelbana också. Detta är en konsekvens av att datamaterialet inte är tidy, och försvårar analysarbetet avsevärt. För att datamaterialet ovan ska räknas som städat krävs att det ser ut som i tabellen här nedan. Boarea Rum T-bana Vatten Avgift 52 2 400 1500 3300 24 1 150 2500 3967 I tabellen ovan finns en klar struktur som följer det som förväntas av ett städat datamaterial. Det går lätt att identifiera alla värden i varje variabel, och det finns ingen analys att datamaterialets struktur ställer till problem i framtida analyser. Utöver dessa tre grundläggande strukturer finns en del rekommendationer för att underlätta programmeringen, göra den mer intuitiv, och ge den ett bättre flyt. Dessa ges i följande punktlista: Många program (t ex Excel) gör det möjligt att spara data som ren text istället för i progammets eget format. Spara alltid en kopia i textformat. Använd semikolon för att avgränsa kolumner när datamaterial sparas i textformat. Eftersom kommatecken används som decimaltecken på svenska, och avstånd eller TAB är svåra att se i en textfil då de påminner om blanksteg, undviks ofta enkla problem genom att använda semikolon. Försök att inte ändra något i ursprungsfilen där datamaterialet är sparat. Det är bättre att importera data till R och göra ändringar där om så är möjligt. Undvik att använda variabelnamn som innehåller blanksteg. Blanksteg har en specifik funktion i R, och om de används i variabelnamn blir dator lätt förvirrad, vilket leder till att beräkningarna inte fungerar som de ska. Istället rekommenderas att använda understreck eller punkt som avskiljare. Alltså bör en variabel döpas till antal_rum eller antal.rum snarare än bara antal rum. Låt bli att använda variabelnamn som innehåller specielle symboler, som t.ex. ?, $, *, +, #, (, ), -, /, }, {, |, &gt;, &lt; etc. Även sådana symboler kan ha specielle funktioner i R, och om de inkluderas i variabelnamn finns risk att R inte kan hantera dem. Gör det till en vana att bara använda understreck eller punkt. Inled aldrig ett variabelnamn med en siffra. Siffror är tillåtna i variabelnamn, men inte som första tecken. Namnen på kolumnerna i ett datamaterial måste alltid vara unike. Det får alltså inte finnas två kolumner med samma namn i ett och samma datamaterial. R är ett skiftlägeskänsligt språk, vilket innebär att det gör skillnad mellan versaler och gemener. Detta medför att variabler vid namn Husdjur och husdjur sparas som två olika objekt, eftersom ett versalt H i det första namnet skiljer variablerna åt. Om ett datamaterial innehåller tomma rader bör dessa raderas innan någon analys påbörjas. Tomma rader kan lätt betraktas som missing values av R, och kan därför komma att snedvrida analysen som ska utföras. Ersätt alla tomma celler med NA. NA står för not available i R, och celler som är kodade som NA är i regel relativt enkla att utesluta ur en analys. Radera alla kommentarer som finns i det ursprungliga datamaterialet. Ofta förekommer kommentarer antingen längst upp i själva datafilen, eller någonstans vid sidan av det data som är av intresse. För att dessa kommentarer inte ska störa analysen är det viktigt att radera dem. Även om datamaterialen i denna kurs i stort sett alltid kommer lagras i strukturerade textfiler eller formaterade som R-data är det högst sannolikt att många av er kommer behöva samla in och strukturera egna datamaterial i arbetslivet. Om (eller när) detta händer finns en artikel, skriven av Karl Broman och Kara Woo, som ger en bra sammanfattning av vad som bör tas i åtankte i sådana situationer. Nog om städade datamaterial. Resten av detta kapitel kommer handla om hur olika typer av datamaterial bör läsas in, för att sedan kunna använda dem i diverse statistiska analyser. 4.2 Läsa in datamaterial med hjälp av kod I R finns två huvudsakliga sätt att importera datamaterial, båda med sina egna för och nackdelar. Ett sätt är att skriva kod som får R att importera datamaterialet, och det andra är att använda menyerna som finns i RStudio för att generera kod, och på så sätt läsa in datamaterialet genom att bara klicka (ungefär som i Minitab eller SPSS). I denna del av kapitlet kommer dataimport med hjälp av kod att diskuteras. Fördelen med att importera datamaterial med hjälp av kod är att koden kan sparas i ett script, och därmed blir det lätt att sprida ut analysarbetet över flera tillfällen utan att behöva ödsla onödig tid på dataimport i början av varje tillfälle. Det medföljer alltså ingen klickföljd att memorera  som är fallet då menyer används  och det är relativt smidigt. Nackdelen är att det finns väldigt många olika sätt att formatera datamaterial, vilket medför att det krävs många olika funktioner och argument att lära sig och hålla reda på. Detta problem är inte lika framträdande när menyer används för att importera data. Som nämnts ovan kommer tre olika dataformat att diskuteras i detta kapitel. De två huvudsakliga är text-och CSV-filer och datafiler som är lagrade i R:s eget format RDS. Dessutom tillkommer datamaterial som är lagrade i Excelark. 4.2.1 Text- och CSV-filer Ett par format som ofta används för att lagra datamaterial är text- och CSV-filer. Textfiler har oftast .txt efter filnamnet, och CSV-filer har ändelsen .csv. CSV står för comma separated values, vilket betyder att kommatecken används för att skilja mellan kolumner på samma rad. Eftersom det finns många länder som använder kommatecken för att skriva ut decimaltal innefattar ordet comma i fallet CSV även semikolon. Strukturen i denna typ av filer är relativt enkel, och ett par exempel kommer att redovisas längre ner. De två funktionerna som används för att läsa in CSV-filer är read.csv() och read.csv2(). Båda dessa är varianter av funktionen read.table(), fast med argument som är förspecificerade för att passa specifika typer av datastruktur. I grund och botten går det alltid att använda read.table() så länge argumenten specificeras korrekt, men det går ofta att spara lite tid genom att istället anropa read.csv() eller read.csv2() direkt. Funktionernas vanligaste argument presenteras nedan, men det går att specificera funktionerna i stor detalj beroende på hur datafilen ser ut. De fem huvudsakliga argument som används är file anger filnamnet på filen (datamaterialet) som ska läsas in header specificerar om namnet på varje variabel finns på första raden i datamaterialet sep anger vilken typ av tecken som används för att skilja kolumner åt quote anger vilken typ av tecken som används som citationstecken för textvariabler dec anger vilket teckan som används som decimaltecken. Standardinställningarna för de tre funktionernas vanligaste argument anges nedan. read.csv(file, header = TRUE, sep = &quot;,&quot;, quote = &quot;\\&quot;&quot;, dec = &quot;.&quot;) read.csv2(file, header = TRUE, sep = &quot;;&quot;, quote = &quot;\\&quot;&quot;, dec = &quot;,&quot;) read.table(file, header = FALSE, sep = &quot; &quot;, quote = &quot;\\&quot;&#39;&quot;, dec = &quot;.&quot;) Som syns i kodsnutten är det standard för .csv-funktionerna att läsa in första raden i ett datamaterial som variabelnamn, men i read.table() antas första raden vara en del av datamaterialet.De tre funktionerna använder alla samma typ av citationstecken. Det som skiljer dem åt är vilka tecken so används för att åtskilja kolumner samt för att skriva ut decimaltal. Funktionen read.csv() använder kommatecken för att skilja mellan kolumner, och punkt för att dela upp decimaltal, samtidigt som read.csv2() använder semikolon för att skilja mellan kolumner och kommatecken för att dela upp decimaltal. read.table(), däremot, använder ett blanksteg för att skilja mellan kolumner, och en punkt för att dela upp decimaltal. För att lära sig läsa in text- och CSV-filer är det bra att gå igenom punktlistan ovan för varje datamaterial som ska läsas in, och på så sätt ta reda på hur argumenten är specificerade i det specifika datamaterialet. Här nedan finns ett utdrag ur textfilen animals1.csv. Titta gärna närmare på datamaterialet och försök identifiera hur vart och ett av argumenten i punktlistan ovan är specificerade. Försök sedan komma fram till vilken av de tre inläsningsfunktionerna som lämpar sig bäst för att läsa in datamaterialet. Svaret finns att läsa i fliken under kodsnutten. &quot;&quot;,&quot;animal&quot;,&quot;body&quot;,&quot;brain&quot; &quot;1&quot;,&quot;Lesser short-tailed shrew&quot;,0.005,0.14 &quot;2&quot;,&quot;Little brown bat&quot;,0.01,0.25 &quot;3&quot;,&quot;Big brown bat&quot;,0.023,0.3 &quot;4&quot;,&quot;Mouse&quot;,0.023,0.4 &quot;5&quot;,&quot;Musk shrew&quot;,0.048,0.33 &quot;6&quot;,&quot;Star-nosed mole&quot;,0.06,1 &quot;7&quot;,&quot;E. American mole&quot;,0.075,1.2 &quot;8&quot;,&quot;Ground squirrel&quot;,0.101,4 &quot;9&quot;,&quot;Tree shrew&quot;,0.104,2.5 &quot;10&quot;,&quot;Golden hamster&quot;,0.12,1 Visa svar I animals.csv är argumenten specificerade som header = TRUE eftersom variabelnamnen anges i den första raden sep = \",\" eftersom ett kommatecken används för att skilja cellerna i varje rad åt quote = \"\\\"\" eftersom helt vanliga citationstecken används för textvariabler dec = \".\" eftersom en vanlig punkt används som decimaltecken Dessa argument kan stämmas av med kodsnutten där standardargument anges, och då framkommer att funktionen read.csv() bör användas för att läsa in datamaterialet. Skriv därför in df1 &lt;- read.csv(file=\"D:/animals1.csv\") för att läsa in datamaterialet i R (notera att det räcker att bara skriva file = \"animals1.csv\" om filen finns i den mapp som är working directory). Eftersom animals.csv är en textfil kan filen öppnas i Notepad eller Textredigerare (eller mosvarande), och på så sätt kan alla text- och CSV-filer öppnas för att inspektera hur de är organiserade. Märk väl att de tecken som används för att skilja mellan celler, hantera textvariabler, och dela upp decimaltal alla är angivna inom citationstecken  t.ex. står det alltså sep = \",\" istället för bara sep = ,. Detta är standard i R, och det är något som är viktigt att komma ihåg. Notera även att citationstecken anges som \"\\\"\", detta eftersom två uppsättningar av citationstecken skulle förvirra datorn. Betrakta nu utdraget ur animals2.csv som finns här nedan, och försök att återigen identifiera hur argumenten är specificerade och vilken funktion som bör användas för att läsa in datamaterialet. Svaret finns än en gång att läsa i fliken under datamaterialet. &quot;&quot;;&quot;animal&quot;;&quot;body&quot;;&quot;brain&quot; &quot;1&quot;;&quot;Lesser short-tailed shrew&quot;;0,005;0,14 &quot;2&quot;;&quot;Little brown bat&quot;;0,01;0,25 &quot;3&quot;;&quot;Big brown bat&quot;;0,023;0,3 &quot;4&quot;;&quot;Mouse&quot;;0,023;0,4 &quot;5&quot;;&quot;Musk shrew&quot;;0,048;0,33 &quot;6&quot;;&quot;Star-nosed mole&quot;;0,06;1 &quot;7&quot;;&quot;E. American mole&quot;;0,075;1,2 &quot;8&quot;;&quot;Ground squirrel&quot;;0,101;4 &quot;9&quot;;&quot;Tree shrew&quot;;0,104;2,5 &quot;10&quot;;&quot;Golden hamster&quot;;0,12;1 Visa svar I animals2.csv är argumenten specificerade som header = TRUE eftersom variabelnamnen anges i den första raden sep = \";\" eftersom ett semikolon används för att skilja cellerna i varje rad åt quote = \"\\\"\" eftersom helt vanliga citationstecken används för textvariabler dec = \",\" eftersom ett kommatecken används som decimaltecken Efter avstämning med standardargumenten framgår att animals2.csv bör läsas in med funktionen read.csv2(), och koden df2 &lt;- read.csv2(file=\"D:/animals2.csv\") kan därför användas för att importera datamaterialet till R. Studera nu utdraget ur datamaterialet animals.txt som visas här nedanför, och försök identifiera argument och agöra vilken funktion som bör användas för att importera datamaterialet till R. &quot;animal&quot; &quot;body&quot; &quot;brain&quot; &quot;Lesser short-tailed shrew&quot; 0.005 0.14 &quot;Little brown bat&quot; 0.01 0.25 &quot;Big brown bat&quot; 0.023 0.3 &quot;Mouse&quot; 0.023 0.4 &quot;Musk shrew&quot; 0.048 0.33 &quot;Star-nosed mole&quot; 0.06 1 &quot;E. American mole&quot; 0.075 1.2 &quot;Ground squirrel&quot; 0.101 4 &quot;Tree shrew&quot; 0.104 2.5 Visa svar I animals.txt är argumenten specificerade som header = TRUE eftersom variabelnamnen anges i den första raden sep = \" \" eftersom ett blanksteg används för att särskilja cellerna i varje rad quote = \"\\\"\" eftersom helt vanliga citationstecken används för textvariabler dec = \".\" eftersom en punkt används som decimaltecken För att läsa in animals.txt är alltså read.table() mest lämplig, och datamaterialet kan importeras med hjälp av koden df3 &lt;- read.table(file=\"D:/animals.txt\", header=TRUE). Återgå nu till animals1.csv, och försök läsa in datamaterialet med hjälp av df4 &lt;- read.table(file=\"D:/animals1.csv\", header=TRUE, sep=\",\", dec=\".\") Studera såväl df4 som df1, finns det någon skillnad mellan de två datamaterialen? Syftet med df4 är att visa att read.table() också kan användas för att läsa in filer som inte använder de standardargument som presenterades i början av detta delkapitel. Istället för att används read.csv() går det alltså att använda read.table(), och inom parenteserna specificera de argument som gäller för det datamaterial som ska läsas in. Det går lika bra att använda read.table() med egenspecificerade argument som att använda någon av funktionerna som har förspecificerade argument, och det är helt enkelt upp till varje individuell användare att avgöra vilken approach som är snabbast och lättast. 4.2.2 Excel-filer Eftersom många möjliga uppdragsgivare använder Excel-ark för att lagra och hantera data är det i praktiken nödvändigt att veta hur data från Excel kan importeras till R. Precis som för text-och CSV-filer finns ett antal tips som är bra att tänka på när data matas in i Excel Första raden i varje ark ska innehåla variabelnamn Första kolumnen bör bestå av observationernas ID Undvik namn och värden med mellanslag. Risken är att det tolkas som två olika kolumner. Korta variabelnamn är bättre än långa. Undvik tecken som ?, $,%, ^, &amp;, *, (, ),-,#, ?,,,&lt;,&gt;, /, |, , [ ,] ,{, och } Radera kommentarer som du har i Excelfilen så att dessa inte tolkas som extra data. Många punkter på listan ovan finns även med i listan över saker som är värda att ta i beaktning när det rör sig om text- och CSV-filer. Det faktum att det finns ett relativt stort överlap kan ses som ett tecken på att många av dessa punkter är övergripande och gäller för nästan alla format som datamaterial kan sparas i. Det finns alltså en generell konvention för hur datamaterial bör struktureras för att göra analysen så smidig som möjligt. I resten av detta avsnitt är målet att importera datamaterialen som finns in Excel-filerna animal3.xlsx och animal4.xlsx. För att importera data som lagras i Excel-filer krävs ett nytt paket i R. Paketet heter readxl, och det lättaste sättet att installera det är att skriva install.packages(\"readxl\") i Console och sedan trycka enter. När paketet väl är installerat är det viktigt att även köra koden library(readxl) för att paketet ska aktiveras i R-sessionen. Paketet behöver bara installeras en gång, men det måste aktiveras varje gång R har varit stängt och öppnas på nytt. Det kan därför vara bra att ha library(readxl) längst upp i ett script där Excel-filer läses in. Den första av Excel-filerna, animals3.xlsx, är en vanlig Excel-fil med bra struktur, där all data finns i det första arket. Datamaterialet som finns i filen kan därför enkelt läsas in genom att använda koden som finns i kodsnutten här nedan. df5 &lt;- read_excel(&quot;animal3.xlsx&quot;) Använd samma ansats för att läsa in animal4.xlsx, denna ska alltså läsas in som df6 &lt;- read_excel(&quot;animal3.xlsx&quot;) Jämför df5 och df6. Visar båda tecken på att datamaterialen har lästs in på ett korrekt sätt? df5 ser bra ut, och datamaterialet verkar ha importerats på ett bra sätt. För df6, däremot, är det något som har gått fel i inläsningen. Öppna filen animal4.xlsx och fundera på vad det kan vara som orsakar detta fel. När filen är öppen framgår direkt att den består av flera olika kalkylblad, men att datamaterialet som är av intresse finns lagrat i blad 2. Utöver detta är det även så att datamaterialet inte börjar på första raden, utan det finns även annan text i kalkylbladet. För att R ska kunna importera data från animal4.xlsx på ett korrekt sätt krävs att två inställningar specificeras i read_excel(), nämligen sheet och range. Inställningen sheet används för att bestämma vilket blad R ska använda när det importerar data från Excel-filer. I fallet animal4.xlsx finns det intressanta datamaterialet i blad 2, vilket innebär att inställningen bör specificeras som sheet = \"Blad2\", eftersom detta är namnet på bladet. Den andra inställningen, range, används för att bestämma vilken del av kalkylbladet som ska läsas in. I detta fall finns det en del text som stör inläsningen, och datamaterialet börjar först på rad 3. Inställningen bör specificeras som range = \"A3:D68\" eftersom cellerna A3 och D68 kan användas för att bilda en rektangel som innefattar hela datamaterialet (tänkt på det som att dra ett lodrätt och ett vågrätt streck från var och en av cellerna, då kommer alla data finnas inom rektangeln som bildas av strecken). Notera att den första cellen i inställningen ska vara den som är längst upp till vänster i datamaterialet, och den andra cellen ska vara den som finns längt ner till höger. Läs nu in datamaterialet som df7 &lt;- read_excel(&quot;animal4.xlsx&quot;, sheet = &quot;Blad2&quot;, range = &quot;A3:D68&quot;) Studera df7 närmare. Ser den likadan ut som df6, eller har specificeringen av inställningar gjort datainläsningen bättre? Denna typ av inställningar kan användas för att förenkla importen av datamaterial från Excel-filer, därför är det bra att öppna Excel-filer och titta på deras struktur innan de ska importeras till R. read_excel() har som standard att importera data från det första bladet i en Excel-fil, och att importera alla celler som har någon typ av information lagrad i sig (det spelar ingen roll om det är meningslös text eller viktiga data). Därför går det bra att använda funktionen rakt av för datamaterial som är strukturerade som animals3.xlsx, eftersom datamaterialet börjar på första raden och alla celler är fyllda med relevant information. I alla övriga fall är det alltså värt att fundera över hur inställningarna kan användas för att underlätta inläsningen av data. 4.2.3 Övriga format Utöver de format som diskuterats ovan finns ett flertal andra sätt att lagra data. Eftersom dessa inte är lika vanligt förekommande, och eftersom de inte kommer utgöra någon del i denna kurs, kommer majoriteten av dem inte att behandlas här. Det finns, bland annat, en rad programspecifika datalagringsformat som kan dyka upp ibland. Programspecifikt innebär att formatet är strukturerat på ett sätt som passar ett specifikt statistikprogram väldigt bra, till exempel finns speciella format för att lagra data för bruk i SPSS, Minitab, Stata och dylikt. En fördel med programspecifik datalagring är att den kan göras väldigt effektiv, och på så sätt kräva mycket mindre minne än t.ex. textfiler. En nackdel som gör att denna typ av datalagring ofta undviks är att datamaterial måste formatteras om när de ska användas i program som inte är standard, och detta kan ofta vara en omständlig process som lätt går fel. R har ett eget datalagrinsformat, och filer som lagras i detta format brukar ha .rds efter filnamnet. Eftersom ett mål med kursen är att lära ut programmering med hjälp av R diskuteras användning av .rds-filer i detta avsnitt. Med hjälp av R:s egna format går det alltså att lagra data mer effektivt när det kommer till minnesanvändning. Formatet gör också att importen av data blir väldigt smidig, eftersom strukturen i datamaterialet är skräddarsydd för att passa de krav som R ställer på ett datamaterial. Funktionen som används för att läsa in datamaterial som sparats i R:s eget format finns direkt tillgänglig i R, och den heter readRDS(). Syntaxen som används för att läsa in datamaterial som finns lagrade i .rds-format är relativt simpel, och kan sammanfattas i kodsnutten nedan. readRDS(file = &quot;filnamn.rds&quot;) För att läsa in datamaterialet som är sparat i filen OVB_data.rds (finns tillgänglig i Studium) används koden som visas här nedanför. df8 &lt;- readRDS(file = &quot;OVB_data.rds&quot;) Som sagt är syntaxen relativt enkel, det enda som krävs är namnet på filen som datamaterialet är lagrat i. Om datamaterialet är del av ett större projekt krävs dock att alla som arbetar med det använder R om det är lagrat i en .rds-fil. Därför kan det vara bra att undvika detta format i sammanhang där flera personer ska jobba med ett och samma datamaterial. 4.3 Läsa in datamaterial med hjälp av menyerna i RStudio Det finns två enkla sätt att läsa in data genom att klicka sig fram i menyerna i RStudio. Ett av dem handlar om att använda panelen längst ner till höger för att klicka på en fil som finns i R:s working directory, och andra handlar om att använda menyn Import Dataset som finns längst upp till höger i RStudio-fönstret. Båda dessa kommer diskuteras i denna del av Kapitel 4. Den stora fördelen med att läsa in datamaterial med hjälp av RStudios menyer är att det ofta kan vara väldigt lätt att göra, och att inställningar kan ändras flera gånger för att ser hur datamaterialet kommer se ut när det väl har importerats. Det kan alltså vara lättare att ordna en bra import redan vid första försöket. Den största nackdelen är dock att det är lätt att glömma att spara koden som skrivs ut i Console, och att det därför kan bli så att processen måste genomföras varje gång RStudio startas på nytt. Om olika inställningar används varje gång datamaterialet läses in kan det ge snedvridande effekter på den statistika analys som ska genomföras. 4.3.1 Läsa in data från working directory Börja med att set till så att filerna i R:s working directory syns i panelen längst ner till vänster. Instruktioner för hur detta ordnas finns i sista stycket under rubriken Working directory i kapitel 2. Flytta nu filen OVB_data.rds till mappen som är working directory, och vänta tills det att den dyker upp i panelen längst ner till vänster. Klicka på filens namn när den har dykt upp, för att få fram en dialogruta. I denna ruta anges namn på det objekt som datamaterialet ska sparas i när det har importerats till R. Ange ett namn och klicka på OK så importeras datamaterialet direkt till R. När filen som ska läsas in inte är av .rds-format kan det bli lite krångligare att använda denna approach, men i de flesta fall så går det att ändra grundinställningarna precis som när data importeras med hjälp av kod. Ladda nu ner filen OVB_data.csv och flytta den till working directory. Testa att klicka på dess namn i panelen längst ner till vänster, och sedan klicka på Import Dataset. När detta är gjort öppnas ett fönster där datamaterialet visas, detta fönster illustreras i bilden nedan. Som synes ser datamaterialet väldigt väl organiserat ut, men det behöver inte alltid vara fallet. Ibland kan det vara så att datamaterialet ser väldigt konstigt ut, och detta kan bero på att grundinställningarna i inläsningen inte är anpassade efter datamaterialet i fråga. När det rör sig om text- och CSV-filer finns det, precis som när data importeras med kod, fyra inställningar som kan ändras för att datamaterialet ska importeras korrekt. Dessa inställningar kan ändras i rutan Import Options, som finns precis under datamaterialet. Med hjälp av rutan vid First Row as Names kan inställningen header justeras. Om rutan har en bock i sig har inställningen specifierats som header = TRUE, annars är inställningen satt till FALSE. Till höger om Delimeter: finns en rullista som kan användas för att avgöra vilket tecken som används för att skilja mellan kolumner, och till höger om Quotes: finns en rullista som kan användas för att avgöra hur textvariabler hanteras. Dessa båda motsvarar inställningarna sep respektive quote från tidigare. Slutligen kan knappen Configure till höger om Locale användas för att få upp en ruta där alternativet dec kan användas för att avgöra vilken typ av decimaltecken som används i datamaterialet. En sak som är särskilt bra med detta sätt att importera data är att det går att ange vilken datanivå varje variabel har (eller är tänkt att ha). Under varje variabel namn finns i bilden ovan en liten pil (med texten (double) bredvid). Klicka gärna på denna fil för att få upp en lista med olika datanivåer, en sådan lista visas i bilden som följer. Det första allternativet i listan ovan är Guess, vilket innebär att R läser av värdena som finns i kolumnen och gissar vilken datanivå variabeln har. Om variabeln i fråga är en faktorvariabel med numeriska nivåer, till exempel de binära nivåerna 0 och 1, är det lätt hänt att R gissar fel och klassar variabeln som Integer. För att undvika detta rekommenderas att byta datanivån till Factor, detta kommer visa sig vara till stor hjälp i analysen av datamaterialet. Notera även att alternativen Skip och Only finns längst ner i listan. Alternativet Skip medför att den valda variabeln inte importeras, och Only medför att bara den valda variabeln importeras. 4.3.2 Läsa in data med Import Dataset Längst upp till höger i RStudio finns en knapp där det står Import Dataset. Klicka på denna för att få upp en rullista med alternativ (se bild nedan). I listan går det att välja vilket format datamaterialet som ska läsas in har. För text- och CSV-filer rekommenderas From Text (base). Klicka på From Text (base) för att få upp ett fönster med alla filer som finns i R:s working directory. Notera att det även går att navigera runt i datorn för att hitta datamaterial som finns i mappar som inte är working directory (R kommer då automatiskt ta fram sökvägen till vald fil). Välj nu filen OVB_data.csv för att få upp rutan som visas i bilden nedan. I rutan finns tre paneler. I panelen med rubrik Input File visas filen som ska läsas in, med andra ord ger den en blick över det rådata som finns. Det som är bra med denna panel är att det går väldigt lätt att undersöka hur det ligger till med grundinställningarna som diskuterats ovan, det vill säga vilken typ av decimalteceken som använs och så vidare. I panelen som heter Data Frame visas strukturen på den data frame som kommer läsas in med de inställningar som för tillfället är angivna. I detta fall ser datamaterialet bra strukturerat ut, men så är inte alltid fallet. När det som visas under Data Frame ser dåligt strukturerat ut är det en bra idé att ändra på inställningarna till vänster om de två panelerna. De vanligaste inställningarna ändras med hjälp av Heading som anger huruvida den första raden innehåller variabelnamn, Separator som anger vilket tecken som används för att skilja mellan kolumner, Decimal som anger vilken typ av decimaltecken som används, och Quote som används för att specificera textvariabler. Testa att byta inställningen för Heading till Yes, vad händer? Ser materialet som visas under Data Frame bättre ut. Prova även att ändra de andra inställningarna för att se vad som händer, och fundera över varför det blir som det blir. När datamaterialet som visas under Data Frame ser bra ut importeras det genom att trycka på Import. Notera att ett kommando skrivs ut och körs i Console när datamaterialet importeras. Denna kod kan vara värd att kopiera och spara i den scriptfil där datamaterialet är tänkt att analyseras, eftersom koden då bara kan köras för att importera datamaterialet nästa gång R startas. Om koden redan finns i scriptet är det inte nödvändigt att importera det genom att använda Import Data-menyn en gång till. 4.4 Spara datamaterial med hjälp av R Många gånger kan det vara fördelaktigt att exportera ett datamaterial från R, och spara det på datorn i någon sorts text- eller excel-fil. Till exempel kan det vara så att R har använts för att städa ett datamaterial, göra olika ändringar i ett datamaterial, eller slå ihop två eller flera datamaterial. Då är det smidigt att kunna spara det förändrade datamaterialet för att sedan kunna arbeta med det direkt, och inte behöva genomföra samma förändringar varje gång analysarbete ska utföras med hjälp av datamaterialet i fråga. De kommandon som används för att exportera datamaterial i R är snarlika de som används för att importera datamaterial. Funktionerna har nästan samma namn, och deras struktur är uppbygd på i stort sett sätt. För att spara datamaterial i text-filer finns tre huvudsakliga funktioner. Dessa är write.csv(x, file = &quot;&quot;, sep = &quot;,&quot;, dec = &quot;.&quot;) write.csv2(x, file = &quot;&quot;, sep = &quot;;&quot;, dec = &quot;,&quot;) write.table(x, file = &quot;&quot;, sep = &quot; &quot;, dec = &quot;.&quot;) Notera att funktionsnamnen är likadana, med skillnaden att det nu står write istället för read framför punkten. Grundinställningarna i funktionerna liknar de som finns i motsvarande funktioner som används för dataimport. Notera att vissa argument ofta strular i write.-funktioner, t.ex. argumentet header. Studenter avråds därför från att använda dessa. I funktionerna representerar x det material som ska exporteras, och inom de citationstecken som finns efter file = anges namnet på den fil som datamaterialet ska sparas i. Datamaterialet kommer per automatik sparas i det working directory som är angivet när kodsnutten körs. För att visa hur exportfunktionerna kan komma till nytta används de två datamaterialen exp_dat1.csv och exp_dat2.csv. De båda datamaterialen är simulerade vilked medför att de inte är särskilt intressanta i sig själva, utan det intressanta är hur de kan manipuleras och sedan sparas. Ladda ner de två datamaterialet till ett R:s working directory och läs in dem som exp_dat1 &lt;- read.csv(&quot;exp_dat1.csv&quot;) exp_dat2 &lt;- read.csv(&quot;exp_dat2.csv&quot;) Sätt sedan ihop datamaterialen till ett stort material genom att använda rbind() exp_sam &lt;- rbind(exp_dat1, exp_dat2) För att kontrollera huruvida de två materialen har satts ihop på ett korrekt sätt går det att använda View(exp_sam) Det nya datamaterialet kan nu exporteras med hjälp av funktionerna ovan. För att exportera det till en textfil där cellerna separeras av semikolon används write.csv2(exp_sam, file = &quot;exp_sam.csv&quot;) I detta fall sparas en textfil vid namn exp_sam.csv i det working directory som har angivits. Notera att filen som sparas inte måste ha samma namn som datamaterialet har i R. Om det, av någon anledning, anses att sammanslagna_data.csv är ett bättre namn på filen som ska sparas används helt enkelt write.csv2(exp_sam, file = &quot;sammanslagna_data.csv&quot;) 4.5 Övningar Övning 4.1 Denna uppgift kretsar kring att importera data från sjätte vågen av World Values Survey. Datamaterialet är begränsat till svar från de intevjuer som utförts i Sverige under år 2011, och innehåller 1206 observationer. Alla svar är omkodade till siffror, och ett utdrag ur datamaterialet innehåller svar på frågor gällande Äktenskaplig status Antal barn Huruvida responenten skulle vara villig att försvara Sverige vid ett eventuellt krigsutbrott Ålder Frågorna är sorterade så att varje punkt i listan ovan motsvarar respektive kolumn i datamaterialet (alltså finns äktenskaplig status i första kolumnen, antal barn i andra kolumnen, etc.). Uppgiften är nu att: Ladda ner datamaterialet som finns lagrat i VWS1.csv från Studentportalen. Öppna filen som datamaterialet är lagrad i med hjälp av Notepad, TextEdit, eller någon annan textredigerare. Fundera på hur datamaterialet materialet är strukturerat, och ange hur de fyra grundinställningarna är specificerade i filen. Visa svar I datamaterialet är header = FALSE eftersom inga variabelnamn ges i första raden sep = \";\" eftersom semikolon används för att skilja mellan kolumner quote = \"\\\"\" detta går egentligen inte att se, eftersom inga textvariabler finns med dec = \".\" detta går inte heller att se, eftersom inga decimaltal finns i datamaterialet Avgör vilken av funktionerna read.csv() och read.csv2() som är bäst lämpad för att importera datamaterialet till R, och skriv sedan en kodsnutt som kan användas för att importera datamaterialet. Visa svar Eftersom semikolon används för att skilja mellan kolumner är read.csv2() bäst lämpad för att läsa in datamaterialet. Notera dock att header = FALSE, och att denna inställning måste ändras i koden. Kodsnutten som används för att läsa in datameterialet blir så wvs &lt;- read.csv2(&quot;WVS1.csv&quot;, header = FALSE) Använd nu read.table() för att importera samma datamaterial genom att ange egna specifikationer för alla inställningar. Visa svar För att använda read.table() måste inställningarna för header och sep specificeras så att wvs2 &lt;- read.table(&quot;WVS1.csv&quot;, header = FALSE, sep = &quot;;&quot;) Ge varje kolumn ett meningsfullt namn. Visa svar Vad som räknas som bra namn är till viss del subjektivt, och det är inget krav att namnen ska vara exakt samma som de namn som anges här. Vad som är viktigt är att namnen är i linje med rekommendationerna som ges i texten. Exampel på variabelnamn colnames(wvs) &lt;- c(&quot;ID&quot;, &quot;marital_status&quot;, &quot;children&quot;, &quot;defend_country&quot;, &quot;age&quot;) View(wvs) Läs in datamaterialet genom att använda Import Dataset-menyn. Blir resultatet likadant som ovan? Övning 4.2 Denna övning använder samma datamaterial som övningen ovan, dock i ett annat format. Utför följande uppgifter: Ladda ner filen WVS.xlsx från Studentportalen och studera den i ett Excel-fönster. Finns det något som kan orsaka svårigheter i datainläsningen? Finns det några celler som innehåller information som inte är relevant i sammanhanget? Visa svar I datamaterialet finns tre saker som är värda att notera All data finns i det andra arket, vid namn Sheet2 Ovanför datamaterialet finns en informationstext som berättar var datamaterialet har hämtats och vad det innehåller för information Till höger om datamaterialet finns ett index som visar vad varje kolumn innehåller data för Använd funktionen read_excel() för att läsa in datamaterialet. Vilka inställningar är viktiga att ändra för att inläsningen ska gå korrekt till? Visa svar För att datainläsningen ska gå korrekt till finns två inställningar som behöver ändras. Den ena är sheet, som bestämmer vilket ark som ska läsas in, och den andra är range som anger vilken del av Excel-arket som ska läsas in. I detta fall bör sheet = \"Sheet2\", och range = \"A4:D1210\", och koden blir wvs3 &lt;- read_excel(&quot;WVS.xlsx&quot;, sheet = &quot;Sheet2&quot;&quot;, range = &quot;A4:D1210&quot;) Notera att indexet över vilken variabel som hör till vilken kolumn kan vara bra att spara på annat sätt, men inte i själva datamaterialet. Använd valfri meny i RStudio for att importera datamaterialet som finns i WVS.xlsx. Var noga med att bara importera den del av materialet som kan komma att bli relevant för en framtida analys. Övning 4.3 I textfilen covid_19.csv finns information gällande antalet bekräftade fall av Covid-19 i hela Sverige, samt regionsspecifik information för Dalarna och Uppsala. Skriv en kodsnutt som på lämligt sätt importerar datamaterialet till R Visa svar Börja med att öppna filen i textedit eller notepad (beroende på vilken typ av dator du har). Det första som finns i datamaterialet är en informationstext som kan ställa till det vid datainläsning. För att komma runt denna informationstext finns två olika alternativ Radera texten manuellt, spara om filen, och sedan läsa in den som vanligt Använda inställningen skip och få R att hoppa över de första raderna när datamaterialet importeras. I vilket fall som helst kan konstateras att header = TRUE sep = \",\" quote = \"\\\"\" egentligen finns ingen text-data i materialet, men detta är ett antagende som kan göras dec = \".\" här gäller samma sak som ovan Det är alltså lämplig att använda read.csv() för att importera datamaterialet. Om den inledande texten har raderats, och om filen finns i ett aktuellt working directory, kan materialet läsas in som covid_19 &lt;- read.csv(&quot;covid_19.csv&quot;) Om informationstexten ligger kvar är det viktigt att notera att de 8 första raderna i textfilen antingen innehåller text eller är tomma. Därför kan alternativet skip sättas till 8, så börjar R läsa in data från den nionde raden i filen. Koden skrivs då som covid_19 &lt;- read.csv(&quot;covid_19.csv&quot;, skip = 8) Undersök datamaterialet för att se om det finns några konstigheter, så som konstiga eller orimliga värden. Koda i sådana fall om de konstiga värdena till NA Visa svar För att få en sammanfattning av datamaterialet kan summary() användas summary(covid_19) ## X Statistikdatum Totalt_antal_fall Dalarna ## Min. : 1.0 Length:267 Min. : -99.0 Min. : 0 ## 1st Qu.: 67.5 Class :character 1st Qu.: 144.0 1st Qu.: 3 ## Median :134.0 Mode :character Median : 330.0 Median : 9 ## Mean :134.0 Mean : 419.3 Mean : 11685 ## 3rd Qu.:200.5 3rd Qu.: 655.5 3rd Qu.: 18 ## Max. :267.0 Max. :1980.0 Max. :999999 ## NA&#39;s :10 ## Uppsala ## Min. : 0.00 ## 1st Qu.: 4.00 ## Median : 13.00 ## Mean : 20.81 ## 3rd Qu.: 33.00 ## Max. :173.00 ## Som synes finns konstiga värden på två olika stället I variabeln Totalt_antal_fall är det minsta värdet -99. Eftersom variabeln mäter antal som bekräftats smittade är negativa tal inte möjliga, och därför bör alla tal som är mindre än noll kodas om till NA I kolumnen som mäter antalet som bekräftats smittade i Dalarna finns minst ett värde som är 999999. Eftersom Dalarnas folkmängd är cirka 285 000 borde detta vara en ren omöjlighet. Därför används koden covid_19$Totalt_antal_fall[covid_19$Totalt_antal_fall &lt; 0] &lt;- NA covid_19$Dalarna[covid_19$Dalarna == 999999] &lt;- NA för att koda om de konstiga värdena. För att kontrollera att altt nu står rätt till anropas summary() en gång till summary(covid_19) ## X Statistikdatum Totalt_antal_fall Dalarna ## Min. : 1.0 Length:267 Min. : 0.0 Min. : 0.00 ## 1st Qu.: 67.5 Class :character 1st Qu.: 166.5 1st Qu.: 3.00 ## Median :134.0 Mode :character Median : 347.5 Median : 9.00 ## Mean :134.0 Mean : 441.6 Mean :12.06 ## 3rd Qu.:200.5 3rd Qu.: 668.8 3rd Qu.:17.00 ## Max. :267.0 Max. :1980.0 Max. :64.00 ## NA&#39;s :11 NA&#39;s :13 ## Uppsala ## Min. : 0.00 ## 1st Qu.: 4.00 ## Median : 13.00 ## Mean : 20.81 ## 3rd Qu.: 33.00 ## Max. :173.00 ## Denna gång ser allt bra ut. Övning 4.4 Denna uppgift är en övning i att föra in (och exportera) egna data med hjälp av R. Antag att du jobbar som forskningsassistent i ett projekt som håller på att genomför en enkätstudie. Enkäterna har skickats ut och svar har kommit in, och det som kvarstår innan data kan analyseras är att svaren måste matas in i datorn. Exempel på svar från ett litet antal enkäter finns i tabellen nedan. Ålder Gymnasium Kandidatexamen Vegetarian 16 0 0 Nej 25 1 1 Ja 64 0 0 Nej 23 1 0 Nej 31 1 1 Ja 37 1 1 Nej 54 1 0 Nej Skapa en ny textfil (med t.ex. Notepad eller TextEdit) och mata in datamaterialet från tabellen i filen. Använd grundinställningarna för en vanlig csv2-fil, alltså header = TRUE sep = \";\" dec = \",\" Importera datamaterialet till R med hjälp av din egna textfil, och alltså inte genom att mata in värdena i enskilda vektorer manuellt Mata in datamaterialet manuellt i en data frame i RStudio. Använd sedan write.csv2 för att exportera datamaterialet till en ny textfil. Jämför textfilen från denna uppgift med textfilen från uppgift a. Om du löst a rätt bör de vara strukturerade på samma sätt. Visa svar Notera att båda lösningsalternativen är fullgoda, precis som alla andra alternativ som ger en korrekt data frame. Om du har löst inmatningen på ett annat sätt kan du använda någon av inmatningarna nedan som referens, för att kontrollera att din egen lösning ger rätt data. #### Lösningslaternativ 1 #### alder &lt;- c(16, 25, 64, 23, 31, 37, 54), gymnasium &lt;- c(0, 1, 0, 1, 1, 1, 1), kandidat &lt;- c(0, 1, 0, 0, 1, 1, 0), vegetarian &lt;- c(&quot;Nej&quot;, &quot;Ja&quot;,&quot;Nej&quot;, &quot;Nej&quot;, &quot;Ja&quot;, &quot;Nej&quot;, &quot;Nej&quot; ) df &lt;- data.frame(alder, gymnasium, kandidat, vegetarian) #### Lösningslaternativ 2 #### df &lt;- data.frame(alder = c(16, 25, 64, 23, 31, 37, 54), gymnasium = c(0, 1, 0, 1, 1, 1, 1), kandidat = c(0, 1, 0, 0, 1, 1, 0), vegetarian = c(&quot;Nej&quot;, &quot;Ja&quot;,&quot;Nej&quot;, &quot;Nej&quot;, &quot;Ja&quot;, &quot;Nej&quot;, &quot;Nej&quot; )) #### Exportera till extern fil #### write.csv2(df, file = &quot;Uppgift4_4_c.csv&quot;) "],["kategorivariabler.html", "Kapitel 5 Kategorivariabler 5.1 En binär variabel 5.2 Två binära variabler 5.3 Tre kategorier eller fler 5.4 Samband mellan kategorivariabler 5.5 Programmeringsuppgifter 5.6 Referenser", " Kapitel 5 Kategorivariabler body { text-align: justify} En nödvändig färdighet vid arbete med data är att kunna hantera och analysera kategorivariabler. Vi börjar i detta kapitel med det enkla fallet binära variabler för att i ett senare övergå till att studera hur man arbetar med variabler som har fler än två kategorier. I princip alla datamaterial innehåller variabler med kategorier, och även om data inledningsvis inte innehåller kategorivariabler är det vanligt att av olika skäl omkoda kvantitativa variabler till kategorier. Kategorivariabler kan vara antingen på nominal eller ordinalskala. Dessutom är det inte ovanligt att även analysera diskreta kvantitativa variabler som om de bestod av kategorier. För nybörjaren kan det vara förvirrande att det finns åtminstone två alternativ, som bägge är viktiga, för hur man arbetar med kategorivariabler. Alternativen sammanfattas i korthet här nedan. Alternativ 1: En kategorivariabel hanteras som en numerisk variabel efter att kategorierna tilldelats numeriska värden. Exempelvis kan vi för en binär variabel ange att värdena 0 och 1 representerar två kategorier. Observera att val värden påverkar hur variabeln används i analysen. Alternativ 2: En kategori variaabel definieras med funktionen factor(), och får datatypen factor. Kategorierna (alt. nivåerna) i en faktorvariabel kallas i R för levels. Fördelen med att definiera en variabel som faktor är att R kan använda information om den binära variabeln i analyser och resultat. Till exempel kan kategoriernas namn presenteras i resultat. Dessutom kräver en del metoder i R en faktor-variabel. Observera att det, av förklarliga skäl, inte går att utföra räkneoperationer på variabler definierade som datatypen faktor (tänk på vad skulle det betyda att addera eller subtrahera två kategorier/grupptillhörigheter.). Eftersom bägge varianterna har för- och nackdelar förekommer ofta båda typerna av kodning för en och samma variabel i ett datamaterial  en numerisk (i fallet med en binär variabel kodad 0-1 kallad för variabelnamn_bin) och version kodad som faktor (kallad variabelnamn_cat). Detta för att underlätta analysarbete i R. Vi kommer i stor utsträckning använda data för att exemplifiera skillnader och tillämpningar i detta kapitel. Datamaterialet som används kan läsas in med koden som finns i fliken här nedan. Koden är väldigt lång, med det går bra att kopiera in den i RStudio och köra den som den är. Visa datamaterial df &lt;- data.frame(utbildning = c(&quot;hög&quot;, &quot;hög&quot;, &quot;låg&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;låg&quot;, &quot;hög&quot;, &quot;låg&quot;, &quot;låg&quot;, &quot;hög&quot;, &quot;hög&quot;,&quot;hög&quot;,&quot;hög&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;låg&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;låg&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;låg&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;låg&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;låg&quot;, &quot;låg&quot;, &quot;hög&quot;, &quot;låg&quot;,&quot;hög&quot;, &quot;hög&quot;, &quot;låg&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;låg&quot;, &quot;hög&quot;, &quot;låg&quot;, &quot;låg&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;låg&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;låg&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;låg&quot;, &quot;hög&quot;,&quot;hög&quot;, &quot;låg&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;låg&quot;, &quot;låg&quot;, &quot;hög&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;hög&quot;, &quot;hög&quot;, &quot;låg&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;låg&quot;, &quot;hög&quot;, &quot;låg&quot;, &quot;låg&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;låg&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;låg&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;låg&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;låg&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;låg&quot;, &quot;låg&quot;, &quot;hög&quot;, &quot;låg&quot;,&quot;hög&quot;, &quot;hög&quot;, &quot;låg&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;låg&quot;, &quot;hög&quot;, &quot;låg&quot;, &quot;låg&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;låg&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;låg&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;låg&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;låg&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;hög&quot;, &quot;låg&quot;, &quot;låg&quot;, &quot;hög&quot;, &quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;,&quot;låg&quot;), alder = c(1, 0, 1, 2, 2, 1, 2, 1, 1, 1, 2, 2, 1, 2, 1, 0, 0, 1, 0, 2, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 2, 0, 0, 1, 0,1, 2, 1, 1, 0, 0, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2,1, 2, 1, 1, 2, 1, 0, 1, 2, 2, 1, 0, 1, 1, 0, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 2, 2, 1, 2, 2, 0, 1, 1, 1, 2, 1, 1, 1, 0, 2, 1,2, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 2, 2, 1, 1, 0, 0, 1, 1, 2, 2, 1, 1, 2, 0, 0, 2, 0, 2, 1, 1, 1, 1, 1, 0, 1, 2, 1, 1, 1, 0, 2, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0,0, 0, 1, 2, 0, 0, 1, 1, 1, 2, 0, 1, 1, 2, 1, 1,1, 1, 1, 1, 1, 1, 0, 1, 2, 2, 1, 1, 2, 0, 0, 0, 1, 1, 1, 2, 1, 1, 0, 2, 0, 1, 2, 2, 0, 1, 1, 1, 0, 2, 1, 0, 1, 0, 0, 0, 1,1, 1, 2, 1, 1, 0, 2, 1, 0, 2, 1, 2, 2, 0, 1, 1,2, 0, 1, 2, 1, 2, 1, 1, 0, 2, 1, 1, 2, 2, 2, 1, 2, 1, 1, 0, 0, 1, 1, 2, 1, 2, 1, 1, 1, 1, 2, 1, 0, 1, 2, 1, 0, 1, 2, 2, 1,0, 0, 1, 0, 0, 2, 2, 1, 1, 1, 1), rokare = c(0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1,0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1,0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1,0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1,1,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,1,1,1,1,0,0,0,1,0,1,0,1,1,0,0,0,1,1,1,1,0,0,1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1,0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1,0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1,1,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,1,1,1,1,0,0,0,1,0,1,0,1,1,0,0,0,1,1,1,1,0,0,1), kon = c(&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;man&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;man&#39;,&#39;man&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;man&#39;,&#39;man&#39;,&#39;man&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;man&#39;,&#39;man&#39;,&#39;man&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;man&#39;,&#39;man&#39;,&#39;man&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;man&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;man&#39;,&#39;man&#39;,&#39;man&#39;,&#39;man&#39;,&#39;man&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;man&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;man&#39;,&#39;man&#39;,&#39;man&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;man&#39;,&#39;man&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;man&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;man&#39;,&#39;man&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;man&#39;,&#39;man&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;man&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;man&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;man&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;man&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;man&#39;,&#39;kvinna&#39;,&#39;man&#39;), reklam = c(&#39;Nej&#39;,&#39;Ja&#39;,&#39;Ja&#39;,&#39;Ja&#39;,&#39;Ja&#39;,&#39;Ja&#39;,&#39;Ja&#39;,&#39;Har ej tagit ställning&#39;,&#39;Ja&#39;,&#39;Nej&#39;,&#39;Nej&#39;,&#39;Ja&#39;,&#39;Nej&#39;,&#39;Ja&#39;,&#39;Ja&#39;,&#39;Nej&#39;,&#39;Har ej tagit ställning&#39;,&#39;Har ej tagit ställning&#39;,&#39;Nej&#39;,&#39;Ja&#39;,&#39;Har ej tagit ställning&#39;,&#39;Nej&#39;,&#39;Nej&#39;,&#39;Ja&#39;,&#39;Nej&#39;,&#39;Ja&#39;,&#39;Ja&#39;,&#39;Har ej tagit ställning&#39;,&#39;Ja&#39;,&#39;Har ej tagit ställning&#39;,&#39;Nej&#39;,&#39;Ja&#39;,&#39;Ja&#39;,&#39;Har ej tagit ställning&#39;,&#39;Nej&#39;,&#39;Har ej tagit ställning&#39;,&#39;Nej&#39;,&#39;Har ej tagit ställning&#39;,&#39;Har ej tagit ställning&#39;,&#39;Har ej tagit ställning&#39;,&#39;Ja&#39;,&#39;Nej&#39;,&#39;Har ej tagit ställning&#39;,&#39;Ja&#39;,&#39;Ja&#39;,&#39;Nej&#39;,&#39;Nej&#39;,&#39;Nej&#39;,&#39;Har ej tagit ställning&#39;,&#39;Ja&#39;,&#39;Har ej tagit ställning&#39;,&#39;Har ej tagit ställning&#39;,&#39;Nej&#39;,&#39;Nej&#39;,&#39;Ja&#39;,&#39;Har ej tagit ställning&#39;,&#39;Ja&#39;,&#39;Har ej tagit ställning&#39;,&#39;Har ej tagit ställning&#39;,&#39;Har ej tagit ställning&#39;,&#39;Har ej tagit ställning&#39;,&#39;Har ej tagit ställning&#39;,&#39;Nej&#39;,&#39;Nej&#39;,&#39;Ja&#39;,&#39;Ja&#39;,&#39;Har ej tagit ställning&#39;,&#39;Har ej tagit ställning&#39;,&#39;Ja&#39;,&#39;Nej&#39;,&#39;Nej&#39;,&#39;Ja&#39;,&#39;Nej&#39;,&#39;Har ej tagit ställning&#39;,&#39;Ja&#39;,&#39;Nej&#39;,&#39;Har ej tagit ställning&#39;,&#39;Nej&#39;,&#39;Nej&#39;,&#39;Nej&#39;,&#39;Har ej tagit ställning&#39;,&#39;Nej&#39;,&#39;Ja&#39;,&#39;Nej&#39;,&#39;Nej&#39;,&#39;Ja&#39;,&#39;Har ej tagit ställning&#39;,&#39;Har ej tagit ställning&#39;,&#39;Nej&#39;,&#39;Ja&#39;,&#39;Har ej tagit ställning&#39;,&#39;Ja&#39;,&#39;Ja&#39;,&#39;Nej&#39;,&#39;Nej&#39;,&#39;Ja&#39;,&#39;Ja&#39;,&#39;Ja&#39;,&#39;Har ej tagit ställning&#39;,&#39;Ja&#39;,&#39;Har ej tagit ställning&#39;,&#39;Nej&#39;,&#39;Har ej tagit ställning&#39;,&#39;Nej&#39;,&#39;Har ej tagit ställning&#39;,&#39;Ja&#39;,&#39;Nej&#39;,&#39;Ja&#39;,&#39;Har ej tagit ställning&#39;,&#39;Ja&#39;,&#39;Ja&#39;,&#39;Har ej tagit ställning&#39;,&#39;Har ej tagit ställning&#39;,&#39;Har ej tagit ställning&#39;,&#39;Nej&#39;,&#39;Har ej tagit ställning&#39;,&#39;Nej&#39;,&#39;Har ej tagit ställning&#39;,&#39;Ja&#39;,&#39;Ja&#39;,&#39;Nej&#39;,&#39;Har ej tagit ställning&#39;,&#39;Har ej tagit ställning&#39;,&#39;Har ej tagit ställning&#39;,&#39;Ja&#39;,&#39;Har ej tagit ställning&#39;,&#39;Har ej tagit ställning&#39;,&#39;Ja&#39;,&#39;Nej&#39;,&#39;Nej&#39;,&#39;Har ej tagit ställning&#39;,&#39;Ja&#39;,&#39;Ja&#39;,&#39;Ja&#39;,&#39;Nej&#39;,&#39;Ja&#39;,&#39;Har ej tagit ställning&#39;,&#39;Har ej tagit ställning&#39;,&#39;Har ej tagit ställning&#39;,&#39;Nej&#39;,&#39;Nej&#39;,&#39;Nej&#39;,&#39;Ja&#39;,&#39;Nej&#39;,&#39;Ja&#39;,&#39;Nej&#39;,&#39;Ja&#39;,&#39;Har ej tagit ställning&#39;,&#39;Nej&#39;,&#39;Nej&#39;,&#39;Ja&#39;,&#39;Ja&#39;,&#39;Nej&#39;,&#39;Nej&#39;,&#39;Har ej tagit ställning&#39;,&#39;Har ej tagit ställning&#39;,&#39;Ja&#39;,&#39;Nej&#39;,&#39;Ja&#39;,&#39;Har ej tagit ställning&#39;,&#39;Har ej tagit ställning&#39;,&#39;Har ej tagit ställning&#39;,&#39;Har ej tagit ställning&#39;,&#39;Ja&#39;,&#39;Nej&#39;,&#39;Nej&#39;,&#39;Har ej tagit ställning&#39;,&#39;Nej&#39;,&#39;Nej&#39;,&#39;Har ej tagit ställning&#39;,&#39;Har ej tagit ställning&#39;,&#39;Ja&#39;,&#39;Nej&#39;,&#39;Nej&#39;,&#39;Har ej tagit ställning&#39;,&#39;Ja&#39;,&#39;Ja&#39;,&#39;Ja&#39;,&#39;Har ej tagit ställning&#39;,&#39;Har ej tagit ställning&#39;,&#39;Nej&#39;,&#39;Nej&#39;,&#39;Har ej tagit ställning&#39;,&#39;Har ej tagit ställning&#39;,&#39;Har ej tagit ställning&#39;,&#39;Nej&#39;,&#39;Har ej tagit ställning&#39;,&#39;Nej&#39;,&#39;Ja&#39;,&#39;Nej&#39;,&#39;Har ej tagit ställning&#39;,&#39;Nej&#39;,&#39;Nej&#39;,&#39;Ja&#39;,&#39;Ja&#39;,&#39;Ja&#39;,&#39;Nej&#39;,&#39;Har ej tagit ställning&#39;,&#39;Ja&#39;,&#39;Ja&#39;,&#39;Har ej tagit ställning&#39;,&#39;Nej&#39;,&#39;Nej&#39;,&#39;Ja&#39;,&#39;Nej&#39;,&#39;Nej&#39;,&#39;Har ej tagit ställning&#39;,&#39;Nej&#39;,&#39;Ja&#39;,&#39;Har ej tagit ställning&#39;,&#39;Ja&#39;,&#39;Har ej tagit ställning&#39;,&#39;Ja&#39;,&#39;Ja&#39;,&#39;Ja&#39;,&#39;Nej&#39;,&#39;Har ej tagit ställning&#39;,&#39;Har ej tagit ställning&#39;,&#39;Har ej tagit ställning&#39;,&#39;Nej&#39;,&#39;Nej&#39;,&#39;Har ej tagit ställning&#39;,&#39;Har ej tagit ställning&#39;,&#39;Har ej tagit ställning&#39;,&#39;Nej&#39;,&#39;Har ej tagit ställning&#39;,&#39;Nej&#39;,&#39;Nej&#39;,&#39;Nej&#39;,&#39;Har ej tagit ställning&#39;,&#39;Ja&#39;,&#39;Nej&#39;,&#39;Ja&#39;,&#39;Har ej tagit ställning&#39;,&#39;Ja&#39;,&#39;Ja&#39;,&#39;Ja&#39;,&#39;Har ej tagit ställning&#39;,&#39;Ja&#39;,&#39;Har ej tagit ställning&#39;,&#39;Nej&#39;,&#39;Har ej tagit ställning&#39;,&#39;Har ej tagit ställning&#39;,&#39;Nej&#39;,&#39;Har ej tagit ställning&#39;,&#39;Ja&#39;,&#39;Har ej tagit ställning&#39;,&#39;Har ej tagit ställning&#39;,&#39;Har ej tagit ställning&#39;,&#39;Nej&#39;,&#39;Ja&#39;,&#39;Ja&#39;,&#39;Ja&#39;,&#39;Har ej tagit ställning&#39;,&#39;Har ej tagit ställning&#39;,&#39;Har ej tagit ställning&#39;,&#39;Ja&#39;,&#39;Nej&#39;,&#39;Har ej tagit ställning&#39;,&#39;Nej&#39;,&#39;Nej&#39;,&#39;Ja&#39;,&#39;Har ej tagit ställning&#39;,&#39;Ja&#39;,&#39;Har ej tagit ställning&#39;,&#39;Har ej tagit ställning&#39;,&#39;Ja&#39;,&#39;Nej&#39;,&#39;Har ej tagit ställning&#39;,&#39;Nej&#39;,&#39;Ja&#39;,&#39;Nej&#39;,&#39;Ja&#39;,&#39;Nej&#39;,&#39;Ja&#39;,&#39;Har ej tagit ställning&#39;,&#39;Ja&#39;,&#39;Ja&#39;,&#39;Har ej tagit ställning&#39;,&#39;Har ej tagit ställning&#39;), inkomst = c(13941,39664,13168,28809,55952,12495,20185,38094,13822,32932,22205,36625,51575,21508,33509,26322,15392,21626,18837,24299,38921,38951,18360,32974,14131,28463,38232,20072,24300,40883,9090,30565,32935,32589,14408,33223,20177,32574,30640,16255,24056,18365,22039,32859,13595,10514,19490,30075,29849,14371,15076,18983,26641,14967,38646,27197,15314,9058,10275,19248,33629,16039,15302,8363,29178,29565,35454,25673,25116,21695,12594,31860,48489,37977,20106,45531,27277,15418,18315,20529,24322,9509,22487,14443,30287,33711,28788,38495,43640,21820,12945,29219,26099,53993,18370,13513,34515,39675,24622,10069,42460,21113,32073,40741,25925,48530,37672,16809,53412,28576,20974,53895,17485,9382,26977,37076,34885,24809,12793,18749,22223,27462,33319,25212,19846,36005,22765,25484,5710,22545,26475,50017,10044,28683,28379,36793,37007,43140,11389,28621,8074,18887,8729,34029,22957,25761,21928,23366,21629,29325,17545,34121,9780,34344,15565,35821,22192,24715,29730,36446,19315,18764,30303,44705,24113,24773,13433,21116,22444,17098,27646,29356,11167,39386,46786,20476,32806,8196,20299,11016,28822,34008,36611,40839,38823,27474,21803,23579,24328,26289,34776,42902,5958,20928,8996,14684,19391,14105,24321,31704,40910,14725,25166,33578,21071,37265,21827,17284,16401,38311,10416,16634,32329,18411,11388,22741,45799,24504,18190,9708,9590,10068,15552,34781,17205,12180,31054,19803,34321,28206,13392,25659,13679,10817,48137,16057,30680,28931,8746,51031,15530,21598,12816,39388,36873,10815,26335,8332,25860,12491,26264,17914,13240,51238,18080,28812,40576,33316,3978,32843,14942,33416,11274,14775,25466,15959,21031,12042,9518,38184,10007,8226,11975,29364,57382,11814,28760,19193,24117,35747), alkohol = c(4,5,5,5,5,5,5,3,5,5,5,5,5,4,5,5,4,4,5,5,4,5,5,4,5,4,3,3,3,5,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,4,1,4,5,2,2,5,4,5,5,5,5,5,5,4,5,5,5,5,5,1,2,5,5,5,5,5,5,5,3,5,5,5,4,3,3,5,3,2,5,5,4,5,5,5,5,5,5,5,3,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,3,4,5,5,5,2,5,5,3,1,5,4,5,2,5,4,3,1,2,2,5,4,5,5,4,3,3,4,5,5,5,5,5,5,5,5,5,5,4,5,5,5,4,5,5,5,5,5,5,5,5,1,1,4,2,5,5,2,5,2,1,5,5,5,5,5,5,4,4,5,5,4,5,5,5,1,4,5,4,5,4,5,5,5,5,1,3,4,4,5,4,5,5,4,5,5,1,2,5,4,5,5,5,5,3,5,1,5,1,5,5,3,4,2,4,4,5,5,5,5,4,3,5,5,4,5,5,1,5,5,5,5,5,5,4,5,5,5,4,4,1,5,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,4,5), cannabis= c(1,5,3,2,3,3,5,1,2,3,1,1,5,1,2,1,1,3,1,2,3,5,3,1,1,4,3,3,1,1,1,2,1,3,1,4,5,1,1,1,2,3,3,2,1,2,2,1,4,5,5,1,2,1,4,3,2,2,3,2,2,1,3,1,1,2,5,3,2,4,3,2,2,5,4,1,2,3,3,1,1,2,1,1,4,3,5,4,1,5,3,1,5,2,1,4,4,1,2,3,3,1,2,4,4,1,3,2,3,2,1,2,4,3,3,1,3,2,1,1,1,2,2,4,1,1,1,4,1,1,2,3,2,1,3,4,1,1,2,2,1,1,1,2,5,1,4,2,2,2,5,5,3,1,1,1,2,4,1,3,4,1,3,3,4,1,4,1,1,1,2,1,1,1,1,5,5,1,5,3,3,2,4,2,1,1,3,1,1,4,1,1,2,3,1,1,1,4,1,2,4,1,2,1,5,3,2,2,3,1,1,1,2,5,1,3,5,1,4,2,1,1,2,5,1,2,2,2,5,5,1,2,4,1,4,1,1,5,2,4,4,3,1,1,1,1,1,2,2,2,1,1,4,2,1,3,1,2,1,1,3,3,1,1,1,1,1,1,1,2,1,1,2,1,1,1,3,5,5,5), cigaretter = c(1,4,5,5,2,4,4,2,2,5,1,5,1,1,1,2,3,5,4,5,2,2,4,5,3,4,2,1,3,5,2,4,5,5,5,4,5,4,4,2,4,3,2,1,2,2,2,4,3,2,2,4,2,1,1,3,3,2,3,5,5,5,2,5,4,3,5,4,2,5,2,3,4,4,5,2,5,3,5,5,2,3,4,2,4,3,4,3,5,4,4,2,4,4,2,3,3,1,3,2,5,4,4,2,2,4,5,4,3,4,4,1,3,3,5,4,5,2,1,3,5,3,5,1,3,4,2,5,5,3,3,2,4,5,5,1,2,4,3,4,4,1,5,1,2,3,3,3,3,2,1,5,1,3,1,5,2,3,2,4,2,3,1,1,2,1,5,2,2,2,1,3,1,4,4,5,1,5,5,3,5,2,3,5,1,4,5,4,3,2,5,2,2,5,3,5,1,1,5,1,5,4,4,2,1,1,5,1,5,4,2,2,4,1,3,2,3,4,5,5,4,4,5,5,2,2,5,2,3,5,5,2,1,1,2,3,5,4,1,1,4,2,1,3,2,4,1,4,2,3,5,5,3,5,3,3,4,5,2,1,3,4,2,1,2,4,5,4,4,1,5,4,1,1,5,2,3,2,5,1), mat = c(8,8,5,2,1,1,4,2,4,2,1,3,1,1,5,2,5,2,2,4,1,3,2,1,1,0,2,1,1,2,2,2,1,4,0,0,0,3,0,3,3,2,2,2,4,2,3,2,1,3,4,0,2,2,2,2,2,2,2,1,1,0,1,0,5,2,1,1,0,1,0,1,3,1,3,4,1,0,2,1,2,2,4,1,0,1,3,1,1,0,1,2,5,2,0,4,1,1,2,4,4,4,1,1,1,1,1,3,2,4,1,2,1,2,0,1,0,4,3,2,3,0,3,1,2,1,2,1,1,2,8,3,4,1,2,0,2,1,2,2,2,1,2,3,2,2,1,3,0,2,1,2,2,2,2,5,1,2,1,2,1,2,1,0,0,2,3,1,4,2,1,3,1,0,3,5,8,4,2,5,2,2,2,4,1,3,3,1,2,4,3,3,2,0,1,1,2,2,1,0,2,2,0,4,3,4,2,3,3,5,1,1,3,2,2,2,5,0,3,5,2,3,1,5,2,2,4,0,1,2,0,2,4,2,1,4,1,4,1,3,1,2,1,4,4,3,3,3,4,3,2,3,2,1,1,3,1,1,0,1,0,8,3,1,0,2,0,1,0,2,1,5,1,2,3,0,4,3,8,8)) Nedan ges en beskrivning av de variabler som finns i datamaterialet. utbildning: Vilken är din högsta avslutade utbildning? - låg. Gymnasieutbildning eller lägre. hög. Grundexamen på universitetet eller högre. alder: Hur gammal är du? - 0. 65-79 år, 1. 50-64 år, 2. 18-49 år. rokare: Röker du minst en cigarett varje vecka? - 1. Ja, 0. Nej. kon: - Vilket kön är du? - man, kvinna reklam: Anser du att TV-reklam för spel bör vara tillåtet? - Ja, Nej, Har ej tagit ställning. inkomst: Vilken är din månadsinkomst? - inkomst kr/mån alkohol: Hur ställer du dig till att i Sverige ha ett totalt förbud mot att sälja alkohol? - 1. Mycket positiv. 2. Ganska positiv. 3. Varken positiv eller negativ. 4. Ganska negativ 5. Mycket negativ. cannabis: Hur ställer du dig till att i Sverige ha ett totalt förbud mot att sälja cannabis? - 1. Mycket positiv. 2. Ganska positiv. 3. Varken positiv eller negativ. 4. Ganska negativ 5. Mycket negativ. cigaretter: Hur ställer du dig till att i Sverige ha ett totalt förbud mot att sälja cigaretter? - 1. Mycket positiv. 2. Ganska positiv. 3. Varken positiv eller negativ. 4. Ganska negativ 5. Mycket negativ. mat: antal inköp av mat per vecka 5.1 En binär variabel 5.1.1 Kodning Oavsett om en binär variabel har kategorier som inte går att rangordna (till exempel variabeln kön med kategorierna kvinna och man) eller har kategorier som går att rangordna (till exempel utbildning med kategorierna låg och hög) beskrivs en binär variabel på samma sätt. Vi ska nu visa hur man beskriver en binär variabel, utifrån de tidigare två nämnda alternativen. Vi exemplifierar med att beskriva variabeln som heter utbildning och har två kategorier, låg och hög. Med funktionen str() identifieras att utbildning är en variabel av datatypen character. Det är alltid viktigt att undersöka variablers datatyp, emellertid är detta ingen kod som sedan sparas i scriptet, och koden kan därför raderas ur skriptet när datatypen är undersökt. Funktionen str() är användbar för att undersöka alla typer av objekt i R, till exempel variabler, dataframes och objekt som innehåller sparade resultat. # Undersök hur R identifierar variabelns datatyp str(df$utbildning) &gt; chr [1:280] &quot;hög&quot; &quot;hög&quot; &quot;låg&quot; &quot;hög&quot; &quot;hög&quot; &quot;låg&quot; &quot;hög&quot; &quot;låg&quot; &quot;låg&quot; &quot;hög&quot; ... Med Alternativ 1 för hantering av kategorivariabler tilldelas de två kategorierna i den binära variabeln numeriska värden och variabeln analyseras sedan som en numerisk variabel. Det är vanligast att ge kategorierna värdena 0 och 1. En anledning är tolkningen blir i termer av andelar av den kategori som är kodad 1. Exemplet nedan illustrerar hur man med det numeriska alternativet kan beskriva den ursprungliga variabeln utbildning som har kategorierna låg och hög. Den uppenbara fördelen med att kodningen 0-1, jämfört med 1-2, är att 0-1 ger en bekväm tolkning eftersom medelvärdet då är proportionen. Kommandot str() identifierar nu att både utb_bin och utb_12 är av typen numeric. Med mean() och summary() erhålls information som beskriver utb_bin och utb_12. Vi ser att 41% har hög utbildning, däremot framgår inte antalet som har låg respektive hög utbildning. # Numerisk kodning: 0 = låg, 1 = hög df$utb_bin &lt;- NA df$utb_bin[df$utbildning == &quot;hög&quot;] &lt;- 1 df$utb_bin[df$utbildning == &quot;låg&quot;] &lt;- 0 str(df$utb_bin) &gt; num [1:280] 1 1 0 1 1 0 1 0 0 1 ... mean(df$utb_bin) &gt; [1] 0.4142857 summary(df$utb_bin) &gt; Min. 1st Qu. Median Mean 3rd Qu. Max. &gt; 0.0000 0.0000 0.0000 0.4143 1.0000 1.0000 # Numerisk kodning: 1 = låg, 2 = hög df$utb_12 &lt;- NA df$utb_12 [df$utbildning == &quot;hög&quot;] &lt;- 2 df$utb_12 [df$utbildning == &quot;låg&quot;] &lt;- 1 str(df$utb_12) &gt; num [1:280] 2 2 1 2 2 1 2 1 1 2 ... mean(df$utb_12) &gt; [1] 1.414286 summary(df$utb_12) &gt; Min. 1st Qu. Median Mean 3rd Qu. Max. &gt; 1.000 1.000 1.000 1.414 2.000 2.000 Med Alternativ 2 används funktionen factor() för skapa faktorvariabeln utb_cat. Kommandot str() identifierar nu att utb_cat har två nivåer med kategorinamnen \"låg\" and \"hög\". # Skapa en faktorvariabel df$utb_cat &lt;- factor(df$utbildning) str(df$utb_cat) &gt; Factor w/ 2 levels &quot;hög&quot;,&quot;låg&quot;: 1 1 2 1 1 2 1 2 2 1 ... R tilldelar automatiskt kategorierna nivåer, där \"hög\" är level 1 och \"låg\" är level 2. Observera att nivåer används för att bestämma en rangordning och kan inte användas i aritmetiska beräkningar. Även om valet av nominal- eller ordinalskala i teorin saknar betydelse för en binär variabel är det viktigt att veta ordningen på nivåerna om man hanterar variabeln som en faktor, det finns nämligen analyser i R där ordningen spelar roll. Nivåerna bestäms utifrån den ordning kategorierna dyker upp i variabeln (i detta fallet är den första observationen \"hög\" och får därför level 1) såvida inte en numerisk variabel görs om till en faktor. Faktorvariabler kan beskrivas med summary() som redovisar antalet inom respektive utbildningskategori. Däremot går det inte att använda mean() för att ta fram andelen för en kategorivariabel, eftrsom kategorierna inte tolkas som siffror av R. summary(df$utb_cat) # Summary fungerar bra &gt; hög låg &gt; 116 164 mean(df$utb_cat) # Mean ger ifrån sig ett felmeddelande &gt; Warning in mean.default(df$utb_cat): argument is not numeric or logical: &gt; returning NA &gt; [1] NA I funktionen factor() kan argumentet levels användas för att manuellt ange vilka nivåer varje kategori ska ha. I detta exempel kan det uppfattas som förvirrande att \"hög\" har nivå 1 och \"låg\" har nivå 2, rent intuitivt känns det som att det bore vara tvärtom. Därför kan nivåerna ändras som i koden nedan. df$utb_cat &lt;- factor(df$utb_cat, levels = c(&quot;låg&quot;, &quot;hög&quot;)) # Anger nya nivåer str(df$utb_cat) &gt; Factor w/ 2 levels &quot;låg&quot;,&quot;hög&quot;: 2 2 1 2 2 1 2 1 1 2 ... summary(df$utb_cat) &gt; låg hög &gt; 164 116 När egna argument anges på detta sätt är det viktigt att veta att det första elementet i vektorn med nivåer kommer bli nivå 1, det andra nivå 2, och så vidare. Se i resultatet ovan att nivåerna har förändrats jämfört med tidigare. Vid arbete med faktorer används ofta en funktionen levels() (ej att förväxla med argumententet levels i funktionen factor()) för att se vilka kategorier som finns i en faktorvariabel, och för att ändra namn på kategorierna. Koden nedan, till exempel, visar vilka nivåer som finns i utb_cat. # Ändra för valt element namn i vektor levels(utbildning_cat) levels(df$utb_cat) &gt; [1] &quot;låg&quot; &quot;hög&quot; Koden ger en vektor med två element, ett för varje nivå i kategorivariabeln. För att byta namn på nivåerna kan koden nedan användas. Notera att det första elementet i levels(df$utb_cat) är \"Låg\", precis som bestämdes tidigare. # Ändra för valt element namn i vektor levels(utbildning_cat) levels(df$utb_cat)[1] &lt;- &quot;Låg utbildning&quot; levels(df$utb_cat)[2] &lt;- &quot;Hög utbildning&quot; När nivåerna skrivs ut igen blir det tydligt att namnen har ändrats. I koden nedan används även summary() för att kontrollera att inga konstiga ändringar har gjorts. levels(df$utb_cat) # Nivåerna har ändrats &gt; [1] &quot;Låg utbildning&quot; &quot;Hög utbildning&quot; summary(df$utb_cat) # Resultaten samma som tidigare &gt; Låg utbildning Hög utbildning &gt; 164 116 Det är värt att notera att det också går att ändra kategorinamn med koden nedan. Detta förfarande liknar det som beskrevs för indexering med logiska operatorer i Kapitel 3. Koden är lite längre än den ovan, men den är mycket lättae att läsa i efterhand, och för en utomstående lättare att förstå. Därför rekommenderas nedan sätt på denna kurs. # Ändra för valt element namn i vektor levels(utbildning_cat) levels(df$utb_cat)[levels(df$utb_cat) == &quot;låg&quot;] &lt;- &quot;Låg utbildning&quot; levels(df$utb_cat)[levels(df$utb_cat) == &quot;hög&quot;] &lt;- &quot;Hög utbildning&quot; Avslutningsvis är det viktigt att studera hur bortfall påverkar analyserna ovan. För att göra det kodas de element 3 och 10 om till NA i såväl utb_bin och utb_cat # Skapa en variabel med missing data (NA) i element 3, 10 i den numeriska # variabeln df$utb_bin och genomför samma analys som förut df$utb_bin_mis &lt;- df$utb_bin df$utb_bin_mis[3] &lt;- NA df$utb_bin_mis[10] &lt;- NA # Skapa en variabel med missing data (NA) i element 3, 10 i faktor-variabeln # utb_cat och genomför samma analys som förut df$utb_cat_mis &lt;- df$utb_cat df$utb_cat_mis[3] &lt;- NA df$utb_cat_mis[10] &lt;- NA summary() kan användas på vektorerna med bortfall i eftersom funktionen själv filtrerar ut NA och tar bort dem ur analysen, precis som syns här nedan. Detta gäller såväl för numeriskt kodade binära variabler som för kategorivariabler. summary(df$utb_bin_mis) &gt; Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s &gt; 0.0000 0.0000 0.0000 0.4137 1.0000 1.0000 2 summary(df$utb_cat_mis) &gt; Låg utbildning Hög utbildning NA&#39;s &gt; 163 115 2 I det numeriskt kodade fallet går det även att använda mean() för att beräkna andelen ettor. Precis som tidigare kommer medelvärdet bli NA när bortfall finns med i vektorn, men detta problem hanteras enkelt genom att sätta na.rm = TRUE mean(df$utb_bin_mis) # Medelvärde för alla observationer &gt; [1] NA mean(df$utb_bin_mis, na.rm = TRUE)# Medelvärde där bortfall räknas bort &gt; [1] 0.4136691 5.1.2 Tabeller och figurer Tabeller och kategorivariabler är direkt relaterade, och det går att redovisa en binär variabel med hjälp av tabell-funktionen table(). Denna funktion hanterar både en och flera variabler med olika antal kategorier. Eftersom table() kan vara något svår för nybörjaren är det lämpligt att introducera denna funktion med det enklaste fallet genom att använda de variablerna som skapades tidigare. Funktionen table() kan användas på både numeriskt kodade variabler och på faktorvariabler. Det är dock värt att notera skillnaderna i resultat här nedan. # Tabell baserad på binär variabel. Inga kategorinamn table(df$utb_bin) &gt; &gt; 0 1 &gt; 164 116 # Tabell baserad på faktorvariabel. Kategorinamn finns table(df$utb_cat) &gt; &gt; Låg utbildning Hög utbildning &gt; 164 116 När table() används på en numeriskt kodad variabel kommer tabellen använda siffrorna i kodningen som namn på kategorierna, men när funktionen används på en faktorvariabel med angivna namn kan R hitta namnen och använda dem i tabellen. Till skillnad från summary() anger table() inte automatiskt om det finns bortfall. table() använder aldrig NA i beräkningarna men den redovisar inte heller om bortfall finns per default, detta kan justeras med argumentet useNA. När useNA = \"ifany\" kommer table rapportera antalet NA när sådana finns, och fungera precis som vanligt när inget bortfall förekommer. Se koden nedan för ett exempel. # Tabell baserad på variabel med bortfall table(df$utb_cat_mis) &gt; &gt; Låg utbildning Hög utbildning &gt; 163 115 # Tabell baserad på variabel med bortfall där vi tar hänsyn till detta i tabellen table(df$utb_cat_mis, useNA = &quot;ifany&quot;) &gt; &gt; Låg utbildning Hög utbildning &lt;NA&gt; &gt; 163 115 2 Tabeller som skapas med table() kan sparas i objekt, precis som vektorer, data frames och matriser. Ett objekt som skapas med table() kan användas för att komma åt många funktionaliteter i R. Ett exempel på en sådan funktionalitet är funktionen prop.table(), som används för att skapa en tabell som visar relativa frekvenser (andelar) istället för frekvenser. Nedan sparas table(df$utb_cat) i ett objekt som sedan används i prop.table() för att beräkna andelarna (0.414 och 0.586) för respektive utbildningsnivå. &gt; # Skapa tabell-objekt med frekvenser från tabell-objektetet &gt; freq_utb_cat &lt;- table(df$utb_cat) &gt; freq_utb_cat &gt; &gt; Låg utbildning Hög utbildning &gt; 164 116 &gt; &gt; # Skapa tabell med andelar från tabell-objektetet &gt; prop_utb_cat &lt;- prop.table(freq_utb_cat) &gt; prop_utb_cat &gt; &gt; Låg utbildning Hög utbildning &gt; 0.5857143 0.4142857 Det går nu att räkna om andelarna till procentsatser genom att multiplicera tabellen med 100. &gt; 100 * prop_utb_cat &gt; &gt; Låg utbildning Hög utbildning &gt; 58.57143 41.42857 Det går även att använda funktionen round() för att avrunda i tabellen. I round används argumentet digits för att ange hur långt värdena ska avrundas. I koden nedan sätts digits = 1, men testa gärna själv att köra motsvarande kod med digits = 2 eller digits = 3. &gt; procent_utb_cat &lt;- round(100 * prop_utb_cat, digits = 1) &gt; procent_utb_cat &gt; &gt; Låg utbildning Hög utbildning &gt; 58.6 41.4 Ofta är det önskvärt att beskriva såväl frekvensker som procentsatser i samma tabell. För att göra detta på ett snyggt sätt kan tabell-objekt bindas samman med cbind(), precis som nedan. Notera att colnames() kan användas för att namnge kolumnerna i tab_utb. &gt; # Binder samman tabellobjekt &gt; tab_utb &lt;- cbind(freq_utb_cat, procent_utb_cat) &gt; tab_utb &gt; freq_utb_cat procent_utb_cat &gt; Låg utbildning 164 58.6 &gt; Hög utbildning 116 41.4 &gt; &gt; # Snyggar till genom att ge kolumnnamn &gt; colnames(tab_utb) &lt;- c(&quot;Frekvens&quot;, &quot;Procent (%)&quot;) &gt; tab_utb &gt; Frekvens Procent (%) &gt; Låg utbildning 164 58.6 &gt; Hög utbildning 116 41.4 Utöver tabeller kan även figurer av olika slag användas för att beskriva datamaterial och presentera resultat från en analys. För att illustrera kategorivariabler används ofta stapeldiagram, som i R konstrueras sådana med funktionen barplot(). Det går att betrakta stapeldiagram som en grafisk representation av en tabell, och det är därför naturligt att använda tabell-objekt i barplot() (funktionen kräver inte att tabeller används, men tabell-objekt underlättar för användaren). Ett väldigt primitivt stapeldiagram kan skapas med koden nedan. &gt; barplot(freq_utb_cat) Figuren ovan är inte särskilt intuitiv, och det är svår att veta vad för typ av information den illustrerar. För att snygga till tabellen används argumenten ylab och xlab för att ge namn åt figurens axlar. Detta demonstreras i koden nedan. barplot(freq_utb_cat, # Anger tabellen som ska beskrivas ylab = &quot;Antal&quot;) # Anger namn för y-axeln Det är inte bara frekvenstabeller som kan användas i barplot(), utan funktionen är även kompatibel med tabeller som skapats av prop.table(). Detta illustreras nedan. barplot(procent_utb_cat, ylab = &quot;Procent (%)&quot;) Med argumentet main går det även att ange en titel till diagrammet. Testa gärna detta själv, principen är densamma som för axelnamn. I det enkla fallet med bara en binär variabel kan stapeldiagram tyckas vara lite onödiga, detta eftersom de tar mycket mer plats än en tabell men egentligen inte tillför någon ny information. Detta är naturligtvis upp till varje enskild användare att göra, men på denna kurser rekommenderas tabeller i detta enkla fall. Detta betyder inte att stapeldiagram inte fyller någon funktioner. I senare avnsitt av detta kapitel visas fler situationer där stapeldiagram är lämpliga. 5.1.3 Inferens Notera att inferensdelen av detta kapitel inte hör till programmeringsblocket, utan det kommer diskuteras under ett senare block av kursen. Under programmeringsblockets gång kan du med gott samvete hoppa över denna del och börja läsa igen under rubriken Två binära variabler. Hittills har vi ägnat oss åt att beskriva en binär variabel i stickprovet, men ofta är målet att uttala oss om egenskaper i en population, så kallad inferens. Vi kommer i detta avsnitt att utgå från en beskrivande frågeställning och följande två sätt att göra inferens är då vanliga. Det första sättet är att beräkna konfidensintervall för med viss säkerhet få en uppfattning om andelen i populationen, \\(p\\). Det andra är att med hypotesprövning undersöka i vilken utsträckning vårt data stämmer överens med en hypotes om populationen, \\(H_0: p =p_0\\). Utgångspunkten är ett slumpmässigt urval från en stor population och vi börjar med att se hur ett konfidensintervall kan konstrueras för andelen \\(p\\) i populationen. Stickprovsandelen är \\(\\hat{p}\\) kan definieras som \\(\\hat{p}=\\dfrac{k}{n}\\) där \\(n\\) är antal försök (antal 0or och 1or) och \\(k\\) är antalet lyckade försök (antal 1or). Givet OSU och \\(np(1-p)&gt;5\\) är andelsestimatorn approximativt normalfördelad och ett konfidensintervall ges av \\[ \\hat{p}\\pm z_{\\alpha/2}\\sqrt{\\hat{V}(\\hat{p})}, \\] där \\(\\hat{V}(\\hat{p}) = \\dfrac{\\hat{p}(1-\\hat{p})}{n}\\) är skattningen av stickprovsandelens varians och \\(z_{\\alpha/2}\\) är ett värde från den standardnormalfördelningen baserat på konfidensgraden \\(100(1-\\alpha)\\%\\). Notera att felmarginalen är \\(z_{\\alpha/2}\\sqrt{\\hat{V}(\\hat{p})}\\). Anta variabeln utbldning består av mätningar på individer dragna med OSU från en stor population. Målet är att beräkna ett 95% konfidensintervall för andelen med högutbildning i populationen, \\(p\\). Genom att implementera ovanstående formler kan detta enkelt beräknas i R. # Beräkna antalet lyckade försök k (antal 1or) k &lt;- freq_utb_cat[2] # Beräkna antal försök (1or or 0r). Denna kodning gör att eventuella NA inte tas med i beräkningen av n n &lt;- sum(freq_utb_cat) # Skattning av andelen med hög utbildning. Det går även att använda mean(df$utb_bin) phat &lt;- k/n # Skatta variansen vphat &lt;- phat*(1-phat)/n # Välja konfidensgrad 100*(1-alpha)% alpha &lt;- 0.05 # Detta ger värdet för från z-fördelningen med 2.5% i högre svansen z_alpha &lt;- qnorm((1-alpha/2)) # Konfidensintervallets nedre gräns (lower limit) ll &lt;- phat - z_alpha*sqrt(vphat) # Konfidensintervallets övre gräns (upper limit) ul &lt;- phat + z_alpha*sqrt(vphat) p_KI &lt;- c(ll, ul) p_KI Hög utbildning Hög utbildning 0.3565876 0.4719839 # Undersöker förutsättningen np(1-p) &gt;5. Vi använder phat istället för p eftersom det är det enda vi # har. Man måste alltid undersöka om resultaten går att lita på! n*phat*(1-phat) Hög utbildning 67.94286 Vi skattar att 41.4% är högutbildade i populationen. Med 95% säkerhet är andelen högutbildade i populationen mellan 35.7% och 47.2% Vi ska nu se på hur inferens kan göras i form av hypotesprövning. Givet OSU och samma förutsättningar som för skapandet av konfidensintervall gäller vid hypotesprövning av \\(H_0: p = p_{H_0}\\) test-statistikan \\[z = \\dfrac{\\hat{p} - p_{H_0}}{\\sqrt{\\dfrac{p_{H_0}(1-p_{H_0})}{n}}}\\] är approximativt \\(N(0,1)\\) om \\(H_0\\) är sann. För att exemplifiera, anta att vi vill undersöka om 40% i populationen har hög utbildning. Vi sätter upp hypoteserna \\(H_0: p = 0.4\\) vs \\(H_1: p \\neq 0.4\\). Utifrån från formeln ovan beräknas det observerat \\(z\\)-värde. Vi ser sedan se hur extremt det är i en standardnormalfördelning för att få fram \\(p\\)-värdet. Vad som avses med extremt beror på formulering av mothypotesen, dvs om den är ensidig eller tvåsidig. Om vi önskar fatta ett beslut jämförs \\(p\\)-värdet mot en förvald signifikansnivå. # p givet nollhypotesen pH0 &lt;- 0.4 # Teststatistika zobs &lt;- (phat - pH0)/sqrt(pH0*(1-pH0)/n) zobs Hög utbildning 0.48795 # Vi erhåller ett observerat z-värde. p-värdet är anger hur extremt detta z-värde. # pnorm() för sannolikheten VÄNSTER om z-värdet. Se Tabell 6.2.A i Formelsamling. För att beräkna # # p-värdet vid två sidig mothypotes används absolutbesloppet (abs()) och vi tar 1 minus och multiplicerar med 2. p_value &lt;- 2*(1 - pnorm(abs(zobs)) ) p_value Hög utbildning 0.6255852 Vi erhåller att \\(p=\\) 0.626. Tolkningen är att givet att andelen högutbildade i populationen skulle vara 40% är sannolikheten 0.63 att observera andelen som observeras eller mer extrem. Data stämmer alltså ganska väl överens med nollhypotesen! Ett beslut på 5% signifikansnivå skulle innebär att vi inte kan förkasta nollhypotesen. Huruvida vi vill fatta ett beslut eller inte beror på målet för analysen. Det finns dock en inbyggd funktion i R för att göra ovanstående analyser, nämligen prop.test(). I funktionen prop.test() anges först antalet lyckade försök (1or) samt det totala antalet försök (1or och 0r). Med argumentet p anges nollhypotesen och med argumentet alternative specificeras mothypotesen. Argumentet conf.level anger konfidensgrad för konfidensintervallet. Slutligen bestämmer argumentet correct om kontinuitetsskorrektion ska användas. Vi använder inte kontinuitetskorrektion på denna kurs och sätter denna till FALSE. # Använd funktionen prop.test() för att skapa konfidensintervall utan korrigering utb_analysis &lt;- prop.test(x = k, # Antal lyckade försök (1or) n = n, # Antal försök (1or och 0or) p = 0.4, # H0 alternative = &quot;two.sided&quot;, # Mothypotes conf.level = 0.95, # Signifikansnivå 1-conflevel correct = FALSE) # Ej kontnuitetskorrektion utb_analysis 1-sample proportions test without continuity correction data: k out of n, null probability 0.4 X-squared = 0.2381, df = 1, p-value = 0.6256 alternative hypothesis: true p is not equal to 0.4 95 percent confidence interval: 0.3581276 0.4727639 sample estimates: p 0.4142857 Vi börjar med att se på resultatet från hypotesprövningen och upptäcker exakt samma \\(p\\)-värde som förut! Vårt tidigare observerade \\(z\\)-värde, 0.488 erhålls genom att ta roten ur 0.2380952. Vidare är konfidensintervallet mycket likt det tidigare framräknade intervallet. De överensstämmer dock inte exakt, vilket beror på att R använder något en annan formel för konfidensintervallet som har något bättre egenskaper om andelen är nära 0 eller 1 och stickprovet är litet. Anta att vi vill hämta värden från analysen som finns i det sparade objektet utb_analysis. Genom att använda str() redovisas vad som finns sparat i objektet. Koden nedan illustrerar hur \\(p\\)-värdet kan hämtas om vi enbart är intresserad av just detta. div.green{ background-color:#abd4b3; border-radius: 5px; padding: 20px;} Risk med inferens när \\(p\\) är nära 0 eller 1 Om andelen i populationen är nära 0 eller 1 krävs stort stickprov för att inferensen ska bli korrekt! Tumregeln \\(np(1-p)&gt;5\\) fungerar dåligt om andelen i populationen är mycket nära 0 eller 1. Konsekvensen blir för lägre konfidensgrad och ett högre Typ-I fel än i förväg angivet. Vi gör fel oftare! Beträffande konfidensintervall är Wilson score interval, som är det konfidensintervall R använder i prop.test, ett något bättre alternativ än den formeln som vi använder. I de absolut flesta fall har det inget betydelse om vi väljer prop.test() eller intervallet som baseras på normalapproximation. För hypotesprövning finns alternativet att använda ett så kallat exakt binomial-test. Detta test introduceras emellertid inte här utan vi hänvisar till funktionen binom.test() och tillhörande dokumentation. Var som sagt uppmärksam om andelen är nära 0 eller nära 1! Undersök på egen hand med följande app! https://jetty.im.uu.se/shiny/ConfidenceIntervals_prop/ div.yellow{ background-color:#FFFA94; border-radius: 5px; padding: 20px;} Test av andelar eller \\(\\chi^2\\)-test? Ett prop.test() med två-sidig mothypotes är likvärdigt med \\(\\chi^2\\)-test. \\(\\chi^2\\)-statistikan är samma som \\(z\\)-statistikan i kvadrat! Problemet med test av \\(p\\) kan nämligen formuleras som ett goodness-of-fit test med observerade frekvenser (\\(116\\) 1or och \\(164\\) 0or) och under nollhypotesen förväntade frekvenser (\\(np_{H_0}=112\\) 1or och \\(n(1-p_{H_0})=168\\) 0r). Vi illusterar i en tabell: 1or 0or 116 (112) 164 (168) Formeln för \\(\\chi^2\\)-testet går det sedan att tillämpa \\[\\chi^2 = \\sum_{i=1}^2 \\dfrac{(O_i-E_i)^2}{E_i} = \\dfrac{(116-112)^2}{112} + \\dfrac{(164-168)^2}{168}=0.2381\\] vilket i detta fall jämförs med en \\(\\chi^2\\)-fördelning med 1 frihetsgrad. Notera att mothypotesen vid \\(\\chi^2\\)-testet alltid är två-sidig, vilket motiverar användningen av prop.test(). 5.2 Två binära variabler 5.2.1 Tabeller Det primära analysverktyget för två binära variabler är i regel table(). Även om table() kan användas vid analys av en enda variabel, är den framför allt användbar för att skapa korstabeller, dvs analys av två kategorivariabler samtidigt. I table() anges den radvisa variabeln först, sedan kolumnvisa variabeln. Tabellen som erhålls kallas i fallet med två variabler för tvåvägs-korstabell. I de fall det går att översätta variablerna i termer av oberoende variabel och beroende variabel, sätts den oberoende variabeln i regel kolumnsvis (x-axel) och den beroende variabeln radvis (y-axel). Detta är analogt med spridningsdiagram som har en \\(x\\)-variabel och en \\(y\\)-variabel! Vi ska nu beskriva sambandet mellan utbildningsnivå och rökning. Först skapas en korstabell med frekvenser, sedan skapas en tabell innehållande andelar. Notera att det kräver en del pusslande för att få tabeller precis som man önskar, men i gengäld erhålls stor flexibilitet vad gäller den slutliga utformningen av tabellen. freq_table_utb_rokare &lt;- table(df$rokare, df$utb_cat) freq_table_utb_rokare &gt; &gt; Låg utbildning Hög utbildning &gt; 0 76 80 &gt; 1 88 36 Vi har en tabell med frekvenser, men för att använda tabellen måste den i regel modifieras. För det första måste rader och kolumner tydligare namnges. Vi kan här tillämpa funktionerna rownames() och colnames(). # Med rownames() kan vi förtydliga radnamnen rownames(freq_table_utb_rokare) &lt;- c(&quot;Icke rökare&quot;, &quot;Rökare&quot;) freq_table_utb_rokare &gt; &gt; Låg utbildning Hög utbildning &gt; Icke rökare 76 80 &gt; Rökare 88 36 Om tanken är att utföra en sambandsanalys är det viktigt att åskådliggöra samandet bättre, det är nämligen svårt avläsa samband med enbart frekvenser och därför behöver procentsatser anges. Precis som tidigare används därför funktionen prop.table() på ett objekt från table(). En två-vägs kortstabell ger nu prop.table() tre möjligheter att beräkna andelar: Andelar baserade på totala antalet (default) Andelar beräknade utifrån radvisa totaler i nämnarna, genom att sätta argumentet margin = 1 Andelar baserade på kolumnvisa totaler i nämnarna, genom sätta argumentet margin = 2. Notera att det är mycket viktigt att välja rätt andelar att beräkna, eftersom dessa direkt styr tolkningen av resultaten. Vi illustrerar nu hur andelarna beräknas i R och tolkar dem efter det. # Andelar baserat alla table_all &lt;- prop.table(freq_table_utb_rokare) table_all &gt; &gt; Låg utbildning Hög utbildning &gt; Icke rökare 0.2714286 0.2857143 &gt; Rökare 0.3142857 0.1285714 # Andelar baserat rader table_row_prop &lt;- prop.table(freq_table_utb_rokare, margin = 1) table_row_prop &gt; &gt; Låg utbildning Hög utbildning &gt; Icke rökare 0.4871795 0.5128205 &gt; Rökare 0.7096774 0.2903226 # Andelar baserat kolumner table_column_prop &lt;- prop.table(freq_table_utb_rokare, margin = 2) table_column_prop &gt; &gt; Låg utbildning Hög utbildning &gt; Icke rökare 0.4634146 0.6896552 &gt; Rökare 0.5365854 0.3103448 Ägna några minuter åt att försöka tolka de olika tabellerna för dig själv (tolkningarna återges i detalj under fliken här nedan)! Visa svar För att förenkla tolkningen beskriver vi nedan sambanden i termer av sannolikheter. Den första tabellen visar att av alla i undersökningen är 27.1% icke-rökare och har låg utbildning. Om urvalet är slumpmässigt är detta således en skattning av sannolikheten \\(\\Pr(\\text{Icke-rökare}\\,\\, \\&amp; \\,\\, \\text{Låg utbildning})\\). På motsvarande sätt är 28.6%, 31.4% och 12.9% skattningar av \\(\\Pr(\\text{Icke-rökare}\\,\\, \\&amp; \\,\\, \\text{Hög utbildning})\\), \\(\\Pr(\\text{Rökare}\\,\\, \\&amp; \\,\\, \\text{Låg utbildning})\\) och \\(\\Pr(\\text{Rökare}\\,\\, \\&amp; \\,\\, \\text{Hög utbildning})\\). Huruvida dessa skattningar är relevanta beror på syftet med undersökningen. Den andra tabellen visar, genom att beräkna radprocent, att bland icke-rökarna har 48.7% låg utbildning. Det innebär naturligtvis att bland icke-rökarna har 51.3% hög utbildning. Om urvalet är slumpmässigt är dessa skattningar av \\(\\Pr(\\text{Låg utbildning}|\\text{Icke-rökare})\\) och \\(\\Pr(\\text{Hög utbildning}|\\text{Icke-rökare})\\). På motsvarande sätt har 71% låg utbildning respektive 29% hög utbildning bland rökarna. \\(\\Pr(\\text{Låg utbildning}|\\text{Rökare})\\) och \\(\\Pr(\\text{Hög utbildning}|\\text{Rökare})\\). Vi kan alltså med denna analys jämföra utbildningsnivån bland icke-rökare och rökare. Den tredje tabellen visar, genom att beräkna kolumnprocent, att bland de lågutbildade röker 53.7% medan bland de högutbildade röker 31%. Detta är således skattningar av \\(\\Pr(\\text{Rökare} | \\text{Låg utbildning})\\) respektive \\(\\Pr(\\text{Rökare} | \\text{Hög utbildning})\\). På motsvarande sätt är 46.3% och 69% skattningar av \\(\\Pr(\\text{Icke-rökare}|\\text{Låg utbildning})\\) och \\(\\Pr(\\text{Icke-rökare}|\\text{Hög utbildning})\\). Vi kan konstatera att i stickprovet är andelen rökare större bland lågutbildade än högutbildade. Vilken tabell som redovisas beror således på frågeställning. Om syftet är att studera huruvida utbildning påverkar benägenheten att röka är det den tredje tabellen den som ska redovisas. Det är nämligen i denna enkelt att jämföra andelarna som röker i respektive utbildningskategori. Vi konstruerar nu en korstabell innehåller både frekvenser och andelar baserade på kolumner, och som tydligt beskriver sambandet. Tabellen konstrueras med cbind(), dessutom skapas procent med en decimal genom att använda round(100*andel, digits = 1). # Skapa tabell för presentation av analys table_utb_rokare &lt;- cbind(freq_table_utb_rokare[,1], round(100*table_column_prop[,1], digits = 1), freq_table_utb_rokare[,2], round(100*table_column_prop[,2], digits = 1)) # Ange kolumnm colnames(table_utb_rokare) &lt;- c(&quot;Låg (n)&quot;, &quot;Låg (%)&quot;, &quot;Hög (n)&quot;, &quot;Hög (%)&quot;) # Se på tabellen table_utb_rokare &gt; Låg (n) Låg (%) Hög (n) Hög (%) &gt; Icke rökare 76 46.3 80 69 &gt; Rökare 88 53.7 36 31 Avslutningsvis, för fullständighetens skull, används funktionen addmargins() på tabellobjektet för att addera marginalsummor till tabellen. Genom att ange margin = 1 adderas kolumnsummor, precis som i koden nedan. Prova gärna själv vad som händer när margin = 2 och margin = c(1, 2). table_utb_rokare_final &lt;- addmargins(table_utb_rokare, margin = 1) rownames(table_utb_rokare_final) &lt;- c(&quot;Icke-rökare&quot;, &quot;Rökare&quot;, &quot;Summa&quot;) table_utb_rokare_final &gt; Låg (n) Låg (%) Hög (n) Hög (%) &gt; Icke-rökare 76 46.3 80 69 &gt; Rökare 88 53.7 36 31 &gt; Summa 164 100.0 116 100 Nu är vi klara med tabellen! Det som återstår är att exportera den till ett ordbehandlingsprogram eller ett bildspel, men detta beskrivs i ett senare avsnitt. 5.2.2 Kvantifiering av samband Samband eller beroende mellan två binära variabler kan kvantifieras med olika mått. Ett vanligt sätt är användning av \\(\\chi^2\\)-måttet för att testa om två variabler är oberoende och kan sägas undersöka hur starkt ett samband är. Förutom \\(\\chi^2\\)-måttet finns en rad andra mått för graden av beroende, såsom Lambda-koefficienten, Cramérs V och tetrakorisk korrelation. Dessa mått introduceras inte här, men det kan vara bra att känna till att det finns alternativ till \\(\\chi^2\\)-måttet. Ofta vill undersökaren dock relatera sambandet till en konkret frågeställning som inte bara handlar om beroende, det vill säga man önskar få en uppfattning av storleken på sambandet. De tre vanligaste måtten på storleken på samband (så kallade effektstorlekar) mellan två binära variabler är: Skillnaden i andelar (absolut jämförelse av andelar): \\[p_{\\text{diff}} = \\Pr(Y=1|X=1) - \\Pr(Y=0|X=1) = p_1 - p_0. \\] Skillnaden i andelar kan anta värdena \\(-1 \\leq p_{\\text{diff}} \\leq 1\\) Ofta kallat riskdifferens. Skillnaden i andelar är även en skillnad i procentenheter. \\(0\\) indikerar ingen skillnad. Positiva värden indikerar en högre sannolikhet i grupp 1 jämfört med grupp 0. Negativa värden indikerar en lägre sannolikhet i grupp 1 jämfört med grupp 0. Kvoten av andelar (relativ jämförelse av andelar): \\[p_{\\texttt{kvot}} = \\dfrac{\\Pr(Y=1|X=1)}{\\Pr(Y=0|X=1)}= p_1/p_0. \\] Kvoten av andelar kan anta värdena \\(0 \\leq p_{\\texttt{kvot}} &lt; \\infty\\). Ofta kallat relativ risk. \\(p_{\\texttt{kvot}}=1\\) indikerar ingen skillnad mellan grupperna. \\(p_{\\texttt{kvot}} &gt;1\\) indikerar en högre sannolikhet i grupp 1 jämfört med grupp 0. \\(p_{\\texttt{kvot}} &lt; 1\\) indikerar en lägre sannolikhet i grupp 1 jämfört med grupp 0. Oddskvoten (relativ jämförelse av odds): \\[OR = \\dfrac{Odds(X=1)}{Odds(X=0)}=\\dfrac{\\dfrac{\\Pr(Y=1|X=1)}{1 - \\Pr(Y=1|X=1)}}{\\dfrac{\\Pr(Y=1|X=0)}{1 - \\Pr(Y=1|X=0)}} = \\dfrac{p_1/(1-p_1)}{p_0/(1-p_0)}, \\] där oddset för en händelse givet \\(x\\) är definierat som \\[Odds(X=x)=\\dfrac{\\Pr(Y=1|X=x)}{1-(\\Pr(Y=1|X=x)}=\\dfrac{\\Pr(Y=1|X=x)}{\\Pr(Y=0|X=x)}.\\] Oddskvoten kan anta värdena \\(0 \\leq OR &lt; \\infty\\). Ofta kallat oddsratio. \\(OR=1\\) indikerar ingen skillnad mellan grupperna. \\(OR &gt;1\\) indikerar en högre sannolikhet i grupp 1 jämfört med grupp 0. \\(OR &lt; 1\\) indikerar en lägre sannolikhet i grupp 1 jämfört med grupp 0. Notera att ovanstående mått är definierade utifrån populationen. I praktiken används motsvarigheterna i stickprovet \\(\\hat{p_1}=k_1/n_1\\) och \\(\\hat{p_0}=k_0/n_0\\), där \\(k_1\\) och \\(k_0\\) är antalet lyckade försök (antal ettor) i respektive \\(x\\)-kategori och \\(n_1\\) och \\(n_0\\) är antalet försök i respektive \\(x\\)-kategori. Vilket av dessa tre mått som är mest relevant att presentera beror på syftet med undersökningen och ofta bör åtminstone både ett absolut mått och ett relativt mått presenteras. Måste man göra en indelning kan absoluta jämförelser av andelar ofta (men inte alltid!) vara mest policy-relevant eftersom måttet kan tolkas som en skillnad i procenheter mellan två stycken grupper. Däremot kan en relativ jämförelse av andelar uppfattas som mer relevant för en enskild individ. Detta beror dock på andra faktorer som populationsstorleken! Eftersom oddskvoten inte är lika enkel att förstå som relativa andelar är det ett mått som i regel främst väljs på grund av studiedesign eller statistisk analysmetod. # Beräkna andelen rökare bland högutbildade. Det går även att använda mean( rokare[df$utb_bin == 1] ) eller table_row_prop[2,2] k1 &lt;- freq_table_utb_rokare[2,2] n1 &lt;- sum(freq_table_utb_rokare[,2]) # Summera antal i kolumn 2, dvs de i kategori 1 phat1 &lt;- k1/n1 # Beräkna andelen rökare bland lågutbildade. Det går även att använda mean( rokare[df$utb_bin == 0] ) eller table_row_prop[2,1] k0 &lt;- freq_table_utb_rokare[2,1] n0 &lt;- sum(freq_table_utb_rokare[,1]) # Summera antal i kolumn 1, dvs de i kategori 0 phat0 &lt;- k0/n0 # Skillnad i andelar phat_diff &lt;- phat1 - phat0 phat_diff [1] -0.2262405 # kvot av andelar phat_kvot &lt;- phat1/phat0 phat_kvot [1] 0.5783699 # oddskvot orhat &lt;- (phat1/(1-phat1))/((phat0/(1-phat0))) orhat [1] 0.3886364 Tolkningen av dessa tre resultat är: Bland högutbildade röker 22 procentenheter mindre jämfört med lågutbildade. Högutbildade har 100(1 - 0.578)% = 42.2% reducerad sannolikhet (risk) att röka jämfört med lågutbildade. Högutbildade har 100(1 - 0.389)% = 62.1% reducerat odds för att röka jämfört lågutbildade. En pedagogisk poäng skulle vara att vända på analysen, dvs att sätta den kategori som ökar sannolikheten (lågutbildade) som 1 och jämförelsekategorin (högutbildade) som 0. Detta skulle ge följande resultat och tolkning: Bland lågutbildade röker 22 procentenheter fler jämfört med lågutbildade. Lågutbildade har 72.9% ökad sannolikhet att röka jämfört med högutbildade. Lågutbildade har 2.57 gånger större odds för att röka jämfört med lågutbildade. div.yellow{ background-color:#FFFA94; border-radius: 5px; padding: 20px;} Absoluta eller relativa jämförelser av andelar? Anta att 0.2% (2 av 1000) av alla som får Covid-19 dör. Ett studie visar att ett nytt antiviralt läkemedel leder till att endast 0.1% (1 av 1000) dör. Det är en skillnad i dödlighet på endast 0.1 procentenheter, men för individen innebär detta en halverad risk för att dö! Huruvida det är policyrelevant beror dock på hur många man räknar med att drabbas. Låt säg att bara 10 000 drabbas av Covid-19, då skulle läkemedlet rädda 10 liv. Skulle däremot 1 miljon få Covid-19 då skulle läkemedlet potentiellt rädda 10 000 liv. Anta att arbetsförmedlingen introducerar ett nytt åtgärdsprogram riktat mot gymnasieungdomar som riskerar att inte slutföra gymnasieskolan. Bland eleverna som deltar i programmet kommer 90% få slutbetyg, medan i kontrollgrupp får 70% slutbetyg. Det är alltså en skillnad på hela 20 procentenheter. För en individ ökar dock sannolikheten till behörighet med endast 29%. 5.2.3 Figurer För att åskådliggöra samband mellan två binära variabler används återigen oftast barplot(), och precis som tidigare används barplot() enklast tillsammans med ett tabell-objekt. Sedan tidigare vet vi att barplot() kan användas för att beskriva enkla frekvanstabeller över en variabel, men i detta avsnitt ska vi visa att det även går att illustrera korstabeller (alltså tabeller med två variabler) med hjälp av barplot(). Innan vi börjar skapa stapeldiagram är det bra att återbekanta oss med tabellerna freq_table_utb_rokare, table_row_prop, table_col_prop, som skapades tidigare. Titta på tabellerna här nedan, och fundera på hur du tror att de resulterande stapeldiagrammen kommer se ut. Diskussion av detta följer nedan. freq_table_utb_rokare Låg utbildning Hög utbildning Icke rökare 76 80 Rökare 88 36 table_row_prop Låg utbildning Hög utbildning Icke rökare 0.4871795 0.5128205 Rökare 0.7096774 0.2903226 table_column_prop Låg utbildning Hög utbildning Icke rökare 0.4634146 0.6896552 Rökare 0.5365854 0.3103448 Med freq_table_utb_rokare skapas ett stapeldiagram som redovisar antalet i respektive kategori. Vad denna figur visar är att det finns fler lågutbildade än högutbildade. Dessutom relaterar diagrammet direkt till frekvenserna i varje cell i tabellen. Denna figur är kan vara användbar i en del fall, men ofta blir det svårt att utläsa samband. Just nu kan du borste från argumentet col och funktionen legend() i kodsnuttarna nedan, och bara fokusera på vad diagrammen faktiskt visar. Vi kommer titta närmare på såväl col som legend() lite senare i detta kapitel. # Stapeldiagram med frekvenser barplot(freq_table_utb_rokare, ylab = &quot;Antal&quot;, col = c(&quot;gray40&quot;, &quot;gray95&quot;)) legend(&quot;top&quot;, xpd = TRUE, horiz = TRUE, inset = c(0,-0.4), legend = c(&quot;Icke-Rökare&quot;, &quot;Rökare&quot;), fill = c(&quot;gray40&quot;, &quot;gray95&quot;), bty = &quot;n&quot;) Med table_row_prop blir figuren meninglös eftersom andelen lågutbildade är mer än 1! barplot(table_row_prop, ylab = &quot;Andel&quot;, col = c(&quot;gray40&quot;, &quot;gray95&quot;)) legend(&quot;top&quot;, xpd = TRUE, horiz = TRUE, inset = c(0,-0.4), legend = c(&quot;Icke-Rökare&quot;, &quot;Rökare&quot;), fill = c(&quot;gray40&quot;, &quot;gray95&quot;), bty = &quot;n&quot;) Med table_col_propges en tydlig bild av om andelen rökare inom respektive utbildning. Om vi däremot önskar få någon uppfattning om antalet som finns i respektive utbildningskategori ger denna figur ingen information. barplot(table_column_prop, ylab = &quot;Andel&quot;, col = c(&quot;gray40&quot;, &quot;gray95&quot;)) legend(&quot;top&quot;, xpd = TRUE, horiz = TRUE, inset = c(0,-0.4), legend = c(&quot;Icke-Rökare&quot;, &quot;Rökare&quot;), fill = c(&quot;gray40&quot;, &quot;gray95&quot;), bty = &quot;n&quot;) Eftersom denna typ av stapeldiagram kan ses som grafiska representationer av korstabeller är det viktigt att hålla koll på vilka andelar det är som representeras i diagrammen, detta kontrolleras som sagt med margin i table()-funktionen. En tumregel är enkel att se när table_column_prop jämförs med det tredje diagrammet ovan. Som syns representeras en kolumn i table_column_prop av en egen stapel i diagrammet. Detta är standard i R, och det är i regel så att kolumner blir till staplar vid denna typ av operation. Därför är en bra tumregel att alltid ha andelar baserade på kolumner när tabellen ska illustreras i ett stapeldiagram, annars blir diagrammet väldigt svårtolkat. Nu några ord om argumentet col och funktionen legend(). Som ni kanske förstod används col för att bestämma vilka färger staplarna i diagrammet ska ha. I R finns en mängd färger att välja mellan, en lång lista av färgernas namn åtrefinns här. Testa gärna att ändra på färger i något av diagrammet ovan för att bekanta dig med hur argummentet fungerar. Vad gäller legend() används funktionen för att lägga till en vägledning/förklaring i figuren. Om figuren skapas helt utan legend() blir den omöjlig att förstå och tolka, se nedan. barplot(table_column_prop, ylab = &quot;Andel&quot;, col = c(&quot;gray40&quot;, &quot;gray95&quot;)) Denna typ av instruktion heter legend på engelska, och i brist på ett bättre svenskt uttryck (den som kommer på ett för gärna höra av sig till Valentin) kommer legend avnändas på denna kurs. Som syns används legend() i direkt anslutning till barplot() (eller någon annan typ av diagramfunktion). Etersom argumenten är svåra att avkoda direkt följer en kort förklaring av de viktigaste argumenten Det första argumentet, ovan specificerat som \"top\" anger var i figuren legenden ska finnas. Argumentet kan även specificeras som till exempel \"bottom\" xpd: sätts nästan alltid till TRUE. Detta argument avgör huruvida legenden får finnas utanför själva diagrammet eller ej. Om det sätts till FALSE kommer legenden nästan alltid ligga över staplarna i sig, vilket påverkar diagrammets utseende negativt. Ha därför som vana att stätta xpd = TRUE. horiz: avgör huruvida legenden ska vara horisontell (liggande) eller ej. Om vi vill ha legenden vid sidan av diagrammet, snarare än ovanför eller under, kan det vara mer lämpligt att sätta horiz = FALSE inset: används för att flytta legenden (både lodrätt och vågrätt). Testa att ändra på siffrorna i argumentet för att se hur det fungerar. legend: anger namn på variablerna som finns i legenden. Kontrollera alltid att namnen representerar rätt del av stapeln genom att jämföra med tabellen. fill: anger vika färger som ska finnas i kvadraterna bredvid namnen i legenden. Dessa kopieras nästan alltid direkt från argumentet col i barplots(). bty: anger vilken typ av ruta som ska finnas runt legenden Kan vara antingen \"n\" (ingen ruta) eller \"o\" (en rektangel). Testa gärna båda för att se vad som händer. Det är alltid viktig att kontrollera att diagrammet faktiskt stämmer överens med korstabellen. Kontrollera alltid att färgerna i legenden och diagrammet matchar med rätt andel (frekvens) kategori i tabellen. Anta att syftet är att studera andelen rökare inom respektive utbildningskategori och vi väljer därför figuren som baseras på table_column_prop. Med argumentet beside och placering av staplarna bredvid varandra kan sambandet eventuellt tydligare åskådliggöras. # Uppdelat stapeldiagram barplot(table_column_prop, ylab = &quot;Andel&quot;, col = c(&quot;gray40&quot;, &quot;gray95&quot;), beside = TRUE) legend(&quot;top&quot;, xpd = TRUE, horiz = TRUE, inset = c(0,-0.4), legend = c(&quot;Icke-Rökare&quot;, &quot;Rökare&quot;), fill = c(&quot;gray40&quot;, &quot;gray95&quot;), bty = &quot;n&quot;) Alternativt skapas ett stapeldiagram baserad på enbart rad 2 från tabellen, dvs andelen rökare i respektive kategori. Förmodligen är detta sista stapeldiagram det tydligaste om vi bara är intresserade av att jämföra andelarna i respektive utbildningsnivå. barplot( table_row_prop[2,], names.arg = c(&quot;Låg utbildning&quot;, &quot;Hög utbildning&quot;), ylab = &quot;Andel rökare&quot;) div.burly{ background-color:#EAF2F8; border-radius: 5px; padding: 20px;} Tips för ytterligare modifering av stapeldiagram Varför inte unyttja den funktionalitet som R erbjuder? Den sista figuren är korrekt, men det kan behövas ytterligare modifiering för att få figuren estestisk tilltalande. Nedan presenteras ett sådant exempel. Vad gör denna figuren bättre än tidigare figurer tycker du? Notera att utförligare information presenteras i kapitlet med figurer och om koden i exemplet är komplicerad så kan du avvakta. Det är dock ofta en bra princip att titta på kod och undersöka vad som händer när man modifierar koden. Visa kod # Enklast är att ta färdig kod och modifiera efter eget behov. Om du inte förstår färdig kod, testa att ändra i koden och se vad som händer! # Gör om andelar till procent percentages_rokare &lt;- round(100*table_row_prop[2,], 1) # Skapa objekt så vi kan hämta information från figurobjekt my_bar &lt;- barplot( percentages_rokare, names.arg = c(&quot;Låg utbildning&quot;, &quot;Hög utbildning&quot;), ylim=c(0,80), # Gränser för y-axel col = &quot;lightblue&quot;, # Stapelfärg border = &quot;white&quot;, # Kantlinjefärg på stapel ylab = &quot;Rökare (%)&quot;, # Namn på y-axel cex.axis = 1.1, # Textstorlek på axlar cex.lab = 1.1, # Textstorlek på namn cex.names=1.1) # Textstorlek på namn # Lägg till proocent ovanför staplarna med hjälp av funktionen **text()**. I denna funktion anges koordinater (x,y) för # var texten ska in, där x-koordinaten är staplarnas placering i objektet my_bar och ofta får man testa sig fram. Med # argumentet **labels** bestäms vad som ska stå över staplarna. Funktionen **paste** används för att sammanfoga numeriska # värden och text, i detta fall procenttecknet. text(x = my_bar, # x-koordinat för placering av text y = percentages_rokare + 6, # y-koordinat för placering av test labels = paste(percentages_rokare, &quot;%&quot;, sep=&quot;&quot;), # Text cex = 1.1) # Storlek på text 5.2.4 Inferens Notera att inferensdelen av detta kapitel inte hör till programmeringsblocket, utan det kommer diskuteras under ett senare block av kursen. Under programmeringsblockets gång kan du med gott samvete hoppa över denna del och börja läsa igen under rubriken Tre kategorier eller fler. Anta nu att målet är generalisera analyserna av stickprovet till en population, antingen med hjälp av konfidensintervall eller hypotesprövning. Vi börjar med att göra inferens för skillnaden i populationsandelar \\(p_1\\) och \\(p_0\\) i två populationer, \\(p_{diff}=p_1- p_0\\). Utgångspunkten här är två oberoende OSU. Givet att förutsättningarna för normalapproximation håller ges ett konfidensintervall av: \\[\\hat{p_1} - \\hat{p_0}\\pm z_{\\alpha/2}\\sqrt{\\dfrac{\\hat{p_1}(1-\\hat{p_1})}{n_1} + \\dfrac{\\hat{p_0}(1-\\hat{p_0})}{n_0}}\\] där \\(z_{\\alpha/2}\\) är värdet hämtat från standardiserade normalfördelningen. Konfidensintervallet för skillnaden in andelar i populationen kan beräknas med prop.test(). # Ta fram värden för beräkningar x0 &lt;- freq_table_utb_rokare[2,1] # Antal rökare (1or) bland lågutbildare x1 &lt;- freq_table_utb_rokare[2,2] # Antal rökare (1or) bland högutbildare n0 &lt;- sum(freq_table_utb_rokare[,1]) # Antal lågutbildare n1 &lt;- sum(freq_table_utb_rokare[,2]) # Antal högutbildare # Skapa konfidensintervall resultat &lt;- prop.test(c(x1, x0), c(n1, n0), correct = FALSE) # Skattning av skillnad i andelar phat_diff &lt;- resultat$estimate[1] - resultat$estimate[2] p_diff_KI_resultat &lt;- resultat$conf.int phat_diff prop 1 -0.2262405 p_diff_KI_resultat [1] -0.3398732 -0.1126079 attr(,&quot;conf.level&quot;) [1] 0.95 Vi kan även implementera formeln ovan och erhålla samma resultat. # Punktskattningar phat1 &lt;- x1/n1 phat0 &lt;- x0/n0 phatdiff &lt;- phat1 - phat0 # Skattningen av variansen för skattningen av skillnaden i andelar vhatphatdiff &lt;- phat1*(1-phat1)/n1 + phat0*(1-phat0)/n0 # Konfidensintervall alpha &lt;- 0.05 z_alpha &lt;- qnorm(1 - alpha/2) ll &lt;- phat_diff - z_alpha*sqrt(vhatphatdiff) ul &lt;- phat_diff + z_alpha*sqrt(vhatphatdiff) p_diff_KI &lt;- c(ll, ul) # Resultat phatdiff p_diff_KI # Kolla förutsättningarna! phat1*(1-phat1)*n1 phat0*(1-phat0)*n0 Tolkningen av resultaten kan skrivas på olika sätt. Nedan är två alternativ: Bland högutbildade röker 23 procentenheter mindre jämfört med lågutbildade. Med 95% säkerhet finns mellan 34 och 11 procenheter färre rökare bland högutbildade jämfört med lågutbildade. Skillnaden i andelen som röker bland högutbildade jämfört med lågutbildade är -0.23 (95% KI: -0.34; -11%). Litar vi på resultaten? Detta bygger på två förutsättningar, OSU (som vi vet från designen) samt att normalapproximationen (vilket vi undersöker i stickprovet) fungerar. Anta att syftet inte är att skatta skillnaden i andelen som röker, utan att frågan snarare är huruvida man röker i samma utsträckning oavsett utbildningsnivå. Då kan vi istället genomföra hypotesprövning och testa \\(H_0: p_1 = p_0\\) mot en två-sidig mothypotes, \\(H_0: p_1 \\neq p_0\\) andvänds test-funktionen \\[ z = \\dfrac{\\hat{p}_1 - \\hat{p}_0}{\\hat{p}_{pool}(1- \\hat{p}_{pool})\\left(\\dfrac{1}{n_1} + \\dfrac{1}{n_0}\\right)}\\] där \\[\\hat{p}_{pool} = \\dfrac{n_1\\hat{p}_1 + n_0 \\hat{p}_0}{n_1 + n_0}.\\] Testfunktionen är \\(N(0,1)\\) om nollhypotesen är sann om vi har OSU och om normalapproximation gäller (\\(n_1p_1(1-p_1) &gt; 5\\) och \\(n_0p_0(1-p_0) &gt; 5\\)). Ovanstående test kan göras med prop.test() och vi hämtar resultat från den redan tidigare genomförda analysen. # Z-test (som beror på X2-värdet när det är tvåsidig) z &lt;- sqrt(resultat$statistic) z X-squared 3.754285 resultat$p.value [1] 0.0001738371 Det andra alternativet är att implementera formeln ovan och beräkna \\(p\\)-värdet, vilket ger samma resultat. # Beräkningar baserade på tidigare kvantiteter pooled_phat &lt;- (n1*phat1 + n0*phat0)/(n1 + n0) zobs &lt;- (phat1 - phat0)/sqrt(pooled_phat*(1-pooled_phat)*(1/n1 + 1/n0)) p_value &lt;- 2*(1 - pnorm(abs(zobs))) p_value [1] 0.0001738371 Tolkningen är att givet att andelen rökare är lika stor i bägge utbildningskategorier i populationen så är det 0.0002 sannolikhet att hitta en så stor skillnad i andelar eller större som vi erhållit. Data stämmer alltså inte alls väl överens med nollhypotesen om ingen skillnad! Det går även att genomföra en ensidig hypotesprövning. Anta att vi vill testa \\(H_0: p_0 = p_1\\) vs \\(H_1: p_1 &lt; p_0\\), dvs om andelen rökare mindre bland högutbildade än bland lågutbildade. Vi måste nu prop.test() ange att mothypotesen är mindre än. För testet baserat på formeln ändras inte \\(z\\)-värdet, däremot hur \\(p\\)-värdet beräknas i pnorm(). # Version 1 resultat_less &lt;- prop.test(c(x1, x0), c(n1, n0), alternativ = &quot;less&quot;, correct = FALSE) resultat_less 2-sample test for equality of proportions without continuity correction data: c(x1, x0) out of c(n1, n0) X-squared = 14.095, df = 1, p-value = 8.692e-05 alternative hypothesis: less 95 percent confidence interval: -1.000000 -0.130877 sample estimates: prop 1 prop 2 0.3103448 0.5365854 # Version 2 pnorm(zobs) [1] 8.691855e-05 Vi får ett mycket lågt \\(p\\)-värde (\\(p&lt;0.001\\)) som säger oss att givet att andelen rökare är lika stor i bägge utbildningskategorier i populationen så är det 0.00008 sannolikhet att finna att högutbildade röker i så mycket mindre utsträckning eller ännu mindre jämfört med lågutbildade. Data stämmer alltså inte alls väl överens med nollhypotesen om ingen skillnad! Ett annat sätt att testa samband mellan binära variabler om vi har en två-sidigt mothypotes är att genomföra ett test för oberoende. En vanlig meted för att testa detta är \\(\\chi^2\\)-metoden, som testar hypoteserna: + \\(H_0\\): Det finns inget samband mellan variablerna (oberoende) + \\(H_1\\): Det finns ett samband mellan variablerna (beroende) Notera att mothypotesens riktning är ospecificerad! Utgå från en \\(2\\times2\\)-tabell med frekvenser från två korstabulerade binära variabler. I respektive cell finns således observerade frekvenser \\(O_{ij}\\). Kolumn 1 Kolumn 2 Rad 1 \\(O_{11}\\) \\(O_{12}\\) Radsumma 1 Rad 2 \\(O_{21}\\) \\(O_{22}\\) Radsumma 2 Kolumnsumma 1 Kolumnsumma 2 Totalsumma Ett oberoendetest för kan genomföras med teststatistikan \\[\\chi^2 = \\dfrac{(O_{11} - E_{11})^2}{E_{11}}+ \\dfrac{(O_{12} - E_{12})^2}{E_{12}}+\\dfrac{ (O_{21} - E_{21})^2}{E_{21}}+ \\dfrac{ (O_{22} - E_{22})^2}{E_{22}},\\] där \\(E_{ij} = \\dfrac{\\text{Radsumma i}\\cdot \\text{Kolumnsumma j}}{\\text{Totalsumma}}\\) är de förväntade frekvenserna givet att variablerna är oberoende. Teststatistikan är \\(\\chi^2\\)-fördelad med \\(1\\) frihetsgrad om \\(H_0\\) är sann och om antalet förväntade frekvenser i alla celler är större än 5. Det framräknade värdet i stickprovet, \\(\\chi^2_{obs}\\), jämförs sedan med denna fördelning. Detta test är alltid ensidigt och genom att se hur extremt värdet är i högra svansen erhålls \\(p\\)-värdet. För att implementera testet i R används chisq.test() på ett tabell-objekt med frekvenser. Det går också att tillämpa formeln ovan kan genomföra ett \\(\\chi^2\\)-test. Det framräknade \\(\\chi^2\\)-värdet används sedan i pchisq() för ett erhålla \\(p\\)-värdet. resultat_chisq &lt;- chisq.test(freq_table_utb_rokare, correct = FALSE ) resultat_chisq Pearson&#39;s Chi-squared test data: freq_table_utb_rokare X-squared = 14.095, df = 1, p-value = 0.0001738 Vi erhåller samma \\(p\\)-värde som när vi testade för skillnad av andelar i fallet med två-sidig mothypotes. \\(\\chi^2\\)-metoden kan alltså användas för att testa andelar, men testet är också ett mer generellt test för oberoende. Om två binära variabler är beroende, så är de beroende oavsett val av effektstorlek. Därför kan \\(\\chi^2\\)-metoden användas även för \\(p_{kvot}\\) och \\(OR\\). Oberoende testet testar alltså någon av hypoteserna: \\[H_0: p_{diff} = 0\\,\\,\\,\\text{vs}\\,\\,\\,H_1: p_{diff} \\neq 0\\] \\[H_0: p_{kvot} = 1\\,\\,\\,\\text{vs}\\,\\,\\,H_1: p_{kvot} \\neq 1\\] \\[H_0: p_{OR} = 1\\,\\,\\,\\text{vs}\\,\\,\\,H_1: p_{OR} \\neq 1\\] 5.3 Tre kategorier eller fler Detta avsnitt lämpar sig i regel för variabler med relativt få kategorier, låt säga färre än 10. För analys av variabler med många kategorier kan alternativa metoder för analys och presentation vara bättre. Notera ordvalet kan eftersom val av presentation och analys måste bedömas från fall till fall. 5.3.1 Kodning Från ett statistiskt perspektiv är en variabel med fler än två kategorier antingen på nominal eller ordinal skalnivå. Precis som fallet med binära variabler finns möjligheten att arbeta med faktorer, och det går i funktionen factor() att ange skalnivå med argumentet ordered. Det bör dock nämnas att det är vanligt att vid arbete med faktorer i R inte ta hänsyn till att variabeln är ordinalskala, utan om så görs beror på om analysen kräver det. Vi inleder med det enklaste fallet, en kategorivariabel på nominalskala. Nedan skapas en faktorvariabel av reklam, som anger uppfattning om reklam för spel, genom att med factor() definera variabeln som en faktor. Vi tillämpar sedan str() för att förvissa oss om att den är definierad som faktor. Vi ser att varaiabeln har 3 nivåer, dvs Factor w/ 3 levels och med funktionen levels() listas nivåerna som är \"Har ej tagit ställning\", \"Ja\", \"Nej\". # Skapa en faktorvariabel reklam för spel som är på nominalskala df$reklam_cat &lt;- factor(df$reklam) # Undersök variabeln egenskaper str(df$reklam_cat) &gt; Factor w/ 3 levels &quot;Har ej tagit ställning&quot;,..: 3 2 2 2 2 2 2 1 2 3 ... levels(df$reklam_cat) &gt; [1] &quot;Har ej tagit ställning&quot; &quot;Ja&quot; &quot;Nej&quot; Något att vara observant över är att en siffra korresponderar till varje faktornivå. Som användare måste man därför vara försiktig vid konvertering av numeriska variabler till faktorer och vice versa. Vi exemplifierar nedan med att skapa en faktorvariabel av den numeriska variabeln inkomst, för sedan göra om den till en numerisk variabel igen med as.numeric. Nedan presenteras data för de 6 första observationerna av inkomst och hur variabeln skiljer sig. # Jämförelse av inkomst, inkomst kodad som faktorvariabel samt # inkomst kodad som faktorvariabel konverterad till numerisk variabel igen cbind(head(df$inkomst), head(factor(df$inkomst)), head(as.numeric(factor(df$inkomst)))) &gt; [,1] [,2] [,3] &gt; [1,] 13941 52 52 &gt; [2,] 39664 254 254 &gt; [3,] 13168 44 44 &gt; [4,] 28809 181 181 &gt; [5,] 55952 279 279 &gt; [6,] 12495 39 39 # Funktionen head() ger de 6 första elementen. Vi önskar nu skapa en faktor av variabeln alder, som är på ordinal datanivå även om den anges som numerisk med kategorierna 0, 1, 2. Kodningen är dessutom lite kontraintuitiv, eftersom det 0 representerar den äldsta åldersgruppen och 2 den yngsta. När vi ska konvertera den numeriska variabeln alder till en faktorvariabel använder vi två speciella argument. Dels ordered för att ange att faktorn är på ordinal skalnivå, dels levels för att ange ordningen på faktornivåerna. För förtydliga ändrar vi sedan namn på nivåerna. Med str() ser vi nu att variabeln alder_cat är en faktor med tre nivåer, där nivåerna har en inbördes rangordning. # Gör variabel till faktor och ändra ordningen så är 2 är minst, sedan 1 och sedan 0 df$alder_cat &lt;- df$alder # Ordningen speciferas när en factor skapas df$alder_cat &lt;- factor(df$alder, levels = c(2,1,0), ordered = TRUE) # Ändra namn på nivåerna levels(df$alder_cat)[levels(df$alder_cat) == 0] &lt;- &quot;65-79 år&quot; levels(df$alder_cat)[levels(df$alder_cat) == 1] &lt;- &quot;50-64 år&quot; levels(df$alder_cat)[levels(df$alder_cat) == 2] &lt;- &quot;18-49 år&quot; # Undersök faktorn str(df$alder_cat) &gt; Ord.factor w/ 3 levels &quot;18-49 år&quot;&lt;&quot;50-64 år&quot;&lt;..: 2 3 2 1 1 2 1 2 2 2 ... levels(df$alder_cat) &gt; [1] &quot;18-49 år&quot; &quot;50-64 år&quot; &quot;65-79 år&quot; För somliga analyser är det praktiskt att arbeta med binära variabler som representerar kategorierna istället för att använda faktor-variabeln. Binära variabler som representerar kategorier kallas för dummy-variabler, och sådana används ofta i regressionsanalys. Det är därför, precis som tidigare för binära variabler, vanligt att ett datamaterial innehåller en och samma kategorivariabel kodad både som en faktor och som dummy-variabel. Notera att det med dummy-variabeler inte är möjligt att ta hänsyn till om variablers kategorier kan rangordnas. I koden nedan skapas tre nya dummy-variabler, en som representerar varje ålderskategori i alder. # Skapa binära variabler för respektive ålderskategori df$alder_1849 &lt;- NA df$alder_1849[df$alder == 0] &lt;- 0 df$alder_1849[df$alder == 1] &lt;- 0 df$alder_1849[df$alder == 2] &lt;- 1 df$alder_5064 &lt;- NA df$alder_5064[df$alder == 0] &lt;- 0 df$alder_5064[df$alder == 1] &lt;- 1 df$alder_5064[df$alder == 2] &lt;- 0 df$alder_6579 &lt;- NA df$alder_6579[df$alder == 0] &lt;- 1 df$alder_6579[df$alder == 1] &lt;- 0 df$alder_6579[df$alder == 2] &lt;- 0 5.3.2 Tabeller och figurer Det är när vi har flera kategorier som funktionerna table() och prop.table() framför allt kommer till sin rätt. Det går visserligen att arbeta med de enskilda dummy-variabler, men koden blir lätt omfattande och för omständlig för enbart deskriptiva syften. Nedand används table() för att analysera variabeln alder_cat, som vi vet har tre kategorier. Notera att både table() och prop.table() används på samma sätt nu som i avsnittet med bara två kategorier. # Skapar tabell med frekvenser freq_table_alder &lt;- table(df$alder_cat) freq_table_alder &gt; &gt; 18-49 år 50-64 år 65-79 år &gt; 66 150 64 # Skapa tabell med andelar prop_table_alder &lt;- prop.table(freq_table_alder) prop_table_alder &gt; &gt; 18-49 år 50-64 år 65-79 år &gt; 0.2357143 0.5357143 0.2285714 I regel är det önskvärt att snygga till tabellen genom att kombinera både frekvenser och andelar. table_alder &lt;- cbind(freq_table_alder, round(100*prop_table_alder, digits = 1)) colnames(table_alder) &lt;- c(&quot;Frekvens&quot;, &quot;Procent (%)&quot;) table_alder &gt; Frekvens Procent (%) &gt; 18-49 år 66 23.6 &gt; 50-64 år 150 53.6 &gt; 65-79 år 64 22.9 För kategorivariabler med fler kategorier än två blir relationen mellan tabeller och figurer och tydlig. Vi använder nämligen främst stapeldiagram för att redovisa frekvenser eller andelar för en kategorivariabel. Om vi har många kategorier kan dotchart() vara ett alternativ och om kategorierna är heltal används ofta stolpdiagram. Nedan presenteras två stapeldiagram, ett med frekvenser och ett med andelar. # Stapeldiagram baserat på tabellen med frekvenser barplot(freq_table_alder, ylab = &quot;Antal&quot;) # Stapeldiagram baserat på tabellen med andelar bar_alder &lt;- barplot(prop_table_alder, ylab = &quot;Andel&quot;) Figurerna ovan kan förbättras på motsvarande sätt som för de binära variablerna. barplot(freq_table_alder, ylab = &quot;Antal&quot;, col = &quot;lightblue&quot;, border = &quot;lightblue&quot;) # Anger färg till staplarnas kantlinje bar_alder &lt;- barplot(round(100 * prop_table_alder, digits = 1), ylab = &quot;Procent (%)&quot;, col = &quot;lightblue&quot;, border = &quot;lightblue&quot;, # Anger färg till staplarnas kantlinje ylim = c(0, 60)) # Justerar längden på y-axeln Vad man bör har i åtanke när man skapar stapeldiagram är huruvida staplarnas avstånd till varandra bör vara korrekt representerade i figuren. Består kategorierna av nominal eller ordinalskala är avståndet oviktigt och ofta har man då, per automatik, samma avstånd. Om variabeln däremot är diskret eller till exempel är årtal eller datum måste avståndet mellan staplarna överensstämma med kategoriernas avstånd. Detta görs automatiskt i stolpdiagram. Vi illustrerar nedan med variabeln mat som mäter antalet matinköp i veckan. När vi undersöker variabeln upptäcker vi att ingen har gjort 6 eller 7 inköp, däremot har 7 stycken svarat 8 gånger. Vi måste alltså skapa en figur som korrekt representerar avståndet mellan 5 och 8 gånger när frekvenserna för dessa antal redovisas. Notera att funktionen plot() används tillsammans med ett tabell-objekt för att skapa ett stolpdiagram. # Version 1 # Matematiskt korrekt figur, men ej estetiskt tilltalande freq_table_mat &lt;- table(df$mat) plot(freq_table_mat, # Tabell ylab = &quot;Antal&quot;, # Namn på y-axel bty =&quot;l&quot;, # Ta bort delar av box-kring figur xlab = &quot;Antal matinköp per vecka&quot;) # Namn på x-axel # Version 2 # Skapa faktornivåer från minsta till största värdet med min(df$mat):max(df$mat). # Kom ihåg vad semikolon har för funktion i R. min(df$mat):max(df$mat) skapar # en vektor med alla heltal mellan det minsta värdet och det största värdet i df$mat. df$mat_cat &lt;- factor(df$mat, levels = min(df$mat):max(df$mat)) # Skapa en frekvenstabell freq_table_mat &lt;- table(df$mat_cat) # Använder barplot för att skapa en semi-korrekt figur, men som är estetiskt tilltalande. Här finns extra kod barplot(freq_table_mat, border = &quot;white&quot;, # Ta bort linje som annars syns för kategori 6 och 7 col = &quot;lightblue&quot;, # Byt färg ylab = &quot;Antal&quot;, # Namn på y-axel xlab = &quot;Antal matinköp per vecka&quot;) # Namn på x-axel En vanlig typ av kategorivariabel är variabler med likertskala som är en skala vilken mäter olika attityder hos respondenten. Ofta är det önsvärt att för flera sådana variabler ge en samlad översikt i en och samma figur, precis som i figuren som visas här nedan. Vi ser att varje liggande stapel representerar en enskild variabel, men att variablerna alla mäts på en gemesam skala som används för att beskriva respondentens attityd till något specifikt fenomen. För att skapa figuren ovan krävs en del arbete, som lättast utförs steg för steg. Med hjälp av en tabell kan vi beskriva tre likertvariabler som finns i datasetet som mäter attityder till förbud av cigaretter, cannabis och alkohol. De tre variablerna finns i datamaterialet som lästes in i början av kapitlet. Variablerna är dock numeriska i datamaterialet, vi börjar därför med att skapa tre kategorivariabler, en för varje variabel. Vi ser att ser att variablerna mäts på en skala som kan rangordnas, och därför sätter vi ordered = TRUE och anger en rangordning genom argumentet levels. Vi byter även namn på faktorerna, så att de inte återges som nummer i figuren. Allt detta görs i kodsnutten nedan. # Skapa faktorer av de likertskalorna df$cigaretter_cat &lt;- factor(df$cigaretter, levels = c(1, 2, 3, 4, 5), ordered = TRUE) levels(df$cigaretter_cat) &lt;- c(&quot;Mycket positiv&quot;, &quot;Ganska positiv&quot;, &quot;Varken positiv eller negativ&quot;,&quot; Ganska negativ&quot;, &quot;Mycket negativ&quot;) df$cannabis_cat &lt;- factor(df$cannabis, levels =c(1, 2, 3, 4, 5), ordered = TRUE) levels(df$cannabis_cat ) &lt;- c(&quot;Mycket positiv&quot;, &quot;Ganska positiv&quot;, &quot;Varken positiv eller negativ&quot;,&quot; Ganska negativ&quot;, &quot;Mycket negativ&quot;) df$alkohol_cat &lt;- factor(df$alkohol, levels =c(1, 2, 3, 4, 5), ordered = TRUE) levels(df$alkohol_cat ) &lt;- c(&quot;Mycket positiv&quot;, &quot;Ganska positiv&quot;, &quot;Varken positiv eller negativ&quot;,&quot; Ganska negativ&quot;, &quot;Mycket negativ&quot;) Vi fortsätter genom att skapa tre enkla frekvenstabeller, en för varje kategorivariabel freq_table_cigaretter &lt;- table(df$cigaretter_cat) freq_table_cannabis &lt;- table(df$cannabis_cat) freq_table_alkohol &lt;- table(df$alkohol_cat) Om vi tittar närmare på en av tabellerna ser vi att den presenterar hur många respondenter som hör till varje kategori freq_table_cigaretter &gt; &gt; Mycket positiv Ganska positiv &gt; 45 62 &gt; Varken positiv eller negativ Ganska negativ &gt; 49 58 &gt; Mycket negativ &gt; 66 Vi vet sedan tidigare att varje kolumn i en tabell blir en egen stapel i ett stapeldiagram. Därför kan vi använda funktionen cbind() och binda samman de tre tabellerna ovan till ett nytt objekt, där varje tabell blir en egen kolumn freq_table_ban &lt;- cbind(freq_table_cigaretter, freq_table_cannabis, freq_table_alkohol) freq_table_ban &gt; freq_table_cigaretter freq_table_cannabis &gt; Mycket positiv 45 114 &gt; Ganska positiv 62 61 &gt; Varken positiv eller negativ 49 46 &gt; Ganska negativ 58 31 &gt; Mycket negativ 66 28 &gt; freq_table_alkohol &gt; Mycket positiv 14 &gt; Ganska positiv 13 &gt; Varken positiv eller negativ 18 &gt; Ganska negativ 50 &gt; Mycket negativ 185 För att få andelar beräknade använder vi prop.table() precis som tidigare, och kommer ihåg att sätta margin = 2 för att räkna ut andelar kolumnvis. prop_table_ban &lt;- prop.table(freq_table_ban, margin = 2) prop_table_ban &gt; freq_table_cigaretter freq_table_cannabis &gt; Mycket positiv 0.1607143 0.4071429 &gt; Ganska positiv 0.2214286 0.2178571 &gt; Varken positiv eller negativ 0.1750000 0.1642857 &gt; Ganska negativ 0.2071429 0.1107143 &gt; Mycket negativ 0.2357143 0.1000000 &gt; freq_table_alkohol &gt; Mycket positiv 0.05000000 &gt; Ganska positiv 0.04642857 &gt; Varken positiv eller negativ 0.06428571 &gt; Ganska negativ 0.17857143 &gt; Mycket negativ 0.66071429 För att räkna om till procentsatser multiplicerar vi andelstabellen med 100, och sedan snyggar vi till den med round() likert_tabell &lt;- round(100 * prop_table_ban, digits = 1) likert_tabell &gt; freq_table_cigaretter freq_table_cannabis &gt; Mycket positiv 16.1 40.7 &gt; Ganska positiv 22.1 21.8 &gt; Varken positiv eller negativ 17.5 16.4 &gt; Ganska negativ 20.7 11.1 &gt; Mycket negativ 23.6 10.0 &gt; freq_table_alkohol &gt; Mycket positiv 5.0 &gt; Ganska positiv 4.6 &gt; Varken positiv eller negativ 6.4 &gt; Ganska negativ 17.9 &gt; Mycket negativ 66.1 Nu kan vi skapa ett stapeldiagram för att illustrera tabellen ovan. Notare att diagrammet behöver justeras ganska mycket för att se ut som likertfigure ovan. Vi börjar med att vrida på diagrammet så att staplarna ligger ner med horiz = TRUE och att ge \\(x\\)-axeln ett nytt namn. Vi ger staplarna snyggare namn med names.arg, och sätter färger på staplarna med col. barplot(likert_tabell, horiz = TRUE, xlab = &quot;Procent (%)&quot;, names.arg = c(&quot;Cigaretter?&quot;, &quot;Cannabis?&quot;, &quot;Alkohol?&quot;), col = c(&quot;brown3&quot;, &quot;brown1&quot;, &quot;lightyellow&quot;, &quot;cadetblue2&quot;, &quot;cadetblue4&quot;)) Vi ser att ytterligare några saker behöver justeras. Dels behöver stapelnamnen vridas 90 grader för att bli horisontella (detta ändras genom att sätta argunemtet las = 1), dels behövs en legend till figuren (detta ordnar vi som vanligt med legend()). barplot(likert_tabell, horiz = TRUE, xlab = &quot;Procent (%)&quot;, names.arg = c(&quot;Cigaretter?&quot;, &quot;Cannabis?&quot;, &quot;Alkohol?&quot;), col = c(&quot;brown3&quot;, &quot;brown1&quot;, &quot;lightyellow&quot;, &quot;cadetblue2&quot;, &quot;cadetblue4&quot;), las = 1) legend(&quot;bottom&quot;, inset = c(0,-0.9), horiz = FALSE, xpd = TRUE, bty = &quot;n&quot;, legend = c(&quot;Mycket positiv&quot;, &quot;Ganska positiv&quot;, &quot;Varken positiv eller negativ&quot;, &quot;Ganska negativ&quot;, &quot;Mycket negativ&quot;), fill = c(&quot;brown3&quot;, &quot;brown1&quot;, &quot;lightyellow&quot;, &quot;cadetblue2&quot;, &quot;cadetblue4&quot;)) Vi ser att legenden inte syns just, trots att koden är korrekt. Detta kommer sig av att den inte får plats i figuren för tillfället. För att göra plats för legenden måste vi justera marginalerna för figuren (alltså trycka ihop den lite för att få plats med legenden under), detsamma gäller för stapelnamnen. Vi båste alltså fria upp mer plats till vänster om och under staplarna. För att ändra marginalerna använder vi funktionen par(), och anger marginalerna i en vektor genom argumentet mar. Standardinställningarna är par(mar = c(5.1, 4.1, 4.1, 2.1)). Det första värdet justerar den nedre marginalen, det andra värdet justerar vänstermarginalen, det tredje värdet justerar den övre marginalen, och det fjärde värdet justerar högermarginalen. För att göra mer plats under och till vänster om diagrammet gör vi marginalerna lite större. Det är viktigt att alltid återställa marginalerna efter att de ändrats. R gör inte detta automatiskt, utan kommer använda de marginaler som anges så länge de inte ändras igen. par(mar = c(15, 12, 4, 3)) barplot(likert_tabell, horiz = TRUE, xlab = &quot;Procent (%)&quot;, names.arg = c(&quot;Cigaretter?&quot;, &quot;Cannabis?&quot;, &quot;Alkohol?&quot;), col = c(&quot;brown3&quot;, &quot;brown1&quot;, &quot;lightyellow&quot;, &quot;cadetblue2&quot;, &quot;cadetblue4&quot;), las = 1) legend(&quot;bottom&quot;, inset = c(0,-0.9), horiz = FALSE, xpd = TRUE, bty = &quot;n&quot;, legend = c(&quot;Mycket positiv&quot;, &quot;Ganska positiv&quot;, &quot;Varken positiv eller negativ&quot;, &quot;Ganska negativ&quot;, &quot;Mycket negativ&quot;), fill = c(&quot;brown3&quot;, &quot;brown1&quot;, &quot;lightyellow&quot;, &quot;cadetblue2&quot;, &quot;cadetblue4&quot;)) par(mar = c(5.1, 4.1, 4.1, 2.1)) Vi kan nu finjustera genom att lägga till den vertikala linjen i mitten med funktionen abline() par(mar = c(15, 12, 4, 3)) barplot(likert_tabell, horiz = TRUE, xlab = &quot;Procent (%)&quot;, names.arg = c(&quot;Cigaretter?&quot;, &quot;Cannabis?&quot;, &quot;Alkohol?&quot;), col = c(&quot;brown3&quot;, &quot;brown1&quot;, &quot;lightyellow&quot;, &quot;cadetblue2&quot;, &quot;cadetblue4&quot;), las = 1) legend(&quot;bottom&quot;, inset = c(0,-0.9), horiz = FALSE, xpd = TRUE, bty = &quot;n&quot;, legend = c(&quot;Mycket positiv&quot;, &quot;Ganska positiv&quot;, &quot;Varken positiv eller negativ&quot;, &quot;Ganska negativ&quot;, &quot;Mycket negativ&quot;), fill = c(&quot;brown3&quot;, &quot;brown1&quot;, &quot;lightyellow&quot;, &quot;cadetblue2&quot;, &quot;cadetblue4&quot;)) abline(v = 50) par(mar = c(5.1, 4.1, 4.1, 2.1)) Den intresserade läsaren kanske även vill ange procentsatser tillhörande varje färg i diagrammet. För att göra så kan koden nedan användas. Notera att den extra koden som har med procentsatserna att göra är överkurs, och inte någon som studenter förväntas memorera och kunna till tentan. Studenter som gärna vill göra figurer med procentsatser i kan med gott samvete kopiera koden nedan och justera så att variablerna i tabellen stämmer. par(mar = c(15, 12, 4, 3)) mybar &lt;- barplot(likert_tabell, horiz = TRUE, xlab = &quot;Procent (%)&quot;, names.arg = c(&quot;Cigaretter?&quot;, &quot;Cannabis?&quot;, &quot;Alkohol?&quot;), col = c(&quot;brown3&quot;, &quot;brown1&quot;, &quot;lightyellow&quot;, &quot;cadetblue2&quot;, &quot;cadetblue4&quot;), las = 1) legend(&quot;bottom&quot;, inset = c(0,-0.9), horiz = FALSE, xpd = TRUE, bty = &quot;n&quot;, legend = c(&quot;Mycket positiv&quot;, &quot;Ganska positiv&quot;, &quot;Varken positiv eller negativ&quot;, &quot;Ganska negativ&quot;, &quot;Mycket negativ&quot;), fill = c(&quot;brown3&quot;, &quot;brown1&quot;, &quot;lightyellow&quot;, &quot;cadetblue2&quot;, &quot;cadetblue4&quot;)) abline(v = 50) # Skapa koordinater för att rita in procent i kategorierna # Likert 1 # x-koordinat ges av följande kod coord_x_1 &lt;- c(0, cumsum(likert_tabell[ , 1])) coord_x_1 &lt;- coord_x_1[-length(coord_x_1)] + diff(coord_x_1)/2 # y-koordinat ges av följande kod coord_y_1 &lt;- mybar[1] text(x = coord_x_1, y = coord_y_1, labels = paste(likert_tabell[ , 1], &quot;%&quot;, sep=&quot;&quot;), cex = 1.2) # Procentvärden hämtas från tabellen # Likert 2 coord_x_2 &lt;- c(0,cumsum(likert_tabell[ , 2])) coord_x_2 &lt;- coord_x_2[-length(coord_x_2)] + diff(coord_x_2)/2 coord_y_2 &lt;- mybar[2] text(x = coord_x_2, y = coord_y_2, labels = paste(likert_tabell[ , 2], &quot;%&quot;, sep=&quot;&quot;), cex = 1.2) # Likert 3 coord_x_3 &lt;- c(0,cumsum(likert_tabell[ , 3])) coord_x_3 &lt;- coord_x_3[-length(coord_x_3)] + diff(coord_x_3)/2 coord_y_3 &lt;- mybar[3] text(x = coord_x_3, y = coord_y_3, labels = paste(likert_tabell[ , 3], &quot;%&quot;, sep=&quot;&quot;), cex = 1.2) par(mar = c(5.1, 4.1, 4.1, 2.1)) 5.3.3 Inferens Notera att inferensdelen av detta kapitel inte hör till programmeringsblocket, utan det kommer diskuteras under ett senare block av kursen. Under programmeringsblockets gång kan du med gott samvete hoppa över denna del och börja läsa igen under rubriken Samband mellan kategorivariabler. Om vi har flera kategorier kan det vara av intressera att testa hypotetiskt fördelning av andelar i populationen. Då kan vi genomföra ett goodness of fit-test (GOF) som undersöker överstämmelsen mellan observerad data och denna hypotetiska population (som är vår fördelning). Anta att vi i ett OSU observerar en kategorivariabeln med \\(k\\) kategorier. Hypoteserna kan då formuleras utifrån andelar i respektive kategori, dvs + \\(H_0: p_1 = p_{1,H_0}, p_2 = p_{2,H_0}, \\ldots, p_k = p_{k,H_0}\\) + \\(H_1:\\) Minst en av andelarna inte överstämmer med värdet under nollhypotesen. Ett GOF-test kan genomföras med teststatistikan \\[\\chi^2 = \\sum_{i=1}^k\\dfrac{ (O_i - E_i)^2}{E_i}= \\dfrac{ (O_1 - E_1)^2}{E_1}+ \\dfrac{ (O_2 - E_2)^2}{E_2}+\\ldots+ \\dfrac{ (O_k - E_k)^2}{E_k}\\] där \\(O_i\\) är antalet observerade frekvenser i kategori \\(i\\) och \\(E_i\\) är antalet förväntade frekvenser, enligt nollhypotesen, i kategori \\(i\\). Teststatistikan är \\(\\chi^2\\)-fördelad med \\(k-1\\) frihetsgrader givet att nollhypotesen är sann och ett OSU. Dessutom krävs att alla förväntade frekvenser är större än 5 (analogt med normalapproximation). För att genomföra \\(\\chi^2\\)-metoden i R används funktionen chisq.test(), som vi tillämpar på en frekvenstabell. Exempel: Åldersfördelning Vi spekulerar i att det i populationen finns 65% i ålderskategorin 18-49 år, 20% i ålderskategorin 50-64 år och 15% ålderskategorin 65-79 år. Målet är att jämföra stickprovets åldersfördelning med populationen. Eftersom det finns flera kategorier formuleras hypoteserna som \\[H_0: p_1 = 0.3,p_2 = 0.45,p_3 = 0.25\\] mot \\[H_1: \\text{Minst en av andelarna inte överstämmer med värdet under nollhypotesen.}\\] # chitvå-test baserat på den tidigar frekvenstabellen resultat &lt;- chisq.test(freq_table_alder, # Frekvenstabell p = c(0.3, 0.45, 0.25), # Andelar under H0 correct = FALSE) # Ej kontuitetskorrektion # Frihetsgrader resultat$parameter &gt; df &gt; 2 # X2obs resultat$statistic &gt; X-squared &gt; 8.942857 # p-värde resultat$p.value &gt; [1] 0.01143097 Resultatet (\\(\\chi^2=8.94, fg=2\\)) ger ett lågt \\(p\\)-värde (\\(p=0.011\\)). Tolkningen är att om observerad data är slumpmässigt draget från befolkningen är det låg sannolikhet att observera en så stor skillnad eller större mellan de observerade värdena och de förväntade. Data stämmer således inte överens med nollhypotesen. Vad \\(p\\)-värdet inte besvarar är varför överstämmelsen är låg. Antigen är vår nollhypotes fel, dvs fördelningen i populationen faktiskt är en annan, eller så innebär ett lågt \\(p\\)-värde att urvalet inte är ett OSU. 5.4 Samband mellan kategorivariabler 5.4.1 Tabeller och figurer För att beskriva ett samband mellan två kategorivariabler används korstabeller på motsvarande sätt som för binära variabler. Det innebär att vi måste reflektera över om det är frekvenser eller andelar som är det relevanta att redovisa. Dessutom måste vi i funktionen prop.table() ange om andelarna ska beräknas radvis, kolumnvis eller baserat på totalen. Vi illustrerar med att undersöka om det finns ett samband mellan ålder och uppfattningen om TV-reklam för spel bör vara tillåtet eller inte. # Skapa en korstabell med frekvenser för ålder och reklam. # Vi antar i detta fall att ålder är oberoende variabler och reklam beroende och placerar därför # ålder kolumnvis och reklam radvis freq_table_reklam_alder &lt;- table(df$reklam, df$alder_cat) # Beräkna kolumnprocent för prop_table_reklam_alder &lt;- prop.table(freq_table_reklam_alder, margin = 2) prop_table_reklam_alder &gt; &gt; 18-49 år 50-64 år 65-79 år &gt; Har ej tagit ställning 0.4242424 0.2933333 0.4218750 &gt; Ja 0.3484848 0.3000000 0.3750000 &gt; Nej 0.2272727 0.4066667 0.2031250 Resulatet visar att i stickprovet är den negativa uppfattningen om TV-reklam och spel störst i åldergruppen 50-64 år, där 41% menar att TV-reklam för spel ej bör vara tillåtet. I åldersgrupperna 18-49 år och 65-79 år har 42% inte tagit ställning. Nu ska vi se om vi kan kombinera frekvenser och procent i samma figur. # Skapa en tabell med procent procent_table_reklam_alder &lt;- round(100*prop_table_reklam_alder,1) # Kombinera frekvenser och procent genom att ta varannan kolumn och kombinera dem table_reklam_alder &lt;- cbind(freq_table_reklam_alder[,1], paste(procent_table_reklam_alder[,1], &quot;%&quot;, sep=&quot;&quot;), freq_table_reklam_alder[,2], paste(procent_table_reklam_alder[,2], &quot;%&quot;, sep=&quot;&quot;), freq_table_reklam_alder[,3], paste(procent_table_reklam_alder[,3], &quot;%&quot;, sep=&quot;&quot;)) colnames(table_reklam_alder) &lt;- c(levels(df$alder_cat)[1], &quot;&quot;, levels(df$alder_cat)[2], &quot;&quot;, levels(df$alder_cat)[3], &quot;&quot;) table_reklam_alder &gt; 18-49 år 50-64 år 65-79 år &gt; Har ej tagit ställning &quot;28&quot; &quot;42.4%&quot; &quot;44&quot; &quot;29.3%&quot; &quot;27&quot; &quot;42.2%&quot; &gt; Ja &quot;23&quot; &quot;34.8%&quot; &quot;45&quot; &quot;30%&quot; &quot;24&quot; &quot;37.5%&quot; &gt; Nej &quot;15&quot; &quot;22.7%&quot; &quot;61&quot; &quot;40.7%&quot; &quot;13&quot; &quot;20.3%&quot; För att redovisa samband mellan kategorivariabler används i regel stapeldiagram. Nedan redovisas sambandet mellan ålder och reklam med de olika alternativ som finns för stapeldiagram, dvs frekvenser eller andelar samt om stapeldiagrammen ska vara uppdelade eller ej. Av alternativen är D förmodligen att föredra om detta samband ska utvärderas, men notera att detta alternativ inte ger någon information om uppfattningen om antalet i grupperna. Då hade B fungerat bättre. Du kan hitta koden som använts för att skapa diagrammen i fliken under figuren. barplot() används genomgående, med olika specifikationer för olika argument. Som en övningsuppgift kan du försöka gå igenom koden i fliken och kommentera vad varje rad gör, för att få bättre koll på de olika argumenten. Visa kod för figur # Figur A barplot(freq_table_reklam_alder, ylab = &quot;Antal&quot;, main = &quot;A&quot;, col = c(&quot;lightblue&quot;,&quot;coral2&quot;,&quot;lightyellow&quot;)) legend(&quot;bottom&quot;, xpd = TRUE, horiz = TRUE, inset = c(0,-0.4), legend=c(row.names(freq_table_reklam_alder)), fill = c(&quot;lightblue&quot;,&quot;coral2&quot;,&quot;lightyellow&quot;), bty = &quot;n&quot;) # Figur B barplot(freq_table_reklam_alder, beside = TRUE, ylab = &quot;Antal&quot;, main = &quot;B&quot;, col = c(&quot;lightblue&quot;,&quot;coral2&quot;,&quot;lightyellow&quot;)) legend(&quot;bottom&quot;, xpd = TRUE, horiz = TRUE, inset = c(0,-0.4), legend=c(row.names(freq_table_reklam_alder)), fill = c(&quot;lightblue&quot;,&quot;coral2&quot;,&quot;lightyellow&quot;), bty = &quot;n&quot;) # Figur C barplot(prop_table_reklam_alder, ylab = &quot;Andel&quot;, main = &quot;C&quot;, col = c(&quot;lightblue&quot;,&quot;coral2&quot;,&quot;lightyellow&quot;)) legend(&quot;bottom&quot;, xpd = TRUE, horiz = TRUE, inset = c(0,-0.4), legend=c(row.names(freq_table_reklam_alder)), fill = c(&quot;lightblue&quot;,&quot;coral2&quot;,&quot;lightyellow&quot;), bty = &quot;n&quot;) # Figur D barplot(prop_table_reklam_alder, beside = TRUE, ylab = &quot;Andel&quot;, main = &quot;D&quot;, col = c(&quot;lightblue&quot;,&quot;coral2&quot;,&quot;lightyellow&quot;)) legend(&quot;bottom&quot;, xpd = TRUE, horiz = TRUE, inset = c(0,-0.4), legend=c(row.names(freq_table_reklam_alder)), fill = c(&quot;lightblue&quot;,&quot;coral2&quot;,&quot;lightyellow&quot;), bty = &quot;n&quot;) 5.4.2 Inferens Notera att inferensdelen av detta kapitel inte hör till programmeringsblocket, utan det kommer diskuteras under ett senare block av kursen. Under programmeringsblockets gång kan du med gott samvete hoppa över denna del och gå direkt till övningsuppgifterna. Det finns ett antal metoder för att analysera samband mellan kategorivariabler. Utgångspunkten i detta kapitel är man genom att korstabulera variablerna erhåller en korstabell som innehåller frekvenser för kombinationerna av variablernas kategorier. I respektive cell finns således observerade frekvenser \\(O_{ij}\\) i cellen på rad \\(i\\) och kolumn \\(j\\). Tabellen nedan illustrerar. Kolumn 1 Kolumn 2 Kolumn k Rad 1 \\(O_{11}\\) \\(O_{12}\\) \\(\\cdots\\) \\(O_{1k}\\) Radsumma 1 Rad 2 \\(O_{21}\\) \\(O_{22}\\) \\(\\cdots\\) \\(O_{2k}\\) Radsumma 2 \\(\\vdots\\) \\(\\vdots\\) \\(\\vdots\\) \\(\\ddots\\) \\(\\vdots\\) \\(\\vdots\\) Rad r \\(O_{r1}\\) \\(O_{r2}\\) \\(O_{rk}\\) Radsumma r Kolumnsumma 1 Kolumnsumma 2 \\(\\cdots\\) Kolumnsumma k Totalsumma Tabellen kan användas för att genomföra ett oberoendetest där nollhypotesen är \\(H_0: \\text{Variablerna är oberoende}\\) vs \\(H_1: \\text{Variablerna är beroende}\\). Notera att testet inte har någon riktning. Ett oberoendetest kan genomföras med teststatistikan \\[\\chi^2 = \\sum_{i=1}^r\\sum_{j=1}^k \\dfrac{(O_{ij} - E_{ij})^2}{E_{ij}} = \\dfrac{(O_{11} - E_{11})^2}{E_{11}}+ \\dfrac{(O_{12} - E_{12})^2}{E_{12}}+\\ldots+ \\dfrac{ (O_{rk} - E_{rk})^2}{E_{rk}},\\] där \\(E_{ij} = \\dfrac{\\text{Radsumma i}\\cdot \\text{Kolumnsumma j}}{\\text{Totalsumma}}\\) är de förväntade frekvenserna givet att variablerna är oberoende. Teststatistikan är \\(\\chi^2\\)-fördelad med \\((r-1)(k-1)\\) frihetsgrader om \\(H_0\\) är sann och om antalet förväntade frekvenser i alla celler är större än 5. Det framräknade värdet i stickprovet, \\(\\chi^2_{obs}\\), jämförs sedan med denna fördelning. Genom att se hur extremt värdet är i högra svansen erhålls \\(p\\)-värdet. Notera att denna typ av sambandsanalys inte tar någon hänsyn till om variablerna går att rangordna. Alltså använder vi eventuellt inte all tillgänglig information. För variabler på ordinalskala finns alternativa metoder som därför eventuellt har högre styrka, exempelvis Spearmans rangkorrelation. Detta faktum innebär dock inte att \\(\\chi^2\\)-metoden inte kan användas. Vi illustrerar testet genom att studera sambandet mellan ålder och uppfattningen om TV-reklam för spel bör vara tillåtet eller inte. Baserat på en OSU bestående av \\(n=280\\) testar vi nu om dessa variabler är oberoende. # Vi använder freq_table_reklam_alder från tidigare uppgift test_reklam_alder &lt;- chisq.test(freq_table_reklam_alder, correct = FALSE) test_reklam_alder &gt; &gt; Pearson&#39;s Chi-squared test &gt; &gt; data: freq_table_reklam_alder &gt; X-squared = 12.265, df = 4, p-value = 0.01549 Det låga \\(p\\)-värdet \\(p=0.015\\) säger att om variablerna är oberoende så är det låg sannolikhet att hitta så stora avvikelser som gör eller större. Data stämmer inte överens med nollhypotesen om inget beroende och vi lutar åt att faktiskt variablerna faktiskt är beroende. En manuell version av testet ger exakt samma resultat. # Chitvå-test manuellt Oij &lt;- freq_table_reklam_alder Ri &lt;- rowSums(Oij) Ki &lt;- colSums(Oij) Totalsumma &lt;- sum(Oij) # Skapa en matrix med förväntade frekvenser Eij &lt;- matrix(NA, dim(Oij)[1], dim(Oij)[2]) Eij[1,1] &lt;- Ri[1]*Ki[1]/Totalsumma Eij[1,2] &lt;- Ri[1]*Ki[2]/Totalsumma Eij[1,3] &lt;- Ri[1]*Ki[3]/Totalsumma Eij[2,1] &lt;- Ri[2]*Ki[1]/Totalsumma Eij[2,2] &lt;- Ri[2]*Ki[2]/Totalsumma Eij[2,3] &lt;- Ri[2]*Ki[3]/Totalsumma Eij[3,1] &lt;- Ri[3]*Ki[1]/Totalsumma Eij[3,2] &lt;- Ri[3]*Ki[2]/Totalsumma Eij[3,3] &lt;- Ri[3]*Ki[3]/Totalsumma # Beräkna observerat chitvå-värde och p-värde X2obs &lt;- sum((Oij - Eij)^2/Eij) fg &lt;- (dim(Oij)[1] -1)*(dim(Oij)[2] -1) p_value &lt;- 1 - pchisq(X2obs, fg) 5.5 Programmeringsuppgifter 5.5.1 Uppgift 1 Antag att 150 studenter blivit frågade om de hellre dricker kaffe eller te i en föreläsningspaus. Studenternas svar finns samlande i vektorn kaffe i fliken nedan, i vektorn motsvarar 1 en student som svarat att hen föredrar kaffe, och 2 en student som tycker bättre om te. Visa datamaterial kaffe &lt;- c(2,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,1,2,2,1,1,1,2,1,2,2,1,1,1,2,1,1,1,2,2,2,2,1,2,1,1,2,1,1,1,2,1,2,1,1,1,1,1,2,1,2,1,1,1,2,1,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,1,2,1,2,1,1,1,1,1,2,1,1,1,1,2,2,2,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,1,2,1,1,1,1,2,2,1,1,1,2,1,2,1,1,2,2,2,1,1,2) Börja med att kopiera koden i fliken, och att klistra in och köra den i ett script i RStudio. Vilken klass får vektorn när den läses in av R? Visa svar Vektorn läses enkelt in genom att kopiera koden i fliken och köra den i RStudio. För att ta reda på vilken klass vektorn får används class(kaffe) [1] &quot;numeric&quot; kaffe läses alltså automatiskt in som en numerisk vektor, och R kommer därför tolka dess element som siffror. Skapa en frekvenstabell över kaffe, och spara den i ett objekt med lämpligt namn. Är det vanligast att dricka kaffe eller te i föreläsningspauser? Visa svar Tabellen skapas enkelt med hjälp av table() tab_kaffe &lt;- table(kaffe) # Sparar tabell i objektet tab_kaffe tab_kaffe # Skriver ut tabellen i konsollen för kontroll kaffe 1 2 109 41 Som synes är det fler som föredrar kaffe över te (svaret 1 förekommer fler gånger än svaret 2) Skapa ett stapeldiagram som illustrerar frekvenstabellen i b. Se till att ge diagrammets axlar informativa namn. Visa svar barplot(tab_kaffe, # Tabellen som används xlab = &quot;Kaffe eller te?&quot;, # Text till x-axeln ylab = &quot;Frekvens&quot;) # Text till y-axeln Som synes blir varken tabellen i b. eller diagrammet i c. riktigt intuitiva, utan R använder genomgående de numeriska kodningarna 1 och 2 istället för t.ex. Kaffe respektive Te. Detta kan åtgärdas på två sätt, antingen genom att skapa en ny kaffevariabel med kategorisk kodning, eller med hjälp av en faktorvariabel. De följande uppgifterna tittar närmare på båda dessa alternativ, och börjar med det första. Skapa en ny vektor som heter kaffe_kat. Vektorn ska spegla kaffe från tidigare, men ska istället för 1 och 2 ha Kaffe respektive Te som element. Visa svar Denna uppgift kan egentligen lösas på väldigt många olika sätt, och det spelar egentligen ingen roll hur lösningen programmeras så länge svaret blir rätt (och koden känns intuitiv för just dig). Ett möjligt sätt att lösa uppgiften är kaffe_kat &lt;- kaffe # Kopierar kaffe till kaffe_kat kaffe_kat[kaffe_kat == 1] &lt;- &quot;Kaffe&quot; # Kodar om ettor till &quot;Kaffe&quot; kaffe_kat[kaffe_kat == 2] &lt;- &quot;Te&quot; # Kodar om tvåor till &quot;Te&quot; Skriv gärna ut de två vektorerna bredvid varandra med koden cbind(kaffe, kaffe_kat) och kontrollera att omkodningen har gått rätt till Använd nu kaffe_kat för att skapa en tabell och ett stapeldiagram som i deluppgiterna b. och c. Hur skiljer de sig åt? Visa svar Frekvenstabell: Frekvenstabellen skapas precis som tidigare med hjälp av table(). Kom ihåg att ge ett nytt namn, så att den gamla tabellen inte skrivs över tab_kaffe_kat &lt;- table(kaffe_kat) # SKapar och sparar tabell tab_kaffe_kat # Skriver ut tabell i konsollen kaffe_kat Kaffe Te 109 41 I denna tabell står Kaffe och Te som kolumnnamn, istället för bara 1 och 2 i tab_kaffe Stapeldiagram: Stapeldiagrammet skapas som barplot(tab_kaffe_kat, # Tabellen som används xlab = &quot;Kaffe eller te?&quot;, # Text till x-axeln ylab = &quot;Frekvens&quot;) # Text till y-axeln Nu är diagrammet lättare att läsa av, eftersom staplarna har namn som enkelt kan tolkas. Det andra alternativet är att skapa en ny faktorvariabel, och använda den för att skapa tabeller och diagram. Skapa faktorivariabeln kaffe_fak, som bygger på kaffe, och koda nivåernas namn till Kaffe och Te. Visa svar För att skapa faktorvariabler används factor() kaffe_fak &lt;- factor(kaffe) # Skapar faktorvariabel För att se faktorvariabelns nivåer används `levels()`` levels(kaffe_fak) # Variabelns nivåer [1] &quot;1&quot; &quot;2&quot; Som synes är nivåerna 1 och 2, vilket motsvarar de värdena som finns i kaffe. Nivåernas namn kan enkelt bytas som levels(kaffe_fak) &lt;- c(&quot;Kaffe&quot;, &quot;Te&quot;) # Byter namn på nivåer levels(kaffe_fak) # Skriver ut nivåer för att kontrollera [1] &quot;Kaffe&quot; &quot;Te&quot; Notera att dett föra elementet i vektorn med nya namn automatiskt kommer ges till den första nivån. Det är viktigt att se till så att de nya namnen anges i rätt ordning, annars blir resultaten naturligtvis helt fel. Använd nu kaffe_fak för att skapa samma frekvenstabell och stapeldiagram som tidigare (sorry för så många deluppgifter). Visa svar Frekvenstabell Tabellen skapas som vanligt med table() tab_kaffe_fak &lt;- table(kaffe_fak) # Skapar tabell tab_kaffe_fak # Skriver ut tabell i konsollen kaffe_fak Kaffe Te 109 41 Stapeldiagram: Stapeldiagrammet skapas som barplot(tab_kaffe_fak, # Tabellen som används xlab = &quot;Kaffe eller te?&quot;, # Text till x-axeln ylab = &quot;Frekvens&quot;) # Text till y-axeln Genom att använda faktorvariabler kan resultaten alltså snyggas till och ge samma resultat. Det är såklart fritt fram att välja den approach som känns lättast, men det är viktigt att behärska båda sätten att programmera. Faktorvariabler är ofta väldigt smidiga och funktionella, inte minst i regressionsanalyser. 5.5.2 Uppgift 2 Utgå ifrån datamaterialet i förra uppgiften, och antag att det tillkommit information gällande huruvida studenterna har mjölk i sin varma dryck. Kod som skapar en ny vektor, mjolk finns att kopiera i fliken nedan. Gör så, och klistra in och kör koden i RStudio. I mjolk tolkas en etta som att person i fråga vill ha mjölk i sin dryck, och en nolla som att personen helst dricker kaffe/te utan mjölk. Visa datamaterial mjolk &lt;- c(0,0,1,1,1,0,0,0,1,1,0,0,1,1,1,0,1,0,1,0,0,0,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,0,0,1,0,0,0,1,1,1,1,0,1,0,0,1,0,1,1,0,1,1,0,0,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0,1,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0,1,1,0,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,1,0,1,1,0,0,1,0,1,1,1,0,0,0,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,1,1,0,1,1,1,1,1,0) Skapa en data frame, df_kaffe, som innehåller kaffe och kaffe_fak från förra uppgiften, och vektorn mjolk från denna uppgift. Visa svar df_kaffe &lt;- data.frame(kaffe, kaffe_fak, mjolk) # Slapar data frame df_kaffe[1:10, ] # Skriver ut de tio första raderna kaffe kaffe_fak mjolk 1 2 Te 0 2 1 Kaffe 0 3 1 Kaffe 1 4 1 Kaffe 1 5 1 Kaffe 1 6 1 Kaffe 0 7 1 Kaffe 0 8 1 Kaffe 0 9 1 Kaffe 1 10 2 Te 1 Genom att använda View(df_kaffe) eller skriva ut de första raderna i konsollen går det att kontrollera att koden gav en bra data frame. Lägg till en ny variabel i df_kaffe, och döp den till mjolk_fak. mjolk_fak ska vara en faktorvariabel med två nivåer: nivån Med för dem som dricker med mjölk, och nivån Utan för dem som dricker utan mjölk. Visa svar Börja med att skapa en ny kolumn i df_kaffe, och låt den var fylld med NA df_kaffe$mjolk_fak &lt;- NA # Skapar ny variabel Fyll ny den nya kolumnen med en faktorvariabel baserad på mjolk df_kaffe$mjolk_fak &lt;- factor(mjolk) # Fyller på med faktorvariabel Kontrollera sedan vilka nivåer som finns, och ge dem lämpliga namn levels(df_kaffe$mjolk_fak) # Tar fram nivåer nivåer [1] &quot;0&quot; &quot;1&quot; levels(df_kaffe$mjolk_fak) &lt;- c(&quot;Utan&quot;, &quot;Med&quot;) # Byter namn på nivåer levels(df_kaffe$mjolk_fak) # Kontrollerar nya namn [1] &quot;Utan&quot; &quot;Med&quot; Notera: det går att ange nya namn till nivåerna direkt i factor(), detta med hjälp av argumentet levels. Detta kortar ner koden en del, men förutsätter att man redan innan vet vilken ordning nivåerna kommer hamna i. Eftersom mjolk_kat skapas med hjälp av mjolk, som är en numerisk variabel, kommer nivåerna automatiskt ordnas efter den numeriska ordningen i i mjolk. Alltså kommer nivån 0 hamna först, och nivån 1 på andra plats (detta går att se i utskriften ovan). Det går då att skapa faktorvariabeln som df_kaffe$mjolk_fak &lt;- factor(mjolk, levels = c(&quot;Utan&quot;, &quot;Med&quot;)) Testa gärna detta för att se att koden ger samma resultat. Det går naturligtvis att använda vilket som av sätten som har presenterats här. Skapa en korstabell som visar mjolk_fak radvis (på \\(y\\)-axeln), och kaffe_fak kolumnvis (längs med \\(x\\)-axeln). Spara tabellen i ett lämpligt döpt objekt. Visa svar Korstabeller skapas, precis som frekvenstabeller, med funktionen table(). Notera att radvariabeln anges först, och kolumnvariabeln efter det. tab_kaffe_mjolk &lt;- table(df_kaffe$mjolk_fak, df_kaffe$kaffe_fak) # Skapar tabell tab_kaffe_mjolk # Skriver ut tabell i konsollen Kaffe Te Utan 56 24 Med 53 17 Använd tabellen från c. för att skapa en ny korstabell som visar andelar istället för frekvenserna. Se till så att andelerana för varje kolumn summerar till 1. Visa svar Korstabeller som visar andelar skapas med prop.table(). Som argument i prop.table() används ett objekt av klassen table. Det går alltså att använde tab_kaffe_mjolk direkt i prop.table(). För att andelarna ska summera till 1 kolumnvis sätts argumentet margin lika med två. p_tab_kaffe_mjolk &lt;- prop.table(tab_kaffe_mjolk, # Väljer korstabell margin = 2) # Andelar kolumnvis p_tab_kaffe_mjolk # Kontrollerar tabellen Kaffe Te Utan 0.5137615 0.5853659 Med 0.4862385 0.4146341 Illustrera informationen i p_tab_kaffe_mjolk med hjälp av ett stapeldiagram. Var noga med att skapa en nyckel som gör diagramet lätt att läsa. Visa svar Stapeldiagrammet skapas som vanligt med barplot(), och nyckeln till figure skapas med legend(). barplot(p_tab_kaffe_mjolk, xlab = &quot;Dryckespreferens&quot;, ylab = &quot;Andel (0-1)&quot;, # Axelnamn col = c(&quot;gray25&quot;, &quot;gray90&quot;)) # färger på stapelfält legend(&quot;top&quot;, # Vill ha nyckeln längst upp horiz = TRUE, # Horisontell nyckel xpd = TRUE, # Låter nyckeln visas utanför diagrammet inset = c(0, -0.15), # Justerar nyckelns position bty = &quot;n&quot;, # Tar bort kanlinje runt nyckel legend = c(&quot;Utan mjölk&quot;, &quot;Med mjölk&quot;), fill = c(&quot;gray25&quot;, &quot;gray90&quot;)) Kontrollera gärna att diagrammet stämmer överens med tabellen i föregående uppgift, och titta extra noga så att färgerna i staplarna och i nyckeln verkligen visar det de påstår sig göra. 5.5.3 Uppgift 3 I fliken nedan finns en data frame som innehåller data ur den den svenska delen av den sjätte vågen av World Values Survey. I datamaterialet finns kolumnerna children: Anger hur många barn respondenten hade vid frågetillfälle fight: Anger huruvida respondenten är beredd att försvara Sverige i händelse av krig (svaret Ja kodas som 1, och svaret Nej som 2) Börja med att kopiera koden som finns i fliken, och klistra in och kör den i ett script i RStudio. Visa datamaterial wvs &lt;- data.frame( children = c(0,2,1,7,2,1,1,3,0,3,0,3,2,0,0,2,2,2,0,0,3,3,3,1,1,3,2,2,3,0,2,2,0,4,1,4,2,3,3,2,1,2,0,0,2,2,2,3,0,2,2,0,1,2,0,0,0,2,0,1,2,2,1,0,3,1,0,3,3,0,2,2,2,2,2,2,3,1,2,3,0,1,2,2,2,2,0,1,1,1,1,0,1,2,0,1,2,0,1,0,0,1,0,1,2,1,0,1,2,3,0,3,1,2,2,1,0,0,1,4,2,2,1,3,2,2,2,3,0,2,3,2,3,3,1,2,2,1,0,1,0,2,0,0,2,4,1,3,0,2,2,4,2,3,0,1,0,2,2,0,2,1,2,2,4,2,2,0,3,5,2,0,0,2,0,2,3,2,2,1,0,2,2,0,2,2,2,0,2,3,2,3,1,0,3,2,2,0,0,2,2,0,2,0,3,1,1,0,2,2,2,0,0,0,3,0,3,1,2,0,2,0,2,2,2,2,0,1,0,3,5,5,2,4,2,1,2,3,2,2,0,2,3,0,2,4,3,3,1,1,3,3,0,0,1,2,0,4,3,0,2,1,0,2,2,3,3,0,3,3,2,2,0,0,3,0,3,2,1,0,4,4,3,3,1,3,3,0,0,2,2,2,4,2,2,2,3,3,0,2,2,0,2,3,2,0,3,5,2,2,2,0,2,6,3,1,2,1,2,2,4,1,2,5,3,0,3,4,0,0,1,0,2,2,2,0,3,3,2,2,0,2,2,4,1,1,1,0,2,2,0,0,0,4,1,0,2,2,1,4,1,0,3,2,3,1,0,4,0,2,1,0,1,2,2,2,0,2,3,1,2,1,2,0,3,4,3,0,2,3,1,2,1,2,3,6,3,1,2,0,2,2,1,7,2,0,2,2,4,3,3,3,3,2,3,3,2,3,0,2,1,1,0,1,2,2,2,1,0,1,2,1,2,1,2,2,0,2,4,2,2,0,1,2,1,2,3,2,4,2,1,1,0,0,3,3,2,2,1,2,2,3,1,1,2,0,3,0,0,3,0,0,3,2,0,2,1,2,2,4,0,2,2,2,2,2,0,2,4,4,2,3,2,0,0,2,0,1,3,2,2,0,0,3,0,2,0,0,1,0,3,1,1,2,0,0,0,2,0,1,3,1,0,2,2,2,2,2,1,1,2,0,3,2,2,2,0,1,2,1,2,2,1,0,1,2,0,2,0,0,2,1,3,2,3,2,2,4,2,3,0,2,2,3,1,1,0,2,2,3,3,1,0,1,0,2,0,2,0,2,2,3,2,3,1,1,2,0,2,0,2,3,0,0,0,3,1,4,4,0,4,3,2,2,2,0,2,0,2,0,0,0,2,2,2,3,1,0,2,0,2,3,2,2,0,2,1,1,0,0,0,2,4,0,2,1,3,2,0,3,0,2,1,4,0,0,2,1,1,3,4,2,3,2,0,2,0,0,2,0,2,2,0,0,1,3,1,0,1,2,0,3,0,2,1,2,1,2,2,3,0,4,0,2,0,2,0,3,1,2,1,2,2,1,0,1,0,0,0,2,1,0,0,1,0,0,1,0,0,0,0,2,0,2,3,2,2,4,0,2,0,0,0,0,2,0,2,0,1,2,0,4,1,1,0,0,0,0,2,0,3,0,1,0,2,0,2,0,0,2,2,0,3,1,4,2,2,0,0,0,0,0,3,2,1,2,3,3,0,0,0,2,1,2,0,-2,3,3,2,0,1,1,2,1,2,2,1,2,4,3,1,0,0,1,2,3,1,3,0,0,0,4,0,0,3,2,2,2,2,0,0,1,1,2,1,3,1,1,1,0,1,0,2,0,2,0,2,0,2,3,0,3,1,0,2,8,0,4,2,0,2,3,2,0,2,0,0,2,0,0,0,2,3,3,0,4,2,0,0,2,0,0,3,2,0,3,0,1,2,2,3,1,0,3,2,4,2,1,1,2,0,0,0,0,0,2,2,2,0,2,2,2,4,4,2,3,2,2,2,0,2,0,2,0,0,2,0,0,2,2,0,5,1,0,1,0,0,2,0,0,2,1,0,1,1,0,1,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,2,2,3,0,2,0,0,2,0,0,2,0,0,0,2,0,0,0,2,0,0,2,0,4,1,1,3,3,0,0,2,0,0,0,4,3,1,2,0,2,3,3,3,2,2,1,0,0,0,2,2,0 ,0,0,0,0,2,0,2,0,0,2,0,2,1,0,1,0,2,2,0,0,5,0,0,1,3,0,0,0,0,2,0,2,0,0,0,2,1,1,0,4,0,2,0,2,3,0,1,2,0,0,2,0,0,0,3,2,0,0,0,0,0,0,1,0,0,0,2,1,0,2,0,1,0,2,0,2,0,0,0,0,0,3,1,5,1,3,0,0,0,0,0,0,2,0,0,2,2,0,0,3,0,0,1,0,0,0,3,3,1,4,1,0,0,4,0,0,0,0,0,0,0,0,0,0,0,1,0,0,3,0,0,2,0,0,1,3,2,0,1,2,0,0,2,0,1,0,0,0,1,1,3,0,1,0,3,2,0,0,1,0,0,0,0,2,1,0,0,0,0,3,0,0,0,2,2,2,3,0,0,0,1,0,0,0,0,0,0,3,0,1,0,0,2,0,0,0,3,0,0,0,0,0,1,0,1,6,1,2), fight = c(1,1,1,1,2,1,1,1,2,2,2,1,1,2,2,1,1,1,1,2,1,1,1,1,1,-1,1,-2,1,2,1,1,1,1,1,1,1,2,1,1,1,2,1,-2,1,1,-2,1,1,1,2,1,1,1,-1,1,1,1,-2,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,-2,1,1,1,-2,1,1,1,1,2,1,1,1,1,1,1,1,1,2,-1,2,1,2,1,-2,1,2,1,1,1,1,1,1,1,1,1,1,2,-2,1,2,1,1,1,1,1,2,1,1,2,1,2,1,1,1,1,1,1,1,1,-1,1,1,1,1,1,1,2,1,1,1,2,1,1,1,-1,1,1,1,2,1,1,-2,1,2,1,1,1,-2,1,1,2,1,1,1,1,2,1,1,1,1,2,1,2,1,1,2,1,1,1,1,1,2,2,1,1,1,1,2,-1,1,1,2,1,1,1,1,1,2,1,1,-1,1,1,1,1,1,1,1,1,1,1,1,-1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,-1,1,1,1,1,1,-1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,-1,1,-1,1,2,1,1,1,1,1,1,2,1,1,1,1,1,1,2,1,1,2,2,1,-2,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,2,-1,1,1,1,1,1,1,1,1,1,1,2,1,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,2,1,-2,1,1,-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,2,1,1,1,-1,1,1,1,1,2,1,1,1,1,1,1,1,1,2,1,1,1,1,2,2,1,1,1,2,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,1,2,1,2,1,1,-1,1,1,1,1,-2,1,-1,1,1,1,1,1,1,2,1,2,1,1,1,1,1,2,-1,2,1,1,1,2,1,2,1,2,1,1,2,1,1,1,2,1,2,-1,1,1,1,1,1,1,2,2,-2,2,1,1,1,-1,1,1,1,1,1,1,1,1,2,1,-1,1,1,1,1,1,2,1,2,-2,2,1,1,1,1,1,2,2,1,2,1,1,1,2,1,2,1,1,2,1,1,1,2,1,1,1,-2,2,1,1,1,1,1,2,1,2,1,1,1,1,1,1,-1,-1,1,1,1,1,1,1,1,-1,1,-1,2,-1,1,2,2,2,2,1,2,1,1,1,2,1,2,2,1,1,1,2,1,1,2,1,1,1,-2,1,1,2,1,1,1,2,2,1,1,2,1,-2,1,1,1,1,1,-1,-2,1,1,1,1,1,1,2,1,1,2,2,1,1,2,1,-1,2,1,1,1,2,1,2,2,1,1,1,1,1,1,1,1,1,1,1,2,-1,1,1,1,-1,1,2,1,1,1,1,1,-1,1,1,1,1,1,2,1,1,1,2,2,2,2,1,1,2,2,1,1,1,1,2,1,1,1,1,1,-1,1,2,-1,2,2,1,-1,1,1,1,2,1,1,1,2,1,1,1,1,1,1,1,2,2,-2,2,1,1,1,1,1,-1,1,1,-1,1,1,1,1,1,-1,-1,1,1,1,1,1,1,1,1,1,1,2,1,2,1,1,1,2,1,1,2,1,2,1,2,1,1,1,1,1,1,1,1,2,1,1,1,-1,2,2,1,1,1,-1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,2,2,-1,-1,1,2,1,1,2,2,1,1,1,1,2,1,2,1,2,1,1,1,-1,2,1,1,1,2,2,1,1,2,-1,2,2,1,1,1,2,1,1,2,2,1,2,-1,1,1,2,2,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,2,-2,1,-1,1,1,1,-2,1,2,2,2,1,1,2,1,1,1,2,-1,1,1,2,1,1,1,1,1,-1,2,1,2,1,1,1,1,1,-1,1,1,1,-2,-1,1,-1,2,1,1,1,1,2,1,1,2,2,1,2,2,2,2,2,2,-1,1,1,2,2,2,1,1,1,1,-1,2,1 ,2,2,2,2,1,2,1,-1,-1,1,1,1,1,1,1,2,2,1,2,2,1,1,-1,2,-2,1,1,2,1,-1,2,-1,2,-1,2,2,1,-1,2,2,1,2,1,2,1,2,1,2,2,1,1,2,1,1,1,1,-1,1,1,-1,1,2,1,1,2,-1,1,1,1,1,2,1,2,1,1,2,1,1,2,1,1,1,1,2,1,1,1,1,1,1,1,2,1,1,1,1,1,1,2,2,1,2,-1,2,1,1,-1,1,1,-1,2,-1,1,1,2,1,2,1,1,-1,2,2,1,1,2,1,2,1,1,1,1,1,2,1,1,2,2,1,-1,1,1,-1,1,1,1,2,1,2,2,1,2,2,2,2,1,2,1,1,1,-1,1,2,1,1,1,2,1,-1,2,1,2,-1,2,1,1,1,1,1,1,2,1,1,1,1,2,2,1,1,1,2,1,1,2,1,1,1,-1,1,1,1,-1,1,-1,1,1,1,1,2,2,-1,1,1,1,-1,1,2,1,2,1,1,1,2,2,1,-1,-2,1,1,2,1,1,-1,2,1,2,1,1,2,1,1,2,2,1,2,2,2)) I båda variablerna finns en del negativa värden. Använd logiska operatorer för att skapa en ny data frame som bara innehåller observationer med positiva värden i båda variablerna. Visa svar För att skapa det nya datamaterialet behövs en logisk sats för varje variabel. Notera att målet är att filtrera ut de rader som har minst ett negativt variabelvärde, och eftersom rader filtreras bör den första positionen användas i indexeringen. Notera även att 0 är ett giltigt antal barn, och därför bör inkluderas i det nya materialet. # Både children OCH fight måste vara större än eller lika med 0 för att vara kvar wvs_pos &lt;- wvs[wvs$children &gt;= 0 &amp; wvs$fight &gt;= 0, ] summary(wvs_pos) # Kontrollera att de nya värdena känns rimliga children fight Min. :0.000 Min. :1.000 1st Qu.:0.000 1st Qu.:1.000 Median :1.000 Median :1.000 Mean :1.405 Mean :1.244 3rd Qu.:2.000 3rd Qu.:1.000 Max. :8.000 Max. :2.000 Skapa två nya variabler inom ramarna för data framen. De två variablerna ska vara barn: En faktorvariabel som visar om respondenten har barn eller inte kriga: En faktorvariabel som visar om respondenten är villig att ge sig ut i eller inte Visa svar Barn: Skapa först den nya variabeln i wvs_pos wvs_pos$barn &lt;- NA # Skapar ny variabel Fyll sedan variabeln så att den tar värde Barn om respondenten har barn (alltså om children &gt; 0), och värde Inga barn annars wvs_pos$barn[wvs_pos$children &gt; 0] &lt;- &quot;Barn&quot; # Anger vilka som har barn wvs_pos$barn[wvs_pos$children == 0] &lt;- &quot;Inga barn&quot; # Anger vilka som inte har barn Gör, till sist, om den nya variabeln till en faktorvariabel, och dubbelkolla att nivåerna ser rätt ut wvs_pos$barn &lt;- factor(wvs_pos$barn) # Gör om till faktorvariabel levels(wvs_pos$barn) # Kollar faktornivåer [1] &quot;Barn&quot; &quot;Inga barn&quot; kriga: Denna variabel skapas på samma sätt som variabeln ovan. Börja med att skapa den nya variabeln i data framen wvs_pos$kriga &lt;- NA Eftersom fight redan är uppdelad i de två kategorier som är av intresse för uppgiften, går det att omvandla den till en faktorvariabel direkt (inga mellansteg för omkodning behövs) wvs_pos$kriga &lt;- factor(wvs_pos$fight) Kontrollera sedan vilken ordning nivåerna står i, och ge dem lämpliga namn levels(wvs_pos$kriga) # Ser att 1 är första nivån och 2 är andra [1] &quot;1&quot; &quot;2&quot; levels(wvs_pos$kriga) &lt;- c(&quot;Kriga&quot;, &quot;Inte kriga&quot;) Dubbelkolla att de nya nivåerna har plockats upp av R levels(wvs_pos$kriga) # Skriver ut nya nivåer [1] &quot;Kriga&quot; &quot;Inte kriga&quot; Skapa en korstabell med krig som radvariabel och barn som kolumnvariabel, för att se om benägenheten att kriga är större hos respondenter som har barn än bland dem som inte har barn. Korstabellens celler ska innehålla andelar, och andelarna ska summera till 1 kolumnvis. Visa svar Börja med att skapa en vanlig korstabell som visar frekvenser. Kom ihåg att radvariabeln anges som första argument, och sedan kolumnvariabeln. tab_krig_barn &lt;- table(wvs_pos$krig, wvs_pos$barn) # Skapar korstabell med frekvenser Använd sedan prop.table() för att skapa en tabell med andelar. Argumentet margin = 2 ser till så att andelarna i varje kolumn summerar till 1. p_tab_krig_barn &lt;- prop.table(tab_krig_barn, # Korstabell med andelar margin = 2) # Kolumner summerar till 1 p_tab_krig_barn # Skriver ut tabellen Barn Inga barn Kriga 0.8134642 0.6511628 Inte kriga 0.1865358 0.3488372 Det ser ut som att respondenter som har barn är beredda att kriga i större utsträckning. Skapa ett uppdelat stapeldiagram för att illustrera informationen som finns i tabellen i c. Visa svar Använd barplot() för att skapa diagrammet, och sedan legend() för att lägga till en nyckel barplot(p_tab_krig_barn, xlab = &quot;Föräldrastatus&quot;, ylab = &quot;Andel (0-1)&quot;, # Axelnamn col = c(&quot;deeppink&quot;, &quot;dodgerblue4&quot;)) # färger på stapelfält legend(&quot;top&quot;, # Vill ha nyckeln längst upp horiz = TRUE, # Horisontell nyckel xpd = TRUE, # Låter nyckeln visas utanför diagrammet inset = c(0, -0.15), # Justerar nyckelns position bty = &quot;n&quot;, # Tar bort kanlinje runt nyckel legend = c(&quot;Kriga&quot;, &quot;Inte kriga&quot;), fill = c(&quot;deeppink&quot;, &quot;dodgerblue4&quot;)) 5.6 Referenser Gerritsen, A. A., De Vet, H. C., Scholten, R. J., Bertelsmann, F. W., De Krom, M. C., &amp; Bouter, L. M. (2002). Splinting vs surgery in the treatment of carpal tunnel syndrome: a randomized controlled trial. Jama, 288(10), 1245-1251. Helsing, K. J., &amp; Comstock, G. W. (1977). What kinds of people do not use seat belts?. American Journal of Public Health, 67(11), 1043-1050. Raghubir, P., &amp; Srivastava, J. (2009). The denomination effect. Journal of Consumer Research, 36(4), 701-713 Rosa, L., Rosa, E., Sarner, L., &amp; Barrett, S. (1998). A close look at therapeutic touch. Jama, 279(13), 1005-1010. "],["kvantitativa-variabler.html", "Kapitel 6 Kvantitativa variabler 6.1 Analys av en kvantitativ variabel 6.2 Analys av två kvantitativa variabler 6.3 Övningsuppgifter 6.4 Referenser", " Kapitel 6 Kvantitativa variabler body { text-align: justify} En kvantitativ variabel är en variabel vars variabelvärden är tal. Till exempel skulle en kvantitativ variabel kunna mäta Ålder: 0, 1, 2, 3,  (I detta fall anges ålder som ett siffervärde, och inte en åldergrupp som i Kapitel 5.) Antal barn i en förskoleklass: 35, 36, 37,  Avstånd till närmsta tunnelbanestation: Kan mätas i meter, kilometer, eller någon annan avståndsenhet. Nederbörd under en given dag: Förslagsvis mätt i milimeter. Vad som tyligt framgår av variablerna ovan är att varje enskilt variabelvärde har numerisk betydelse, och inte enbart betecknar en kategori, grupp, eller klass. Variablerna mäts alltså på intervall- eller kvotskala. Kvantitativa variabler delas vanligtvis in i två underkategorier, nämligen diskreta och kontinuerliga variabler. Kontinuerliga variabler kan anta värden på hela den reella tallinjen (t.ex. 1 , \\(\\sqrt{2}\\), \\(\\pi\\), eller vilket annat värde som helst), medan diskreta variabler brukar begränsas till sådana variabler som bara kan anta heltalsvärden (alltså 0, 1, 2, osv. Notera att 0 inte alltid räknas med). De fyra exempelvariablerna ovan kan självfallet klassificeras som antingen diskreta eller kontinuerliga. Ålder och antal barn klassas här som diskreta variabler (givet att ålder bara mäts i hela år, och att barn bara räknas i heltal), samtidigt som avstånd till tunnelbana och nederbörd betraktas som kontinuerliga (eftersom varken avstånd eller nederbörn nödvändigtvis behöver vara heltal. Ett avstånd kan vara 0.57 km, till exempel). Notera att de båda kontinuerliga variablerna i detta fall måste vara positiva, eftersom vare sig negativ nederbörd eller negativa avstånd finns i verkligheten. En sak som är viktig att komma ihåg är dock att denna begränsning inte gäller generellt för kontinuerliga variabler, utan de kan också vara negativa. Ta som exempel temperatur eller årlig vinst för ett visst företag (givet att förlust ses som negativ vinst). Detta kapitel handlar om hur kontinuerliga variabler kommer hanteras i R under kursens gång, och tanken är att det ska ge information om hur kontinuerliga variabler kan beskrivas med hjälp av R (beskrivande statistik, tabeller och figurer). För att visa tydliga och illustrativa exempel kommer ett och samma datamaterial användas i hela kapitlet. Datamaterialet kommer från en studie om lungkapacitet, och är hämtat från Rosner (2006). I materialet finns 654 observationer (alla från olika individer) i tre variabler fev: forcerad utandningsvolym (forced expiratory volume). Mäter den största luftmängd som kan avges vid forcerad utandning inom ett givet antal sekunder. Värdet anges i liter per sekund (kontinuerlig). age: varje individs ålder då mätningen gjordes (diskret). heights: varje individs längd (i tum) då mätningen gjordes (kontinuerlig). Datamaterialet finns gömt under fliken här nedanför, och för att följa med i de exempel som demonstreras är det bra att kopiera variablerna och klistra in dem i ett eget R-script. Visa datamaterial fev &lt;- c(1.708, 1.724, 1.72, 1.558, 1.895, 2.336, 1.919, 1.415, 1.987, 1.942, 1.602, 1.735, 2.193, 2.118, 2.258, 1.932, 1.472, 1.878, 2.352, 2.604, 1.4, 1.256, 0.839, 2.578, 2.988, 1.404, 2.348, 1.755, 2.98, 2.1, 1.282, 3, 2.673, 2.093, 1.612, 2.175, 2.725, 2.071, 1.547, 2.004, 3.135, 2.42, 1.776, 1.931, 1.343, 2.076, 1.624, 1.344, 1.65, 2.732, 2.017, 2.797, 3.556, 1.703, 1.634, 2.57, 3.016, 2.419, 1.569, 1.698, 2.123, 2.481, 1.481, 1.577, 1.94, 1.747, 2.069, 1.631, 1.536, 2.56, 1.962, 2.531, 2.715, 2.457, 2.09, 1.789, 1.858, 1.452, 3.842, 1.719, 2.111, 1.695, 2.211, 1.794, 1.917, 2.144, 1.253, 2.659, 1.58, 2.126, 3.029, 2.964, 1.611, 2.215, 2.388, 2.196, 1.751, 2.165, 1.682, 1.523, 1.292, 1.649, 2.588, 0.796, 2.574, 1.979, 2.354, 1.718, 1.742, 1.603, 2.639, 1.829, 2.084, 2.22, 1.473, 2.341, 1.698, 1.196, 1.872, 2.219, 2.42, 1.827, 1.461, 1.338, 2.09, 1.697, 1.562, 2.04, 1.609, 2.458, 2.65, 1.429, 1.675, 1.947, 2.069, 1.572, 1.348, 2.288, 1.773, 0.791,1.905, 2.463, 1.431, 2.631, 3.114, 2.135, 1.527, 2.293, 3.042, 2.927, 2.665, 2.301, 2.46, 2.592, 1.75, 1.759, 1.536, 2.259, 2.048, 2.571, 2.046, 1.78, 1.552, 1.953, 2.893, 1.713, 2.851, 1.624, 2.631, 1.819, 1.658, 2.158, 1.789, 3.004, 2.503, 1.933, 2.091, 2.316, 1.704, 1.606, 1.165, 2.102, 2.32, 2.23, 1.716, 1.79, 1.146, 2.187, 2.717, 1.796, 1.953, 1.335, 2.119, 1.666, 1.826, 2.709, 2.871, 1.092, 2.262, 2.104, 2.166,1.69, 2.973, 2.145, 1.971, 2.095, 1.697, 2.455, 1.92, 2.164, 2.13, 2.993, 2.529, 1.726, 2.442, 1.102, 2.056, 1.808, 2.305, 1.969, 1.556, 1.072, 2.042, 1.512, 1.423, 3.681, 1.991, 1.897, 1.37, 1.338, 2.016, 2.639, 1.389, 1.612, 2.135, 2.681, 3.223, 1.796, 2.01, 1.523, 1.744, 2.485, 2.335, 1.415, 2.076, 2.435, 1.728, 2.85, 1.844, 1.754, 1.343, 2.303, 2.246, 2.476, 3.239, 2.457, 2.382, 1.64, 1.589, 2.056, 2.226, 1.886, 2.833, 1.715, 2.631, 2.55, 1.912, 1.877, 1.935, 1.539, 2.803, 2.923, 2.358, 2.094, 1.855, 1.535, 2.135, 1.93, 2.182, 1.359, 2.002, 1.699, 2.5, 2.366, 2.069, 1.418, 2.333, 1.514, 1.758, 2.535, 2.564, 2.487, 1.591, 1.624, 2.798, 1.691, 1.999, 1.869, 1.004, 1.427, 1.826, 2.688, 1.657, 1.672, 2.015, 2.371, 2.115, 2.328, 1.495, 2.884, 2.328, 3.381, 2.17, 3.47, 3.058, 1.811, 2.524, 2.642, 3.741, 4.336, 4.842, 4.55, 2.841, 3.166, 3.816, 2.561, 3.654, 2.481, 2.665, 3.203, 3.549, 2.236, 3.222, 3.111, 3.49, 3.147, 2.52, 2.292, 2.889, 2.246, 1.937, 2.646, 2.957, 4.007, 2.386, 3.251, 2.762, 3.011, 4.305, 3.906, 3.583, 3.236, 3.436, 3.058, 3.007, 3.489, 2.864, 3.428, 2.819, 2.25, 4.683, 2.352, 3.108, 3.994, 4.393, 3.208, 2.592, 3.193, 1.694, 3.957, 2.346, 4.789, 3.515, 2.754, 2.72, 2.463, 2.633, 3.048, 3.111, 3.745, 2.384, 2.094, 3.183, 3.074, 3.977, 3.354, 3.411, 2.387, 3.171, 3.887, 2.646, 2.504, 3.587, 3.845, 2.971, 2.891, 1.823, 2.417, 2.175, 2.735, 4.273, 2.976, 3.835, 4.065, 2.318, 3.596, 3.395, 2.751, 2.673, 2.556, 2.542, 2.608, 2.354, 2.599, 1.458, 3.795, 2.491, 3.06, 2.545, 2.993, 3.305, 4.756, 3.774, 2.855, 2.988, 2.498, 3.169, 2.887, 2.704, 3.515, 3.425, 2.287, 2.434, 2.365, 3.086, 2.696, 2.868, 2.813, 4.309, 3.255, 3.413, 4.593, 4.111, 1.916, 1.858, 2.975, 3.35, 2.901, 2.241, 4.225, 3.223, 5.224, 4.073, 4.08, 2.606, 3.169, 4.411, 3.791, 3.089, 2.465, 3.343, 3.2, 2.913, 4.877, 2.358, 3.279, 2.581, 2.347, 2.691, 2.827, 1.873, 3.751, 2.538, 2.758, 3.05, 3.079, 2.201, 1.858, 2.216, 3.403, 3.501, 2.578, 3.078, 3.186, 1.665, 2.081, 2.974, 3.297, 4.073, 4.448, 3.984, 2.25, 2.752, 2.304, 3.68, 3.102, 2.862, 2.677, 3.023, 3.681, 3.255, 3.692, 2.356, 4.591, 3.082, 3.297, 3.258, 2.216, 3.247, 4.324, 2.362, 2.563, 3.206, 3.585, 4.72, 3.331, 5.083, 3.498, 2.417, 2.364, 2.341, 2.759, 2.953, 3.231, 3.078, 3.369, 3.529, 2.866, 2.891, 3.022, 3.127, 2.866, 2.605, 3.056, 2.569, 2.501, 3.32, 2.123, 3.78, 3.847, 3.785, 3.924, 2.132, 2.752, 2.449, 3.456, 3.073, 2.688, 3.329, 4.271, 3.53, 2.928, 2.689, 2.332, 2.934, 2.276, 3.11, 2.894, 4.637, 2.435, 2.838, 3.035, 4.831, 2.812, 2.714, 3.086, 3.519, 4.232, 2.77, 3.341, 3.09, 2.531, 2.822, 3.038, 2.935, 2.568, 2.387, 2.499, 4.13, 3.001, 3.132, 3.577, 3.222, 3.28, 2.659, 2.822, 2.14, 4.203, 2.997, 3.12, 2.562, 3.082, 3.806, 3.339, 3.152, 2.458, 2.391, 3.141, 2.579, 3.104, 4.045, 4.763, 2.1, 3.069, 2.785, 4.284, 4.506, 2.906, 5.102, 3.519, 3.688, 4.429, 4.279, 4.5, 2.635, 2.679, 2.198, 3.345, 3.082, 3.387, 3.082, 2.903, 3.004, 5.793, 3.985, 4.22, 4.724, 3.731, 3.406, 3.5, 3.674, 5.633, 3.122, 3.33, 2.608, 3.645, 3.799, 4.086, 2.887, 4.07, 3.96, 4.299, 2.981, 2.264, 4.404, 2.278, 4.504, 5.638, 4.872, 4.27, 3.727, 2.853, 2.795, 3.211) age &lt;- c(9, 8, 7, 9, 9, 8, 6, 6, 8, 9, 6, 8, 8, 8, 8, 7, 5, 6, 9, 9, 5, 5, 4, 7, 9, 3, 9, 5, 8, 9, 5, 9, 8, 7, 5, 8, 9, 8, 8, 8, 9, 8, 5, 8, 5, 9, 7, 8, 6, 8, 5, 9, 9, 8, 6, 9, 9, 7, 4, 8, 8, 8, 6, 4, 8, 6, 9, 7, 5, 9, 8, 8, 9, 9, 9, 7, 5, 5, 9, 6, 7, 6, 8, 8, 7, 8, 7, 9, 5, 9, 9, 9, 7, 8, 8, 9, 9, 9, 7, 8, 8, 7, 9, 4, 9, 6, 8, 6, 7, 7, 8, 7, 7, 7, 7, 8, 7, 5, 8, 7, 9, 7, 7, 6, 8, 8, 8, 9, 7, 8, 9, 8, 8, 9, 8, 6, 6, 8, 9, 5, 7, 9, 6, 9, 9, 9, 6, 8, 9, 8, 8, 9, 9, 9, 7, 8, 6, 9, 9, 9, 7, 8, 5, 8, 9, 6, 9, 6, 8, 5, 7, 7, 4, 9, 8, 9, 9, 9, 5, 9, 7, 6, 9, 9, 9, 7, 5, 8, 9, 7, 9, 8, 9, 6, 6, 8, 9, 5, 6, 6, 9, 7, 9, 8, 5, 7, 6, 9, 7, 9, 9, 8, 9, 7, 9, 4, 9, 5, 8, 9, 8, 3, 9, 8, 6, 9, 8, 8, 7, 6, 8, 9, 4, 7, 8, 8, 9, 6, 8, 6, 8, 9, 8, 7, 9, 8, 7, 9, 8, 9, 6, 8, 9, 8, 9, 9, 8, 7, 5, 7, 8, 9, 9, 6, 8, 7, 9, 7, 7, 5, 9, 9, 8, 8, 9, 6, 7, 5, 9, 5, 7, 6, 8, 7, 8, 4, 8, 5, 8, 7, 7, 9, 9, 8, 9, 6, 8, 9, 4, 6, 7, 9, 8, 6, 8, 7, 5, 8, 7, 11, 10, 14, 11, 11, 12, 10, 11, 10, 14, 13, 14, 12, 12, 10, 13, 10, 11, 10, 11, 10, 13, 14, 11, 10, 11, 13, 10, 10, 12, 10, 10, 10, 11, 11, 11, 10, 11, 11, 13, 13, 11, 11, 14, 11, 10, 10, 10, 14, 13, 10, 14, 10, 11, 13, 12, 13, 10, 13, 11, 14, 11, 13, 11, 11, 10, 11, 11, 10, 11, 13, 12, 10, 10, 14, 11, 10, 11, 10, 11, 13, 13, 10, 11, 11, 12, 10, 10, 11, 10, 11, 14, 13, 12, 11, 11, 11, 14, 12, 10, 12, 11, 10, 11, 13, 10, 10, 11, 13, 10, 11, 10, 13, 11, 10, 11, 11, 14, 11, 13, 11, 11, 10, 13, 10, 13, 10, 12, 10, 14, 12, 10, 11, 14, 12, 10, 10, 10, 10, 12, 13, 11, 12, 11, 12, 11, 11, 12, 12, 13, 11, 12, 10, 12, 13, 10, 12, 10,12, 10, 11, 10, 12, 14, 10, 10, 12, 10, 10, 13, 12, 12, 11, 13, 12, 10, 11, 11, 13, 12, 13, 13, 10, 12, 12, 14, 11, 10, 13, 11, 11, 13, 12, 10, 10, 12, 13, 11, 10, 11, 11, 11, 11, 11, 14, 12, 13, 13, 10, 12, 10, 10, 12, 11, 12, 11, 11, 12, 12, 14, 11, 10, 11, 12, 13, 12, 11, 11, 11, 14, 11, 13, 12, 10, 12, 13, 10, 10, 10, 10, 14, 12, 11, 11, 12, 14, 14, 10, 11, 11, 10, 10, 12, 12, 11, 12, 10, 12, 13, 10, 12, 10, 13, 12, 10, 12, 10, 11, 12, 11, 12, 10, 13, 12, 11, 11, 11, 11, 12, 14, 11, 11, 12, 14, 11, 13, 11, 10, 13, 12, 11, 13, 14, 10, 11, 11, 15, 15, 18, 19, 19, 16, 17, 15, 15, 15, 15, 15, 19, 18, 16, 17, 16, 15, 15, 15, 18, 17, 15, 17, 17, 16, 17, 15, 15, 16, 16, 15, 18, 15, 16, 17, 16, 16, 15, 18, 15, 16, 17, 16, 16, 15, 18, 16, 15) height &lt;- c(57, 67.5, 54.5, 53, 57, 61, 58, 56, 58.5, 60, 53, 54, 58.5, 60.5, 58, 53, 50, 53, 59, 61.5, 49, 52.5, 48, 62.5, 65, 51.5, 60, 52, 60, 60, 49, 65.5, 60, 57.5, 52, 59, 59, 55, 57, 57, 60, 59, 51, 57, 50, 57, 54, 52.5, 55, 60.5, 54.5, 61.5, 62, 54.5, 54, 57, 62.5, 60, 50, 57.5, 60, 60, 51, 49, 59, 57.5, 58, 55.5, 52, 60.5, 57, 58, 60, 59, 59.5, 56, 53, 51, 69, 53, 57, 53, 63, 54.5, 58, 63, 52, 61.5, 52.5, 62, 61.5, 64.5, 57.5, 60, 60, 61, 58, 61.5, 55, 55, 52, 54, 63, 47, 60.5, 56, 58.5, 55, 58.5, 51, 59.5, 54, 58, 58, 52.5, 60.5, 54.5, 46.5, 56.5, 55, 57, 54.5, 54, 53, 57, 59, 55, 55.5, 51.5, 61, 63.5, 57.5, 53, 56.5, 54, 52, 53, 61.5, 58.5, 52, 58, 61, 51, 62, 64.5, 58.5, 52.5, 58, 66, 63.5, 64, 58.5, 64, 60.5, 55, 53, 48, 58.5, 64.5, 60.5, 56, 58.5, 54, 58, 64.5, 50.5, 60, 51.5, 59, 53, 53, 53.5, 52, 64, 63, 58, 58.5, 59.5, 51, 57.5, 47, 55.5, 57, 61, 55.5, 53.5, 50, 61.5, 61.5, 55, 58, 56.5, 57, 52, 52.5, 62.5, 65, 50, 57.5, 56.5, 57.5, 54, 59.5, 59.5, 58, 57, 55, 60, 56.5, 60, 59, 63, 59, 53, 61.5, 48, 63, 55.5, 64.5, 59, 58.5, 46, 62, 53, 49.5, 68, 59.5, 55.5, 55, 51.5, 56, 63, 48, 56.5, 59, 60.5, 65, 55, 55, 51, 52.5, 64, 59, 53.5, 60.5, 59.5, 56.5, 63, 56.5, 61.5, 52, 57, 63.5, 63, 65, 61.5, 62, 55, 51, 54, 57, 56, 61.5, 53, 59, 56, 59, 52.5, 52.5, 50, 59.5, 64, 61, 57.5, 60, 55, 56, 51, 59.5, 50.5, 57.5, 54, 57, 58, 60, 49, 57, 52, 52, 59.5, 58, 64, 57, 53, 62, 53, 56.5, 57, 48, 49.5, 51, 59.5, 56, 54, 57.5, 55.5, 50, 60, 57, 69, 64, 63, 58, 66.5, 60.5, 57, 64, 61, 68.5, 69.5, 72, 71, 63, 61.5, 63.5, 62, 65, 61, 63, 66, 68, 66, 72, 66, 67, 64, 60.5, 63, 64, 60.5, 62, 60, 64.5, 67, 61.5, 66, 60, 64, 68.5, 67, 67, 66, 62.5, 61, 62, 66.5, 60, 64, 62, 58, 68.5, 61.5, 64.5, 67, 68.5, 61, 65, 70, 60, 72, 59, 69, 67.5, 65.5, 65.5, 64.5, 62, 65.5, 67.5, 68, 63.5, 58.5, 65.5, 65, 70.5, 63, 63.5, 66, 63, 67.5, 61.5, 60, 64.5, 68.5, 64.5, 61, 57, 62.5, 58, 62.5, 72.5, 65.5, 69.5, 66.5, 59, 68, 67, 63, 64.5, 62, 62, 66, 62, 62.5, 57, 68.5, 59, 61.5, 65, 66.5, 65, 68, 67, 64.5, 70, 60, 64, 62.5, 61, 64, 65.5, 61, 65.4, 63.5, 67.5, 66, 62, 61.5, 69, 66, 66, 69, 71, 60.5, 58, 63, 69, 59.5, 64, 74, 64.5, 70, 67, 64.5, 65, 62.5, 68, 68.5, 67.5, 60, 68, 65, 64, 73, 59, 70.5, 66, 61.5, 67, 62.5, 52.5, 72, 71, 65.5, 60, 60, 60.5, 59, 68, 62, 64.5, 63, 66, 67, 57, 63, 62, 65, 68.5, 69, 71, 58, 63.5, 66.5, 67, 64, 61, 67, 67.5, 68, 66.5, 67, 60.5, 70, 63.5, 65, 63, 61, 65.5, 67.5, 61, 63, 63.5, 70, 71.5, 65.5, 74, 68, 61, 61, 61, 61.5, 67, 63, 67.5, 70.5, 70.5, 62, 62, 61.5, 62, 60.5, 62.5, 63, 63, 62, 65.5, 65, 70, 66, 63, 68, 59, 68.5, 63, 63, 66, 62, 68, 72.5, 64, 65.5, 61.5, 57, 64, 66, 64.5, 67, 72, 65, 63, 62, 71, 61, 65.5, 62, 65.5, 70.5, 62, 65.5, 65, 61, 69.5, 65, 65.5, 63.5, 60.5, 65, 67, 63.5, 59.5, 63.5, 61, 66, 64, 62, 60.5, 71, 64.5, 61, 62.5, 64.5, 68, 68.5, 62, 60, 59.5, 61, 63, 67.5, 69, 68, 58, 65, 69, 70, 71, 66, 72, 66, 68, 70, 67.5, 70, 64, 66, 62, 65.5, 64.5, 66.5, 67, 63, 64, 69, 71, 68, 70.5, 67, 69, 62, 67.5, 73, 64, 68.5, 62, 73.5, 66.5, 67, 63, 69.5, 70, 66, 66, 63, 70.5, 60, 72, 70, 72, 67, 68, 60, 63, 66.5) 6.1 Analys av en kvantitativ variabel 6.1.1 Enklare deskriptiva mått Det första steget i en dataanalys, oavsett vilken, är nästan alltid en beskrivning av datamaterialet. Såväl analytikern som mottagaren tjänar mycket på att få en helhetsbild av datamaterialet. För att initiera en sådan analys är det vanligt att beräkna sedan tidigare kända stickprovsmedelvärden och stickprovsstandardavvikelser. Utöver dessa är det också bra att beräkna medianer och kvartilavstånd (på engelska: inter-quartile range, IQR) för att få en mer robust bild av variablernas läge och spridning. Dessa värden beräknas med koden nedan. #### Värden för fev #### fev_bar &lt;- mean(fev) # Medelvärde fev_sd &lt;- sd(fev) # Standardavvikelse fev_md &lt;- median(fev) # Median fev_iqr &lt;- IQR(fev) # Kvartilavstånd fev_bar [1] 2.63678 fev_sd [1] 0.8670591 fev_md [1] 2.5475 fev_iqr [1] 1.1375 #### Värden för age #### age_bar &lt;- mean(age) # Medelvärde age_sd &lt;- sd(age) # Standardavvikelse age_md &lt;- median(age) # Median age_iqr &lt;- IQR(age) # Kvartilavstånd age_bar [1] 9.931193 age_sd [1] 2.953935 age_md [1] 10 age_iqr [1] 4 Ett smidigt sätt att ta fram deskriptiv statistik för en variabel är att använda funktionen summary(). Den används enkelt som nedan. summary(fev) # Beskrivande statistiv för fev Min. 1st Qu. Median Mean 3rd Qu. Max. 0.791 1.981 2.547 2.637 3.119 5.793 summary(age) # Beskrivande statistiv för age Min. 1st Qu. Median Mean 3rd Qu. Max. 3.000 8.000 10.000 9.931 12.000 19.000 Som synes beräknar funktionen variablernas största respektiva minsta värde, deras medelvärde och median, samt deras första respektive tredje kvartiler. I situationer då andra percentiler är av intresse kan funktionen quantile() användas. Som argument i funktionen anges dels vilken variabel beräkningen ska utföras på, dels vilka percentiler som önskas. För att plocka fram den 10:e och 90:e percentilen för fev används koden nedan. quantile(fev, probs = c(0.1, 0.9)) # Percentiler för fev 10% 90% 1.612 3.813 I detta fall tolkas den 90:e percentilen som att 90% av individenerna har ett lägre värde än \\(3.813\\). Percentilerna beräknas på olika sätt beroende på om variabeln har ett jämnt eller udda antal observationer (precis som medianen beräknades på olika sätt under första halvan av grundkursen i statistik). R känner av detta automatiskt, och kan så räkna ut percentilerna på rätt sätt. För framtida referens är det dock bra att komma ihåg att percentiler kan ligga mellan två observationer. Notera att tolkingen av percentilen ovan inte är helt olik de tolkningar av kvartiler som redogjorts för i tidigare kurser i statistik. Försök använda quantile() för att ta fram de tre kvartilerna, och jämför med värdena ovan. Den korrekta koden finns i fliken här nedan. Visa kod för percentiler Argumentet probs = c(0.25, 0.5, 0.75) får funktionen att returnera första kvartilen, medianen, och tredje kvartilen. Fundera gärna på hur kvartiler bör tolkas, och övertyga dig själv om att koden ger rätt resultat. quantile(fev, probs = c(0.25, 0.5, 0.75)) # Kvartiler för fev 25% 50% 75% 1.9810 2.5475 3.1185 6.1.2 Frekvenstabeller Frekvenstabeller kan användas för att ge en mer detaljerad bild av en specifik variabel, och de kan även agera som stöd vid framtida analyser. I R skapas frekvenstabeller med hjälp av funktionen table(), vilken skriver ut en tabell i konsollen. För att frekvenstabeller ska vara användbara är det bra om variabeln som ska beskrivas inte antar för många olika värden. I sådana fall blir frekvenstabellen inte särskillt sammanfattande, utan bara ett sätt att återge alla värden som finns i datamaterialet. Frekvenstabeller lämpar sig därför till att beskriva diskreta variabler (som inte tar alltför många variabelvärden) som till exempel age, precis som här nedan. table(age) # Frekvenstabell för age age 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 2 9 28 37 54 85 94 81 90 57 43 25 19 13 8 6 3 Utskriften är i detta fall uppdelad i två rader. Den övre raden visar de olika åldrarna som finns angivna i variabeln, och den undre raden anger hur många personer som angivit varje ålder. Det var alltså två treåringar, nio fyraåringar, och 28 femåringar som undersöktes i studien, till exempel. I fallet med age gav table() en värdefull sammanfattning av hur åldersspridningen ser ut i datamaterialet. Eftersom det bara finns 17 olika åldrar i datamaterialet är tabellen relativt liten, och den skulle utan några större problem få plats på ett A4 (t.ex. i en rapport). I fallet fev, däremot, finns väldigt många olika variabelvärden, och en frekvenstabell för variabeln blir därför en enda stor röra (resultatet av att köra table(fev) finns gömt under fliken här nedan). Därför är det, som sagt, bäst att använda frekvenstabeller när antalet olika variabelvärden är relativt litet. Vad litet betyder i detta fallet är en smaksak, och det finns inga specifika regler eller bestämmelser för detta. Visa tabell Inte särskilt tilltalande att ha med i en rapport: table(fev) # Stökig frekvenstabell för fev fev 0.791 0.796 0.839 1.004 1.072 1.092 1.102 1.146 1.165 1.196 1.253 1.256 1.282 1 1 1 1 1 1 1 1 1 1 1 1 1 1.292 1.335 1.338 1.343 1.344 1.348 1.359 1.37 1.389 1.4 1.404 1.415 1.418 1 1 2 2 1 1 1 1 1 1 1 2 1 1.423 1.427 1.429 1.431 1.452 1.458 1.461 1.472 1.473 1.481 1.495 1.512 1.514 1 1 1 1 1 1 1 1 1 1 1 1 1 1.523 1.527 1.535 1.536 1.539 1.547 1.552 1.556 1.558 1.562 1.569 1.572 1.577 2 1 1 2 1 1 1 1 1 1 1 1 1 1.58 1.589 1.591 1.602 1.603 1.606 1.609 1.611 1.612 1.624 1.631 1.634 1.64 1 1 1 1 1 1 1 1 2 3 1 1 1 1.649 1.65 1.657 1.658 1.665 1.666 1.672 1.675 1.682 1.69 1.691 1.694 1.695 1 1 1 1 1 1 1 1 1 1 1 1 1 1.697 1.698 1.699 1.703 1.704 1.708 1.713 1.715 1.716 1.718 1.719 1.72 1.724 2 2 1 1 1 1 1 1 1 1 1 1 1 1.726 1.728 1.735 1.742 1.744 1.747 1.75 1.751 1.754 1.755 1.758 1.759 1.773 1 1 1 1 1 1 1 1 1 1 1 1 1 1.776 1.78 1.789 1.79 1.794 1.796 1.808 1.811 1.819 1.823 1.826 1.827 1.829 1 1 2 1 1 2 1 1 1 1 2 1 1 1.844 1.855 1.858 1.869 1.872 1.873 1.877 1.878 1.886 1.895 1.897 1.905 1.912 1 1 3 1 1 1 1 1 1 1 1 1 1 1.916 1.917 1.919 1.92 1.93 1.931 1.932 1.933 1.935 1.937 1.94 1.942 1.947 1 1 1 1 1 1 1 1 1 1 1 1 1 1.953 1.962 1.969 1.971 1.979 1.987 1.991 1.999 2.002 2.004 2.01 2.015 2.016 2 1 1 1 1 1 1 1 1 1 1 1 1 2.017 2.04 2.042 2.046 2.048 2.056 2.069 2.071 2.076 2.081 2.084 2.09 2.091 1 1 1 1 1 2 3 1 2 1 1 2 1 2.093 2.094 2.095 2.1 2.102 2.104 2.111 2.115 2.118 2.119 2.123 2.126 2.13 1 2 1 2 1 1 1 1 1 1 2 1 1 2.132 2.135 2.14 2.144 2.145 2.158 2.164 2.165 2.166 2.17 2.175 2.182 2.187 1 3 1 1 1 1 1 1 1 1 2 1 1 2.193 2.196 2.198 2.201 2.211 2.215 2.216 2.219 2.22 2.226 2.23 2.236 2.241 1 1 1 1 1 1 2 1 1 1 1 1 1 2.246 2.25 2.258 2.259 2.262 2.264 2.276 2.278 2.287 2.288 2.292 2.293 2.301 2 2 1 1 1 1 1 1 1 1 1 1 1 2.303 2.304 2.305 2.316 2.318 2.32 2.328 2.332 2.333 2.335 2.336 2.341 2.346 1 1 1 1 1 1 2 1 1 1 1 2 1 2.347 2.348 2.352 2.354 2.356 2.358 2.362 2.364 2.365 2.366 2.371 2.382 2.384 1 1 2 2 1 2 1 1 1 1 1 1 1 2.386 2.387 2.388 2.391 2.417 2.419 2.42 2.434 2.435 2.442 2.449 2.455 2.457 1 2 1 1 2 1 2 1 2 1 1 1 2 2.458 2.46 2.463 2.465 2.476 2.481 2.485 2.487 2.491 2.498 2.499 2.5 2.501 2 1 2 1 1 2 1 1 1 1 1 1 1 2.503 2.504 2.52 2.524 2.529 2.531 2.535 2.538 2.542 2.545 2.55 2.556 2.56 1 1 1 1 1 2 1 1 1 1 1 1 1 2.561 2.562 2.563 2.564 2.568 2.569 2.57 2.571 2.574 2.578 2.579 2.581 2.588 1 1 1 1 1 1 1 1 1 2 1 1 1 2.592 2.599 2.604 2.605 2.606 2.608 2.631 2.633 2.635 2.639 2.642 2.646 2.65 2 1 1 1 1 2 3 1 1 2 1 2 1 2.659 2.665 2.673 2.677 2.679 2.681 2.688 2.689 2.691 2.696 2.704 2.709 2.714 2 2 2 1 1 1 2 1 1 1 1 1 1 2.715 2.717 2.72 2.725 2.732 2.735 2.751 2.752 2.754 2.758 2.759 2.762 2.77 1 1 1 1 1 1 1 2 1 1 1 1 1 2.785 2.795 2.797 2.798 2.803 2.812 2.813 2.819 2.822 2.827 2.833 2.838 2.841 1 1 1 1 1 1 1 1 2 1 1 1 1 2.85 2.851 2.853 2.855 2.862 2.864 2.866 2.868 2.871 2.884 2.887 2.889 2.891 1 1 1 1 1 1 2 1 1 1 2 1 2 2.893 2.894 2.901 2.903 2.906 2.913 2.923 2.927 2.928 2.934 2.935 2.953 2.957 1 1 1 1 1 1 1 1 1 1 1 1 1 2.964 2.971 2.973 2.974 2.975 2.976 2.98 2.981 2.988 2.993 2.997 3 3.001 1 1 1 1 1 1 1 1 2 2 1 1 1 3.004 3.007 3.011 3.016 3.022 3.023 3.029 3.035 3.038 3.042 3.048 3.05 3.056 2 1 1 1 1 1 1 1 1 1 1 1 1 3.058 3.06 3.069 3.073 3.074 3.078 3.079 3.082 3.086 3.089 3.09 3.102 3.104 2 1 1 1 1 2 1 4 2 1 1 1 1 3.108 3.11 3.111 3.114 3.12 3.122 3.127 3.132 3.135 3.141 3.147 3.152 3.166 1 1 2 1 1 1 1 1 1 1 1 1 1 3.169 3.171 3.183 3.186 3.193 3.2 3.203 3.206 3.208 3.211 3.222 3.223 3.231 2 1 1 1 1 1 1 1 1 1 2 2 1 3.236 3.239 3.247 3.251 3.255 3.258 3.279 3.28 3.297 3.305 3.32 3.329 3.33 1 1 1 1 2 1 1 1 2 1 1 1 1 3.331 3.339 3.341 3.343 3.345 3.35 3.354 3.369 3.381 3.387 3.395 3.403 3.406 1 1 1 1 1 1 1 1 1 1 1 1 1 3.411 3.413 3.425 3.428 3.436 3.456 3.47 3.489 3.49 3.498 3.5 3.501 3.515 1 1 1 1 1 1 1 1 1 1 1 1 2 3.519 3.529 3.53 3.549 3.556 3.577 3.583 3.585 3.587 3.596 3.645 3.654 3.674 2 1 1 1 1 1 1 1 1 1 1 1 1 3.68 3.681 3.688 3.692 3.727 3.731 3.741 3.745 3.751 3.774 3.78 3.785 3.791 1 2 1 1 1 1 1 1 1 1 1 1 1 3.795 3.799 3.806 3.816 3.835 3.842 3.845 3.847 3.887 3.906 3.924 3.957 3.96 1 1 1 1 1 1 1 1 1 1 1 1 1 3.977 3.984 3.985 3.994 4.007 4.045 4.065 4.07 4.073 4.08 4.086 4.111 4.13 1 1 1 1 1 1 1 1 2 1 1 1 1 4.203 4.22 4.225 4.232 4.27 4.271 4.273 4.279 4.284 4.299 4.305 4.309 4.324 1 1 1 1 1 1 1 1 1 1 1 1 1 4.336 4.393 4.404 4.411 4.429 4.448 4.5 4.504 4.506 4.55 4.591 4.593 4.637 1 1 1 1 1 1 1 1 1 1 1 1 1 4.683 4.72 4.724 4.756 4.763 4.789 4.831 4.842 4.872 4.877 5.083 5.102 5.224 1 1 1 1 1 1 1 1 1 1 1 1 1 5.633 5.638 5.793 1 1 1 div.yellow{ background-color:#FFFA94; border-radius: 5px; padding: 20px;} Saknade värden i frekvenstabeller Funktionen table() hanterar saknade värden, NA, på olika sätt, beroende på hur kommandot useNA specificeras. För att illustrera detta används vektorn mis_vec &lt;- c(1, 2, 3, NA, 1, 2, 3) När table() används som vanligt renderas tabellen som visas nedan. table(mis_vec) mis_vec 1 2 3 2 2 2 När inget anges kommer R automatiskt anta att antalet NA i datamaterialet inte är av intresse, och därför exkludera det ur tabellen. Ibland kan det dock vara så att bortfallet faktiskt spelar roll, och i transparenta studier är det bra att rapportera hur stort borfallet är (om det finns något sådant, det vill säga). För att R ska räkna antalet saknade värden och skriva med det i tabellen används argumentet useNA = \"ifany\", då renderas istället tabellen här nedan. table(mis_vec, useNA = &quot;ifany&quot;) mis_vec 1 2 3 &lt;NA&gt; 2 2 2 1 Det är alltså bra att fundera över huruvida eventuellt bortfall bör räknas med när en frekvenstabell ska skapas, och om sådant är fallet, använda useNA = \"ifany\". 6.1.3 Histogram I fall där frekvenstabeller blir stökiga på grund av ett stort antal olika variabelvärden kan histogram användas som ett mer kompakt alternativ. Histogram används huvudsakligen för att ge en bild av hur kontinuerliga variabler är fördelade, men de kan också användas för diskreta variabler med väldigt många olika variabelvärden. I R skapas histogram med funktionen hist(). Ett enkelt histogram över variabeln fev skapas med koden nedan. hist(fev) # Histogram över fev 6.1.3.0.1 Etiketter Funktionen hist() har väldigt många olika argument som kan användas för att justera diagrammet som skapas. Tre alternativ som är bra att känna till är main, xlab, och ylab. Med hjälp av dessa justeras diagrammets titel, samt texten som hör till varje axel. Med koden nedan ändras dessa argument för att skapa ett mer informativt diagram. # Histogram med titel och nya labels hist(fev, main = &quot;Forcerad andingsvolym&quot;, ylab = &quot;Frekvens&quot;, xlab = &quot;FEV (liter per sekund)&quot;) Från och med nu kommer de olika diagrammen dölja sig i flikar under koden. Detta för att texten ska förbli relativt kort och lättnavigerad. Visa figur I det fall då en titel eller text inte önskas alls kan argumentet bara lämnas blankt. Testa till exempel att göra histogrammet ovan med argumenten main = \" \" eller xlab = \" \" 6.1.3.0.2 Längd på axlarna I vissa fall behöver längden på diagrammets axlar justeras. I R görs detta med argumenten ylim och xlim. För att ändra argumenten anges en vektor med två element, det första anger det lägsta axelvärdet som ska tillåtas, och det andra elementet anger det högsta axelvärdet som ska tillåtas. Antag att axlarna i histogrammet ovan av någon anledning ska förlängas så att att \\(x\\)-axeln går från -5 till 10, och \\(y\\)-axeln går från 0 till 200 (notera att ett negativt \\(x\\)-värde inte nödvändigtvis är rimligt i just detta exempel, men det kan vara önskvärt i andra fall). En sådan figur skapas med hjälp av koden nedan. # Histogram med nya axellängder hist(fev, xlim = c(-5, 10), ylim = c(0, 200)) Visa figur 6.1.3.0.3 Frekvenser ovanför varje klass När histogram sparas i ett eget objekt, till exempel vid namn h, sparas även information så som frekvenser och klassmitter i objektet. För åtkomst till denna information används $, på ett liknande sätt som det används för åtkomst till variabler i en data frame. h &lt;- hist(fev, ylim = c(0, 170)) # Sparar histogram i h h$mids # Plockar ut klassmitter m.h.a. $mids [1] 0.75 1.25 1.75 2.25 2.75 3.25 3.75 4.25 4.75 5.25 5.75 h$counts # Plockar ut frekvenser m.h.a. $counts [1] 3 37 127 148 136 103 48 30 16 3 3 Den sparade informationen kan nu användas för att ange frekvensen i varje klass i histogrammet. För att göra detta används tilläggsfunktionen text() som nedan. De två första argumenten i funktionen anger kordinater för texten i \\(x\\)- och \\(y\\)-led (de bestämmer var texten ska ligga i diagrammet). Argumentet labels anger vilken text som skrivas ut, och eftersom det är frekvenserna som önskas specificeras argumentet som labels = h$counts. Det sista argumentet, adj, ser till så att texten centreras ovanför varje klass, testa gärna att sätta in andra värden istället för \\(0.5\\) och \\(-0.5\\) för att se vad som händer. h &lt;- hist(fev, ylim = c(0, 170)) text(h$mids, h$counts, labels = h$counts, adj = c(0.5, -0.5)) Visa figur 6.1.3.0.4 Klassgränser och antal klasser Argumentet breaks kan användas på två olika sätt. Antingen kan en vektor med önskade klassgränser anges, eller så kan argumentet anges för att justera antalet klasser i ett histogra. Jämför till exempel de två histogrammen som genereras nedan, och fundera på hur de hänger ihop med koden. hist(fev, breaks = c(0, 1, 3, 6)) Visa figur hist(fev, breaks = 20) Visa figur Notera att argumentet breaks kan vara lite tjurigt i det senare fallet. Ibland blir det så att R (av helt oförståeliga själ) delvis ignorerar argummentet och väljer klassgränser som programmet själv ser som lämpliga. Det är bra för användaren att ha detta i sitt medvetande, då det inte alltid behöver vara så att koden i sig är fel, utan det kan bara vara R som spökar. I de fall där klassbredderna är olika är det bra att använda argumentet freq = FALSE. R använder då frekvenstätheter, istället för frekvenser, i histogrammet, och diagrammets \\(y\\)-axel blir mycket lättare att tolka. 6.1.3.0.5 Ytterligare specifikationer Av rent estetiska själ kan det vara önskvärt att ta bort kantlinjerna runt de olika staplarna. I R ordnas detta med argumentet border = FALSE. Dessutom kan staplarnas färg ändras till något lite roligare än grått, detta ändras med hjälp av argumentet col (en samling av hur olika färger kodas i R finns här ). Ett lite snyggare histogram skulle till exempel kunna skapas som nedan. hist(fev, main = &quot;&quot;, # Tar bort histogrammets titel xlab = &quot;FEV (liter/sek)&quot;, # Etikett på x-axel ylab = &quot;Frekvens&quot;, # Etikett på x-axel breaks = 20, # Antal klasser border = FALSE, # Tar bort kant runt staplar col = &quot;plum&quot;) # Ändrar färg på staplarna div.yellow{ background-color:#FFFA94; border-radius: 5px; padding: 20px;} Klassgränser och antalet klasser Valen som görs ovan är naturligtvis subjektiva, och det finns inget som säger vad som är snyggt eller inte. Det är dock bra att tänka lite extra på hur klassgränser och antalet klasser specificeras i ett histogram, eftersom detta kan påverka hur väl diagrammet faktiskt speglar datamaterialet. Här nedan illustreras samma datamaterial i fyra histogram med olika klassgränser och antal klasser. Datamaterialet som illustreras är normalfördelat, vilket tydligt kan ses i figurerna längst upp till vänster och längst ner till höger. I de övriga diagrammen är det svårt att säga något som helst om huruvida datamaterialet är normalfördelat eller ej. Det är därför värt att testa ett par olika alternativ innan ett slutligt diagram väljs, för att hitta den inställning som illustrerar datamaterialet så bra som möjligt. 6.2 Analys av två kvantitativa variabler Detta avsnitt handlar om hur två kvantitativa variabler kan illustreras i samma figur. Avsnittet är uppdelat i två delar, där distinktionen grundar sig i vilka variabeltyper det är som ska illustreras. Baserat på denna distinktion bestäms vilken typ av diagram som är mest lämpligt (precis som i statistik A4/A8), och det är därför väldigt bra att tänka på vilken typ av variabler som ska beskrivas innan den deskriptiva analysen påbörjas. 6.2.1 Två kontinuerliga variabler De två vanligaste sätten att beskriva två kontinuerliga variabler är spridningsdiagram och Pearsons korrelationskoefficient. Det förra är ett bra sätt att illustrera samvariation mellan variabler, och den senare mäter huruvida det finns något linjärt samband mellan de båda variablerna. 6.2.1.1 Spridningsdiagram Många gånger kan det vara av intresse att skapa en figur för att se om två kontinuerliga variabler samvarierar på något sätt, och då är spridningsdiagram (scatter plot) ett bra alternativ. Spridningsdiagram skapas med det generiska kommandot plot() i R, och kan till stor del justeras på samma sätt som histogrammen ovan. För att skapa ett vanligt spridningsdiagram där height finns \\(x\\)-axeln och fev finns på \\(y\\)-axeln används koden nedan. plot(x = height, y = fev) I figuren kan cirklarna som representerar varje observation bytas ut till andra symboler, detta görs genom att ändra argumentet pch till ett siffervärde mellan 0 och 25. Till exempel kan cirklarna bytas ut till kvadrater med hjälp av koden nedan (en sida som sammanfattar vilket siffervärde som ger vilken symbol finns här. plot(x = height, y = fev, pch = 0) Visa figur Det finns en del argument som fyller samma funktion i plot() som i hist(), dessa är main, xlab och ylab för titlar och etiketter ylim och xlim för axellängder col för färger på punkterna. Ett lite snyggare spridningsdiagram kan skapas som plot(x = height, # x-variabel y = fev, # y-variabel ylab = &quot;FEV (liter/sek)&quot;, # Etikett till y-axel xlab = &quot;Längd&quot;, # Etikett till x-axel pch = 16, # Ifylld punkt som markör col = &quot;blue&quot;) # Ändrar färg på punkterna 6.2.1.2 Pearsons korrelationskoefficient Pearsons korrelationskoefficient är ofta ett bra komplement till ett spridningsdiagram. Korrelationskoefficienten kan ta värden mellan -1 och 1, och mäter hur pass linjär samvariationen mellan två kontinuerliga variabler är, alltså hur väl punkterna i spridningsdiagrammet är samlade runt en rät linje. En korrelationskoefficient som ligger nära 1 tyder på stark, positiv samvariation. Om den ena variabeln har ett högt värde, är det högst troligt att även den andra har det (se den översta figuren här nedan). Motsvarande gäller för obseravtioner med låga värden. En korrelationskoefficient på -1 tyder på det motsatta, om den ena variabeln har ett högt värde förväntas den andra variabeln ha ett lågt värde (se den mellersta figuren här nedan). Slutligen tyder en korrelationskoefficient nära 0 på att ingen linjär smavariation finns, punkterna bör alltså vara spridda slumpmässigt i diagrammet (se den nedre figuren här nedan). I R beräknas stickproveskorrelationen mellan två variabler med hjälp av funktionen cor(). Stickprovskorrelationen mellan height och fev beräknas som cor(x = height, y = fev) [1] 0.868135 Vilket ser ut att stämma relativt väl överens med spridningsdiagrammet i det förra avsnittet. div.yellow{ background-color:#FFFA94; border-radius: 5px; padding: 20px;} Korrelation och icke-linjära samband En sak som är viktig att komma ihåg är att Pearsons korrelations-koefficient bara mäter hur stark den linjära samvariationen mellan två variabler är. Det finns naturligtvis flera typer av samvariation som inte är linjära, och i deskriptiva analyser är det därför viktigt att använda korrelations-koefficienten med viss försiktigthet, och gärna tillsammans med spridningsdiagram. Här nedan följer ett exempel som visar på varför en viss grad av försiktighet är nödvändig. I fliken finns två variabler x_cor och y_cor som används för att illustrera en situation då korrelationskoefficienten, när tolkas felaktigt, kan ge en skev bild av datamaterialet. Visa datamaterial x_cor &lt;- c(-5.86439253855497, -1.43597680237144, -0.557658380828798, 0.553684489801526, -1.48444498702884, -4.54311690945178, -4.70674677751958, 4.60378906968981, -1.43077093642205, -2.44445485342294, -4.48213258478791, 1.71518361009657, -4.26403472386301, -0.208796096965671, -3.69642441999167, -0.304030154831707, 2.30663920473307, 4.72523551527411, 2.10758776031435, 5.78801127243787, 4.59385838359594, -3.53894815407693, -4.06569141335785, -0.933496956713498, 5.01003466453403, -2.92779209185392, 0.383819226175547, 1.69766232836992, -0.0605317857116461, 2.15893999580294, -0.937316212803125, -1.26719969697297, -1.06448861863464, -0.70016285777092, 3.85658694896847, -4.302495572716, -4.40025229286402, -1.75088406633586, 4.64191750902683, -5.45604836661369, 2.1750651570037, -2.65939560346305, -2.80156862642616, -0.296186163090169, -5.6524095358327, 2.24203268252313, -4.34353812318295, 5.11039749998599, -1.71673354133964, -0.19572323653847, 0.433533512055874, 2.86123791430146, 3.56698769889772, 5.12141733337194, 5.66679778229445, 1.42487081419677, 1.02799868490547, 3.07261069491506, -0.523379808291793, -3.97485722322017, 2.47302148025483, -0.959513308480382, 0.435494952835143, 2.56544065196067, -4.23642921354622, 2.51910498552024, -3.43450129777193, 4.40523060131818, 4.14423972554505, 2.7713297791779, -0.659573706798255, -0.316247899085283, -4.37690794095397, 0.701152271591127, 5.01649497449398, -2.51752826850861, -5.19016728177667, 0.846395524218678, -3.74603203497827, 2.9088171645999, -5.34782209899276, 4.68921250384301, 3.54415418487042, -0.661200986243784, 3.53289462905377, 4.25234192423522, 4.19615561608225, 2.602389623411, -1.57098864857107, 2.30702747404575, -4.52308602724224, 5.23059280961752, -5.76080022845417, -0.810422932729125, 0.611223335377872, 3.11755008157343, 1.94819243531674, -2.98065088782459, 5.24784311838448, 2.04372919443995, -2.52907108515501, 2.27760804723948, -1.01213886961341, 1.89285836555064, 1.48235849384218, -0.756356027908623, -2.67695398908108, -2.8729636548087, -1.13260476384312, 5.53976978547871, -4.86333254165947, 3.73086743988097, 3.51884004659951, 2.53500320389867, -4.02673621941358, 4.72284496296197, -5.26503092329949, 2.81897336896509, 3.97550426702946, -1.89988576434553, 2.14803829137236, -1.21428278367966, 1.86381844617426, -3.91419969219714, -5.26569446269423, -5.33130717650056, -0.940515568479896, -0.887071288190782, 1.18806012813002, -5.16970119997859, -0.87442019674927, 0.449586038477719, -3.53376394417137, -3.34293064288795, -2.21858079917729, 3.05507892742753, 2.79804273694754, 2.70105247199535, 2.82882257737219, -0.00406247656792402, -3.01224234234542, -5.17500651441514, -4.46285936515778, -5.56699248589575, 0.391616527922451, -3.77570909075439, -0.801314611919224, -0.834749462082982, -5.10326085425913, -4.49976385105401, 4.30535251367837, 1.95064429007471, -4.27386486344039, -1.22882923856378, -4.94328713882715, 1.95183547865599, -1.91666411329061, -1.86356966011226, 5.11462553031743, -3.20687001664191, -3.38617214374244, -1.3609501440078, 5.20629471447319, 4.32619164604694, 1.36014333274215, -1.66064143180847, 0.160328395664692, -3.09523442387581, -2.80701953172684, 3.52882725466043, 1.92389569245279, -3.34456553310156, -1.08310336433351, -4.21733734756708, 2.41087722312659, 1.32709406409413, 2.75043877400458, -4.4830230306834, -1.22587357275188, -1.48652502615005, -0.891042815521359, 4.15688028931618, -2.4806948332116, -3.21958520170301, 1.8265458997339, -5.35168910678476, 5.40245028678328, -5.22069438826293, -0.696254429407418, 3.07486899476498, -2.64368547219783, 0.313281577080488, 4.13077652547508, 0.59310564212501, -4.45451829582453, -3.89451640751213, -1.54594003781676, -3.08049134351313, 0.177653674967587, 3.50173227488995, -2.01388649828732, 3.16356065869331, -4.8224638486281, -4.89060790836811, 1.16010802611709, -4.60733616258949, 3.94017753470689, -2.344950302504, -3.18453837186098, -4.00804762355983, -2.76524977572262, -4.77857188414782, 1.92331372294575, 2.0959399882704, 1.89606608077884, 4.46141163725406, -4.31323133502156, 2.20478624850512, -0.232552042230964, 4.8380277575925, 3.11489412467927, 3.46245760470629, 1.87206973694265, 2.80687589105219, 1.83384580537677, 2.63242583256215, 0.495583872310817, -5.15827745106071, -4.84405103512108, -5.21479791775346, 3.35555247310549, -1.44319519400597, 1.4710839567706, 2.24455487541854, 1.27918676845729, -1.61587416194379, -0.146192556247115, -1.50593885779381, -2.21367011871189, 3.85590899270028, 2.31367619521916, 0.817260009236634, 3.81954930536449, 1.78521729446948, -0.931415791623294, -4.05018984898925, 2.88604778051376, -3.54378416575491, 0.934073282405734, 1.91026193741709, 3.90620255470276, -3.09297367371619, -0.781432407908142, -3.37139746919274, -3.48574412427843, -0.201942172832787, -1.03117333631963, -2.29081455152482, 4.9195710606873, 5.59172852151096, -3.06280124746263, -5.04959790408611, -1.67600579280406, -5.62163967546076, 0.00048559159040451, 2.44796640146524, -4.40249607246369, -3.12038963846862, -5.90665160212666, -3.07803991343826, -2.705247589387, -1.41524924430996, -5.66812112554908, -5.52824538107961, 4.69527727738023, -0.0249824076890945, -4.41420126333833, 0.268953206017613, 1.70019644312561, 3.85920576564968, 0.982753903605044, -2.0266708675772, -2.07221507281065, -3.13442851323634, 0.901587945409119, -3.32639229577035, -2.64481509849429, -1.4289373839274, -1.01676025986671, -0.260985455475748, -2.20148284826428, 0.471208141185343, 3.62979944888502, -1.63145815953612, 5.50091175176203, 4.04855551756918, -0.204747154377401, -1.6134633757174, 4.006162667647, -5.78578860964626, -4.4473615558818, -0.51764655020088, 1.77362532075495, -4.23136412724853, 3.21683595143259, 4.25683191139251, 5.71499114949256, -5.90049939695746, -4.94474141299725, -0.461656811647117, 0.22233750578016, -0.368306050077081, -0.631843621842563, -2.71005070768297, -5.55788201931864, -5.35080788377672, -5.84003126062453, 2.66926260385662, -3.76998704764992, -0.425729823298752, -2.05537411943078, 0.216768493875861, -3.48466119077057, 3.64808512665331, 2.10386463347822, 4.14911777805537, 2.46440581697971, -3.05821720417589, -0.770339076407254, -4.01560948323458, 1.64552938565612, -4.31913993693888, -2.94404711388052, 2.63366373907775, -0.509436529129744, -2.43900655489415, 3.90388449747115, 4.94141294248402, -2.8335997145623, -0.750269285403192, -3.51249697431922, 3.06972266547382, 5.7715987348929, 3.49607700482011, -5.46911952272058, 1.49682352971286, 0.185940451920033, 2.61120565887541, -2.07450593076646, 1.94110536295921, 4.13435281813145, 0.668913943693042, 0.533427002839744, 1.13682076055557, -3.3515594098717, 2.10873214714229, 4.52574804984033, 2.65504027716815, 5.93163960892707, 4.58176778163761, -2.80901133175939, -3.70125117525458, 4.5074990959838, -2.17553016263992, -0.41508043371141, -1.84128791559488, -2.52211849205196, -2.9997620433569, 3.17430431395769, -2.54884536657482, -0.108684950508177, -3.15567467641085, -5.37086521089077, -2.30455892533064, 5.67356565501541, -5.33359614573419, -3.17525636963546, -3.78735836036503, -0.00814633537083864, -1.17351124249399, -1.76926239486784, -0.631798535585403, -5.41753455530852, 4.33960485365242, -4.70884873252362, -2.85036724805832, -2.89936948008835, 4.22600639238954, -1.10508747305721, 1.77784910704941, 0.364222071133554, -5.72863668389618, -4.27188852801919, -5.86537114251405, 1.52154471259564, -2.15860872622579, 1.88831554446369, 4.67907990887761, 4.60909154545516, -5.56265650782734, -0.851920531131327, -1.72764524258673, 3.68325364496559, 1.29211596306413, 4.76557127572596, -4.73709072265774, -5.0276418523863, -5.31207323726267, 5.46919869817793, 0.556542861275375, -3.09453079663217, 0.398685554042459, -0.384768535383046, -0.531101575121284, -0.0766403647139668, -5.65018736477941, -2.89195249322802, 1.10902743134648, -5.56165512744337, -4.23958828020841, -5.01453134045005, -0.189870553091168, -2.83492263313383, 2.41574100404978, -2.05251438729465, -5.96921091992408, 4.23230962269008, -2.39341560378671, 3.69120146613568, 3.35365698114038, 4.95318208169192, 2.78710991330445, 3.91960581298918, -3.40767204668373, -2.59056472219527, 4.46527017373592, -0.534307681024075, 5.52204624004662, 5.36765942070633, 0.336890671402216, 1.15953898429871, 0.351983623579144, 0.0615966478362679, 5.42799248266965, -4.37932213023305, 3.13442898541689, -3.14388785976917, 5.89572857413441, 5.56920766364783, -0.842380355112255, -5.95428342372179, 0.466116718947887, 3.39090068824589, -3.98534075729549, -5.00015527568758, 2.99162599258125, -2.87129613943398, -4.36781460978091, 4.76908676885068, -5.67027823068202, -4.05202140379697, -2.03874458279461, 5.96935374476016, 3.04529627133161, 1.46130614262074, -4.8296627746895, 5.18354105204344, 2.60001885239035, 4.74056925158948, 3.47412625607103, -3.83562496025115, 1.47017023991793, 0.20291362144053, 3.64169818349183, -1.36433559469879, 5.50361108779907, -0.567957239225507, -1.23456984199584, 1.33138702344149, 5.14894889015704, -2.75500717945397, 5.42817679233849, -0.385761078447104, 2.53641148936003, 1.07004427537322, 5.20073131285608, 3.42966685909778, -2.25469410605729, 4.43185863643885, 3.94910727906972, 2.33184932917356, -3.19552502408624, -5.40801217965782, -3.02428950089961, -2.64520167466253, -0.800308775156736, 3.50004907697439, 0.120768285356462, -2.46703495178372, 5.66788987442851) y_cor &lt;- c(0.692116077725195, -0.833820835658524, 0.551094316233229, 0.478165553350035, -0.996419884224274, -0.992730153952847, -0.787317798367764, -0.885604533948131, -1.06152101350711, 0.457057894147183, -0.729896585604075, -0.978794513790041, -0.60522686417355, 0.797339815551349, 0.390540098705696, 0.791056199476351, -0.0658394160600363, -1.07956091031993, -0.377898994096769, 0.676724127351636, -0.92271062688403, 0.68211062246375, -0.265586770375202, -0.281990646259145, -0.933569187989352, 0.970442057904559, 0.855239683269214, -0.913340432870525, 1.05755126441053, -0.557728609466566, -0.413071062494649, -0.750623331324987, -0.496536315071716, -0.00276258290690587, 0.0894836188515442, -0.68468900083751, -0.769706234509263, -1.12258289596224, -0.862053797212771, -0.136507484911278, -0.231558312720629, 0.512022766999122, 0.670063652650559, 0.734333679199448, 0.11875944371307, -0.26798051360053, -0.600224989852732, -0.589775882767548, -0.92930591562741, 0.922846118851976, 0.578995361790117, 0.97066756897238, 0.68790797465233, -0.536706968725068, 0.441770394137291, -0.881256478813447, -0.361936174831535, 1.05982364925898, 0.548092220946772, -0.240150837343345, 0.359091389633033, -0.36895423258766, 0.613186081882422, 0.623229100015448, -0.486751410585548, 0.46160923108823, 0.903730917053862, -0.659747459903884, -0.449591389386599, 0.705197272782706, 0.174335085452261, 0.843079786347905, -0.640998796648546, 0.249470157541554, -1.02428382665794, 0.274645055014929, -0.569701349870323, -0.227953728783033, 0.21991606361946, 0.862578816245065, -0.454157706556781, -0.992151900718503, 0.726538430118473, 0.366356885419869, 0.698431515406227, -0.589898304479426, -0.42313463129314, 0.351647363269612, -0.915081710580083, -0.203387000470344, -0.945642100191838, -0.42970695945602, 0.437503680874048, -0.143954453092994, 0.213954707871942, 0.965641966991328, -0.842223666863874, 0.965819897883947, -0.628395164741264, -0.561860829959186, 0.318873605579769, -0.319851707066493, -0.324045829438118, -0.952772340775089, -0.924445349040963, 0.0753221581027099, 0.500514167001168, 0.876576303959421, -0.570347773359213, 0.019722702177426, -0.89257920086998, 0.258685868429658, 0.759805312436448, 0.262874143005627, -0.322119082028071, -1.02183036134721, -0.598527601774096, 0.696783591016198, 0.0570775881532332, -0.888576552095211, -0.359856562825605, -0.65347558048046, -0.961958430946146, 0.0979345855190165, -0.492788566103075, -0.33472866844283, -0.413830595911876, -0.150506615673904, -0.749560511121892, -0.577635086304876, -0.113693313572898, 0.557698126284979, 0.650887752184128, 1.09609841455634, -0.239600812541057, 0.925275829714373, 0.988146976419745, 0.667171239978437, 0.787995243735866, 0.928322239709289, 0.956953986603638, -0.630923702091154, -0.770594811693208, 0.0361742629265017, 0.614372251426405, 0.339422414729519, 0.105203804090473, -0.0811484394321826, -0.644019143260316, -0.957072615434561, -0.657568606516498, -0.657184692154678, -0.715883475657522, -0.983216106811242, -0.701445457809133, -0.746729244754527, -0.721298971546328, -0.917333397952104, -0.7440246871844, 0.942722246720506, 0.742486110862305, -0.87643277604441, -0.397882897374624, -0.609278544430292, -0.788774517324603, -1.03008786999627, 0.900174883722106, 0.876550985507823, 0.772520611319698, 0.714399684849063, -0.734153776138897, 0.843446606937203, -0.520221715898307, -0.873207573363112, 0.183251446777576, -0.786414826767054, 0.764042479408094, -0.849391737954901, -0.744589245253425, -1.01871713617985, 0.00793431716737572, -0.315083596059678, 0.336162131415597, 1.10719386364714, -0.920051555908693, -0.332402980346329, -0.387380886383534, -0.744629579313388, 0.249807585560943, 0.85315614501589, 0.564613607101056, 0.860703086960768, -0.41180534727551, 0.155062583456708, -0.84944302770448, -0.0232354897945976, -1.21581192855228, 0.942392667564932, 0.968358502729973, 0.843350560478223, -0.633419379891784, 0.973409076411311, -0.965002020381659, -0.723426638130645, -0.635624656346435, -0.907780517197421, -0.0659472296454691, 0.0290512372461689, 0.943477419282174, -0.115736535875326, 0.662690666046125, -0.9681085235679, -0.769870076469868, -0.43319885747632, -0.953036650100475, -0.934255632582831, -0.712949266901575, -0.371267882159617, 0.770395281297423, -0.915116089169343, 0.990521822374141, 0.807322690010507, -0.848620205350821, 0.845720759505633, -0.992056768890273, 0.48865106070475, 0.447179115401043, -0.78738628578981, -0.882652853235678, -0.580708608540424, 1.12462815136212, -0.886842239561658, -0.876510666038672, -0.0528351480259851, -1.07946627084427, -0.926451976564244, 1.04189351967588, -0.873138160446389, -0.323302547342293, -0.0398336883927105, -0.0723876475197, 0.0299203623621222, 0.26771157331388, -0.799702005811923, -0.0927464925429201, -0.140132425501586, 0.791514174457469, 0.661362629969618, -0.194673394925077, -0.826110437080204, 0.0521029906218902, 0.993778152017857, -0.135797400885025, 0.861960227188668, 0.702640664956012, 0.734991552394919, -0.482055266374795, -0.15321908581954, -0.941768627602878, 0.172938151698188, 1.0452041992147, -0.909228336253595, -0.966156394921463, 0.272876182068588, 0.922914912684233, 0.274903818453297, -0.685046983835134, 1.01215693839823, 0.819070409348976, 0.856227674956861, 0.789428305518576, -1.08349033649955, 0.251286664934293, 0.111426160383657, -0.861936599935431, 0.887230833488581, -1.04773500244942, 0.951517615425827, -0.936397263489121, 0.171010205107887, -0.464208296441551, -0.609430728927302, -0.575950432922157, 1.06164100137271, -0.122266753685931, 0.966287429868908, 0.581564671231955, -1.08817933125627, -0.580379324594687, 1.03281086814407, -0.348869193069082, 0.745142774179912, 0.567237298372281, -1.07948998560629, 0.0517884494519469, -0.181908987477246, 0.959735673555604, -0.890529355141261, -0.286825361441517, 0.5194807972762, -0.821528526196263, 0.451678946467058, -1.13755433623201, -0.647394918459111, 1.11755054614341, -0.572189434431056, 0.537328007215023, 0.80585733992751, -0.903018870834392, 0.609266424849447, 0.9168705239366, 0.612378460576535, 0.51330690518088, 0.619295145555417, 0.0739018077311075, -0.360211626817118, 0.928834828811469, 0.548861930170216, 0.27891033502873, 0.629701339579054, -0.545770238682216, 1.02493997465363, 0.677732512511985, 0.512342385480205, -0.563566564867947, -0.499778393251972, 0.135866115302711, 0.94627533975966, 0.0524937887958016, -0.244888692869009, -1.12082462487432, -0.719907209607575, 1.00667181435325, 0.587339268146245, 0.525369587475545, 0.116621365487128, 0.0508602438018313, -0.802706540742785, 0.694343718370414, 0.0346940197725392, 0.784159600151842, 0.838395539018007, 0.459368890835023, 0.866974611760156, 0.0528053656688342, -1.08648127648979, 1.04313494380031, 0.507105448819916, -0.673336071921562, -0.631624742395916, -0.444355259541822, 0.340284440437517, 0.476499394293787, -0.676650757568411, 0.949218974919565, -0.552239842328508, -0.892022109030021, 0.722671286426101, 0.863173008060452, -0.870035077996046, 0.666044476900363, 0.399800786701317, -0.902105309464301, -0.327330240437956, 0.582333659618165, -1.04118647337577, 0.374628419458681, 0.975500452347226, 1.11807023884526, 0.430445983928438, 0.775979329187456, 0.901168524943803, -0.178248981348715, -0.0324343500448203, 0.496659607431612, -0.455993445133844, 1.08446294951181, 0.31210075299887, 0.979991122264016, -0.627660741306241, -0.893155340150051, 0.331431540329934, -0.0574182076128606, -0.573875698051284, -0.851669095478101, 0.509540521704214, 0.842563085161535, -0.445790499937521, -0.488148274278827, -1.00000971308572, 0.750717107650914, 0.385189991815612, -0.71432092292147, 0.691388931950444, -1.11184411614013, -0.337024133112692, -0.827471547601959, -0.871687732023444, -1.06905464378816, 0.0944049479804341, -0.0169893750874063, -0.997835764718766, 0.380411826809133, -0.941900543925321, -1.29054424821311, -0.99249496058113, -0.949842557020156, -0.404215020038054, 0.0647648419477043, 0.492438306722134, 0.887835951467139, 0.87494312701596, 0.575746537260541, 0.338525111524258, 1.00095143145309, 0.241769246710808, 0.899207125012576, -0.678461931814348, 0.189889832655481, -0.581158606619191, -0.727976273121182, 0.930054847124453, 0.653144522968482, 0.176551055270141, -0.533423432541824, 0.865739420200622, -0.474139877566841, 0.293145174517555, 0.354327758401527, 0.815337022899501, -1.08101701113977, 0.82278581508067, -0.0431081510758147, 1.04132522096649, 0.524951746682782, -0.993426699521503, 0.631744939827365, 0.0709007298133944, -0.271754635437279, 0.832096335135455, -0.68804061681554, 0.742072601691465, 0.943729735608386, -0.130215855909967, -0.581137545540033, 0.995667609461697, 1.00926658886954, 0.609834597051648, -0.0480545501906195, -0.030081984508683, 0.773978460184942, 0.630026868098328, 0.787489191743331, -0.126706512812433, -0.815946746752882, 0.927014256322037, 0.878520117718395, -0.818300729363242, -0.939861414262159, 0.383374915016445, -0.361952298070514, -0.573478966354709, 0.846810192777705, 1.07876450582925, -0.815416053273182, -1.05012205676904, -0.494305637011417, 0.336976113298814, -0.966394021248254, 0.770021134498414, 0.138068916310278, -1.03810537426467, 0.820994176723859, 0.439047680723385, -1.03761045203866, -0.194799550931192, 0.517542667931891, -0.896932625734218, -0.910902040542301, -0.772447333215392, 0.764862844103926, -0.258852077275202, 0.658500894604562, 0.322701881663578, -0.433746793503408, -0.427160971046463, 0.799620457272055, -0.209058723465767, -0.828836013742181, -0.113169127607347, -0.00575135876008619, 1.18235488908229, -0.164927025768732, 1.11476710397186, 0.409038999872967, 0.044165125913567, 0.63751883848208, 1.02399771931605, 0.0931674689632747, 0.368893205056112) Kopiera de två variablerna och klistra in dem i R. En snabb korrelationsanalys ger då en väldigt svag korrelation. cor(x = x_cor, y = y_cor) [1] -0.0217337 En förhastad slutsats skulle då kunna vara att de två variablerna är helt oberoende, och inte samvarierar på något sätt. Denna slutsats är dock felaktig, vilket framgår tydligt om sambandet illustreras i en figur. plot(x = x_cor, # x-variabel y = y_cor, # y-variabel ylab = &quot;&quot;, # Etikett till y-axel xlab = &quot;&quot;, # Etikett till x-axel pch = 16, # Ifylld punkt som markör col = &quot;blue&quot;) # Ändrar färg på punkterna Som synes finns en tydlig, icke-linjär, samvariation variablerna emellan, vilket inte framgår av korrelationskoefficienten. Slutsatsen om brist på samvariation skulle därför vara fel. Det är alltså viktigt att komma ihåg att korrelationskoefficienten bara mäter hur pass väl punkterna samlar sig runt en rät linje, och variablerna inte kan betraktas som helt oberoende bara för att korrelationskoefficienten är (när) 0. En analys som bygger på oberoende variabler skulle i detta fallet bli missvisande. 6.2.2 En kontinuerlig och en diskret variabel När en av de två variablerna är diskret finns en risk att spridningsdiagram blir svårtolkade, och det är därför bäst att använda en annan typ av figur för att illustrera de två variablerna tillsammans. I sådana fall är box plots (lådagram) det vanligaste alternativet. Om antalet variabelvärden i den diskreta variabeln är lågt kan det även vara lämpligt att skapa ett histogram per variabelvärde, och sedan placera histogrammen bredvid varandra. 6.2.2.1 Lådagram Lådagram kan ses och tolkas som motsvarigheten till ett spridningsdiagram, med skillnaden att det i detta fall illustrerar en kontinuerlig och en diskret variabel. På samma sätt som spridningsdiagramet ger lådagrammet en uppfattning om hur två variabler samvarierar, och ger även en bild av hur de båda variablernas spridning ser ut. För att skapa lådagram används funktionen boxplot(), och argumentet som används är av formen y ~ x, där y är den kontinuerliga variabeln, och x är den diskreta. För att skapa ett lådagram som illustrerar samvariationen mellan fev och age kan ett lådagram skapas som nedan. boxplot(fev ~ age) För att göra ett diagram med liggande lådor används argumentet horizontal = TRUE, och precis som i tidigare diagram kan såväl main som xlab, ylab, och col för att justera histogrammets utseende. Ett modifierat lådagram kan skapas med hjälp av koden nedan. boxplot(fev ~ age, # Variabler som används ylab = &quot;Ålder&quot;, # Etikett till y-axel xlab = &quot;FEV (liter/sek)&quot;, # Etikett till x-axel horizontal = TRUE, # Ger liggande lådor col = &quot;lightblue&quot;) # Ändrar färg på lådorna 6.2.2.2 Uppdelade histogram Om den diskreta variabeln har få variabelvärden, eller om ett litet antal grupper ska studeras, kan det vara informativt att göra ett histogram per variabelvärde/grupp och vissa dessa vid sidan av varandra. Genom att temporärt förändra R:s grundinställningar är det möjligt att få R att skriva ut flera diagram bredvid (eller ovanför) varandra. För att ändra grundinställningarna används kod i stil med par(mfrow = c(rader, kolumner), där rader och kolumner ersätts med siffror som anger hur många bilder som ska läggas i vertikal respektive horisontell ledd. Grundinställningen i R är par(mfrow = c(1, 1), vilket betyder att en figur i taget visas i panelen, och det är viktigt att återställa denna inställning när figuren är färdig. Dessa förändringar illustreras bäst med hjälp av exempel. Antag att det är av intresse att jämföra fev för åldrarna 5 respektive 10 år. För att skapa två histogram och visa dem bredvid varandra ersätts rader med 1 och kolumner med 2, och sedan skapas histogrammen som vanligt. Efter detta återställs kolumner till 1 för att sedan kunna skapa figurer som vanligt. Och sedan skapas de båda histogrammen som par(mfrow = c(1, 2)) # Två figurer bredvid varandra hist(fev[age == 5], col = &quot;red&quot;) # Histogram över femåringar hist(fev[age == 10], col = &quot;blue&quot;) # Histogram över tioåringar par(mfrow = c(1, 1)) # Återställer default Det går även att lägga till flera rader med figurer vid behov. För att skapa två figurer till under de som gjordes ovan ändras även rader till 2. Detta ger resultatet nedan. par(mfrow = c(2, 2)) # Två figurer bredvid varandra hist(fev[age == 5], col = &quot;red&quot;) # Histogram över femåringar hist(fev[age == 10], col = &quot;blue&quot;) # Histogram över tioåringar hist(fev[age == 3], col = &quot;green&quot;) # Histogram över ettåringar hist(fev[age == 15], col = &quot;yellow&quot;) # Histogram över femtonåringar par(mfrow = c(1, 1)) # Återställer default Notera att figureran blir ihoptryckta när det läggs bredvid/ovanpå varandra. Det är därför bra att inte rada upp/stapla för många diagram i samma figur, då detta kan påverka diagrammens tydlighet. 6.3 Övningsuppgifter 6.3.1 Uppgift 1 I fliken nedan finns ett simulerat datamaterial med två variabler, value1 och value2. Variablerna är helt fiktiva, och har ingen tolkning i termer av verkliga fenomen, men de kan kan utan problem användas i en övningsuppgift som denna. Visa datamaterial df &lt;- data.frame(value1 = c(7.73,1.77,2.42,5.33,4.22,6.71,-0.62,1.86,-1.02,4.18,7.79,11.81,0.52,4.61,3.42,-0.42,0.68,2.28,-0.86,4.62,5.15,5.94,6.77,8.96,3.33,4.71,4.81,5.58,3.97,3.36,1.8,8.99,3.88,6.58,7.83,5.97,-0.33,6.32,0.43,2.27,0.61,5.99,3.49,7.78,-2.93,6.34,-0.09,4.21,1.34,4.31,3.25,2.73,6.91,9.45,1.24,-2.92,5.82,2.42,0.78,3.89,2.16,7.8,0.04,0.97,5.41,3.42,3.65,1.71,2.29,11.29,16.41,6.55,-0.58,3.62,5.18,6.21,5.18,0.06,11.37,3.31,10.83,9.19,-0.32,6.57,2.25,8.38,-0.93,-1.68,1.71,2.66,4.75,3.68,2.35,13.44,6.52,-5.94,5.49,5.21,1.83,-1.61,4.7,2.69,4.05,1.74,8.51,7.42,1.45,-3.87,2.58,1.65,3.16,6.75,4.72,1.64,5.18,2.79,1.23,5.22,6.44,4.8,3.28,4.38,0.78,0.09,4.16,6.69,-0.49,5.9,1.59,12.13,11.22,0.6,0.57,5.2,-1.52,5.54,4.4,-4.86,6.48,8.84,1.77,2.51,3.74,3.45,1.11,4.1,-1.09,6.81,2.31,3.4,5.12,7.56,1.72,11.01,-1.14,4.28,-1.05,1.25,1.47,3.64,1.94,-2.2,-1.61,9.85,5.51,12.37,4.33,2.27,3.09,5.9,4.39,8.46,3.5,5.89,8.32,-5.38,6.11,0.67,3.01,4.44,2.27,1.38,2.38,1.73,6.79,0.4,4.48,0.12,5.83,1.6,5.68,13.11,3.73,4.19,4.39,9.84,-0.32,4.21,7.77,1.34,8.47,3,0.17,4.54,1.4,-1.71,0.84,1.62,10.47,2.69,1.17,2.85,8,6.43,6.28,6.73,7.06,8.72,5.29,4.66,-2.95,4.94,3.33,-1.7,-0.76,6.63,-2,3.05,1.85,8.17,10.81,11.66,5.92,2.66,2.25,7.41,-3,7.93,2.63,2.84,6.74,2.94,6.73,8.87,4.62,4.89,-0.32,0.4,2.86,-1.12,8.16,0.39,6.93,3.96,1.09,4,-0.52,3.2,3.63,7.1,6.44,1.78,-2.59,2.8,-3.83,-0.6,2.29,2.77,2.65,3.06,6.92,1.32,3.56,5.55,8.36,3,0.58,0.8,4.22,0.59,9.71,-2.14,8.27,1.52,0.68,7.82,8.38,5.43,8.75,2.41,5.07,10.9,3.24,3.95,4,1.2,-1.93,-1.19,6.12,2.79,6.67,0.09,4.81,3.36,4.03,-2.24,2.58,-0.93,-3,3.76,-1.75,2.28,1,8.41,1.67,6.41,0.06,5.77,3.47,3.55,3.03,5.43,2.62,4.82,3.66,6.32,5.02,4.69,-2.92,-3.59,-0.55,6.28,1.15,3.03,4.11,9.45,9.45,5.12,4.43,3.4,9.38,4.82,2.99,4.69,10.65,3.93,3.34,5.2,4.81,1.01,2.98,4.56,1.09,0.82,4.85,5.22,-1.28,6.53,4.8,9.19,11.63,1.64,1.53,8.77,4.44,6.53,4.33,6.72,8.12,8.22,-3.83,2.91,-1.83,5.3,3.76,3.93,-1.32,7.94,-2.42,9.69,-1.45,7.61,5.5,3.89,6.66,3.82,14.27,7.61,9.16,10.21,6.13,1.42,3.58,5.79,4.94,0.07,-0.88,11.42,3.59,0.5,0.51,6.02,5.66,5.46,4.35,7.44,1.57,15.44,7.28,1.1,14.6,-2.48,-3.37,-4.1,7.88,6.05,4.56,4.12,6.45,2.62,8.68,1.52,0.26,1.83,0.57,6.93,7.05,-0.22,6.92,3.93,2.75,-6.45,2.75,3.34,9.07,11.64,7.47,9.13,3.44,-0.1,4.39,4.26,8.97,3,-3.46,-1.42,3.19,7.1,0.51,0.8,2.99,4.25,3.5,0.9,4.21,2.91,5.94,2.77,10.72,-1.92,6.31,5.74,5.85,7.75,13.77,9.69,10.9,7.97,8.36,1.28,-2.33,2.42,4.59,4.93,-0.53,7.74,9.76,4.05,15.55,4.31,0.52,-0.71,5.93,9.8,5.78,6.37,1.65,8.61,6.44,-1.34,13.49,5.42,7.94,-1,5.26,4.41,2.97,2.88,-0.19,0.67), value2= c(4,1,1,3,1,1,2,3,1,2,2,4,2,2,2,2,1,3,1,3,2,3,2,4,3,3,2,3,1,1,3,3,3,4,3,4,2,1,1,3,1,2,2,3,2,2,1,3,2,3,1,3,4,4,2,1,1,3,3,2,2,2,1,1,3,3,3,2,2,4,4,3,1,3,3,3,1,2,3,1,4,4,3,3,3,4,1,1,3,3,4,3,2,4,3,1,4,2,1,2,2,3,2,3,3,1,1,1,3,1,4,3,4,2,1,2,2,1,3,2,1,3,1,2,3,3,1,2,1,4,3,2,1,4,1,2,3,2,4,4,2,3,3,3,3,3,2,2,2,1,4,4,1,4,1,2,1,3,2,1,2,2,1,3,4,3,3,3,2,4,3,4,3,1,4,1,4,3,2,3,2,2,3,4,4,2,3,1,3,1,4,4,2,3,3,4,2,2,4,1,4,3,1,1,2,1,1,1,4,1,2,3,1,4,3,4,4,4,3,4,1,3,3,2,1,4,1,1,1,4,4,4,3,3,2,3,1,3,1,1,4,3,4,4,3,1,3,3,3,1,4,3,3,4,1,2,2,3,2,3,3,2,1,4,1,2,3,3,1,3,4,1,3,4,4,1,2,1,3,1,4,1,1,4,1,3,3,3,3,1,2,4,3,3,3,2,1,1,4,3,4,1,3,2,3,2,1,2,2,1,1,1,1,3,3,2,1,4,3,4,1,4,1,3,3,4,2,3,4,1,1,3,2,2,3,1,4,3,2,3,3,4,1,3,3,1,3,1,3,2,3,3,2,2,3,1,1,4,3,4,2,3,1,4,3,4,2,3,2,4,1,1,3,2,2,2,1,3,1,4,1,3,3,1,3,3,4,4,4,2,4,1,3,3,2,1,1,4,2,1,1,4,2,4,2,3,2,4,4,3,4,1,1,1,3,2,2,2,3,2,4,1,2,1,2,4,4,2,4,3,3,1,3,4,4,3,4,4,3,1,2,3,4,2,1,2,2,4,3,2,2,3,1,1,1,4,4,1,4,1,4,4,2,3,4,4,4,4,3,2,1,2,2,3,1,2,4,2,4,2,2,1,4,4,3,3,3,4,3,1,4,3,4,1,3,2,1,3,4,2)) Kopiera koden i fliken och kör den i R. Koden skapar en data frame vid namn df som innehåller de två variablerna. Undersök vilken vektortyp de två variablerna lagras i. Bekriv sedan variablera, var och en för sig, på ett lämpligt sätt. Visa svar value1: class(df$value1) # Kollar vektortyp &gt; [1] &quot;numeric&quot; head(df$value1) # Skriver ut de första värdena i value &gt; [1] 7.73 1.77 2.42 5.33 4.22 6.71 Som synes är class en kavantitativ variabel, och den verkar även vara kontinuerlig (dess värden är inte heltal), därför skulle variabeln lämpligen kunna beskrivas med hjälp av ett histogram. hist(df$value1, xlab = &quot;Value&quot;, main = &quot;Histogram över &#39;value&#39;&quot;) value2 class(df$value2) # Kollar vektortyp &gt; [1] &quot;numeric&quot; head(df$value2) # Skriver ut de första värdena i value &gt; [1] 4 1 1 3 1 1 value2 är kvantitativ men antar bara heltalsvärde, alltså är det en diskret variabel. Lämpligt är därför att beskriva den med en frekvenstabell tab_v2 &lt;- table(df$value2) tab_v2 &gt; &gt; 1 2 3 4 &gt; 127 112 151 110 eller eventuellt ett stapeldiagram barplot(tab_v2, ylab = &quot;Frekvens&quot;) Antag nu att du är intresserad av att studera sambandet mellan de två variablerna. Närmare bestämt vill du ha value1 som beroende variabel och value2 som oberoende. För att göra en första, deskriptiv, analys vill du illustrera sambandet mellan de två variablerna. Hur kan du göra det på ett lämpligt sätt? Ledning: kom ihåg att tänka på variabeltyper! Visa svar Eftersom value1 är kontinuerlig och value2 är diskret behövs ett diagram som klarar av att kombinera dessa två variabeltyper. Enligt kapiteltextens resonemang bör denna typ av variabelkomination illustreras med en box plot. boxplot(df$value1 ~ df$value2) Att döma av figuren ser det ut som att value1 stiger när value2 också gör det. Du kommer lära dig mer om hur sambandet kan kvantifieras/testas i senare delar av kursen. 6.3.2 Uppgift 2 Kör koden set.seed(211101) value3 &lt;- rnorm(n = 500, mean = (9.89 + 2.059 * df$value1), sd = 3) df &lt;- cbind(df, value3) för att lägga till ytterligare en variabel, value3, till df från Uppgift 1. value3 är en kontinuerlig variabel, och av anledningar som vid denna tidpunkt är oförklarliga finns en misstanke om linjärt samband mellan value3 och value1. Du önskar göra en regressionsanalys för att studera det linjära sambandet, men först behövs en kort deskriptiv studie. Regressionsanalysen är tänkt att ha value3 som \\(y\\)-variabel och value1 som \\(x\\)-variabel. Skapa en figur med två histogram sida vid sida. Det vänstra histogrammet ska visa föredlningen för value1 och det högra fördelningen för value3. På så sätt kan du kontrollera grundantagandet att \\(y\\)-variabeln i regressionsanalysen är normalfördelad. Ser antagandet ut att gälla i detta fall? Visa svar För att skapa histogram används hist() som vanligt, och för att få två diagram bredvid varandra justeras par(mfrow = c(rader, kolumner)) på lämpligt sätt. par(mfrow = c(1, 2)) # Två kolumner, en rad hist(df$value1, main = &quot;Value 1&quot;) hist(df$value3, main = &quot;Value 3&quot;) par(mfrow = c(1, 1)) # Återställer grundinställning Skapa ett spridningsdiagram med value1 på den vågräta axeln och value3 på den lodräta. Uppskatta även korrelationen mellan de två variablerna. Ser det ut som att variablerna är linjärt relaterade med varandra? Visa svar Funktionen plot() används för att skapa ett spridningsdiagram, och cor() för att beräkna stickprovskorrelationen. plot(x = df$value1, y = df$value3, # Anger variabler pch = 20, # Byter stil på punkterna col = &quot;forestgreen&quot;) # Byter färg på punkterna cor(df$value1, df$value3) &gt; [1] 0.9317125 korrelationen är väldigt hög, och spridningsdiagrammet antyder att ett linjärt samband finns (dock är det omöjligt säga om det är ett orsakssamband eller ej). Den som är intresserad kan gå händelserna i förväg och skatta regressionsmodellen (detta kommer tas upp på Mattias del av kursen) och sedan rita in regressionslinjen i diagrammet ovan. Regressionsmodellen skattas med lm(yvariabel ~ xvariabel) och regressionslinjen ritas in med abline() regressionsmodell &lt;- lm(df$value3 ~ df$value1) # Skattar regressionsmodell plot(x = df$value1, y = df$value3, # Anger variabler pch = 20, # Byter stil på punkterna col = &quot;forestgreen&quot;) # Byter färg på punkterna abline(regressionsmodell, col = &quot;red&quot;) # Ritar regressionslinje Notera att detta inte är något du förväntas kunna ännu, utan det är bara för den intresserade. 6.3.3 Uppgift 3 Läs igenom sida 8 i föreläsningsanteckningarna till Kapitel 6 (Programmering_KvantitativaVariabler.pdf). Skapa en liknande vektor med deskrivptiva mått för alder (se sida 6 i samma anteckningar). Kopiera även koden krävs för att skapa objektet desk_tab som finns på sida 8. Visa svar Vi börjar med att kopiera in all kod som krävs för att skapa desk_tab (det blir lättare att modifiera koden så att den använder alder efteråt). # Vektorer från sida 6 langd &lt;- c(194.1, 175.1, 167.1, 161.6, 176.8, 180.9, 180.6, 174.8, 172.4, 187.3, 186.8, 194.6, 154.3, 169.7, 169.5, 168.0, 187.4, 184.7, 195.2, 184.4) alder &lt;- c(21, 20, 29, 26, 20, 20, 21, 29, 29, 22, 21, 22, 23, 26, 23, 25, 21, 24, 24, 23) # Deskriptiva mått för langd (från sida 7) langd_bar &lt;- mean(langd) # Medelvärde langd_sd &lt;- sd(langd) # Standardavvikelse langd_md &lt;- median(langd) # Median langd_iqr &lt;- IQR(langd) # Kvartilavstånd # Kod som skapar desk_tab (från sida 8) desk_tab &lt;- cbind(langd_bar, langd_sd, langd_md, langd_iqr) colnames(desk_tab) &lt;- c(&quot;Medelvärde&quot;, &quot;Std. Av.&quot;, &quot;Median&quot;, &quot;Kvartilavst.&quot;) rownames(desk_tab) &lt;- c(&quot;Langd&quot;) desk_tab &gt; Medelvärde Std. Av. Median Kvartilavst. &gt; Langd 178.265 11.2964 178.7 17.275 För att skapa en vektor med deskriptiva mått över alder kan vi antingen skapa de fyra mellersta objekten ovan (från sida 7) en gång till för alder, eller så kan vi lägga in värdena i en vektor direkt, som i koden nedan # Deskriptiv vektor för alder desk_alder &lt;- c(mean(alder), sd(alder), median(alder), IQR(alder)) desk_alder &gt; [1] 23.450000 3.017057 23.000000 4.250000 Använd rbind() för att lägga till deskriptiva mått för alder i desk_tab. Visa svar Vi kan nu använda rbind() utöka desk_tab med den nya vektorn # Deskriptiv vektor för alder rbind(desk_tab, desk_alder) &gt; Medelvärde Std. Av. Median Kvartilavst. &gt; Langd 178.265 11.296403 178.7 17.275 &gt; desk_alder 23.450 3.017057 23.0 4.250 Och sedan spara den nya desk_tab genom att skriva över den gamla # Deskriptiv vektor för alder desk_tab &lt;- rbind(desk_tab, desk_alder) desk_tab &gt; Medelvärde Std. Av. Median Kvartilavst. &gt; Langd 178.265 11.296403 178.7 17.275 &gt; desk_alder 23.450 3.017057 23.0 4.250 Namnge den nya raden med hjälp av rownames() Visa svar Vi kan lägga till ett namn till den nya raden # Deskriptiv vektor för alder rownames(desk_tab) &lt;- c(&quot;Langd&quot;, &quot;Alder&quot;) desk_tab &gt; Medelvärde Std. Av. Median Kvartilavst. &gt; Langd 178.265 11.296403 178.7 17.275 &gt; Alder 23.450 3.017057 23.0 4.250 Om vi hade fler variabler skulle vi kunna lägga till dem på ett liknande sätt. I nästa kapitel kommer vi lära oss exportera sådana tabeller till word. 6.4 Referenser Rosner, B. 2006. Fundamentals of Biostatistics. 6th ed. Duxbury Press. "],["tabeller-1.html", "Kapitel 7 Tabeller 7.1 Principer för tabeller 7.2 Exportera tabell till HTML-fil 7.3 Paket för tabeller 7.4 Övningsuppgifter", " Kapitel 7 Tabeller body { text-align: justify} Diskreta variabler förekommer ofta i statistisk dataanalys. En betydande del av programmeringsblocket har handlat om diskreta variabler, hur de bäst beskrivs i tabeller och hur de kan illustreras med hjälp av diagram. Detta kapitel syftar till att underlätta hanteringen av de tabeller som diskuterats tidigare och tar diskuterar därför kortfattat formalia kring tabeller, till exempel hur de bör struktureras och på vilket sätt de bäst inkluderas i en rapport. Kapitlet avslutas med ett exempel som visar hur en tabell smidigt kan exporteras från R för att användas i ett Word-dokument. 7.1 Principer för tabeller I princip gäller att sunt förnuft bör tillämpas vid konstruktion och användning av tabeller av olika slag. Naturligtvis ska allt som står i en tabell gå att läsa och vara relevant. Många gånger är det lätt att inkludera information som inte är relevant för analysen av bara farten, men detta skapar nästan alltid förvirring och det blir för läsaren oklart varför onödig information inkluderats. Vid arbete med inlämnings- och seminarieuppgifter under kursens gång rekommenderas att nedan punkter tas i beaktande när tabeller ska användas. Tabellrubriker placeras ovanför tabeller. Tabellrubriker ska enkelt förklara för läsaren vad tabellen syftar till att beskriva, men ska inte nödvändigtvis innehålla detaljer. Detaljer gör sig oftast bättre i själva tabellen. Tabellen ska vara självförklarande. Tabellresultat ska alltid att beskrivas i text, med hänvisning till tabellen. Undvik att ha alltför många linjer i tabeller. Ofta räcker faktiskt tre horisontella linjer - en ovanför kolumnnamnen, en under kolumnnamnen och en nedanför sista raden. 7.2 Exportera tabell till HTML-fil Alla rapporter eller vetenskapliga artiklar bör inkludera en beskrivning av urvalet, dvs variablernas fördelning i stickprovet. Frågan som då besvaras är Vilka är det vi vi undersöker?. Ibland är denna beskrivning placeread i början av rapporten eller arikeln, och ibland i en bilaga i slutet av rapporten. Observera att syftet inte är att göra inferens, utan enbart att beskriva de observationer som finns i urvalet. Detta innebär normalt sett att medelfel, konfidensintervall eller \\(p\\)-värden inte redovisas i denna tabell. I Kapitel 5 diskuterades utförligt hur R kan användas för att skapa tabeller som innehåller olika typer av information om en eller flera variabler i ett stickprov. Tanken bakom tabellerna är nästan alltid att de ska inkluderas i någon sorts rapport, och de behöver därför exporteras till t.ex. ett Word-dokument och snyggas till. Denna export kan göras manuellt, men det finns två stora nackdelar (risker) med en sådan approach. Om tabellerna är väldigt stora, alltså innehåller väldigt många mått eller variabler, är det mycket tidskrävande att exportera tabellerna värde för värde. När tabeller exporteras manuellt är det väldigt lätt att något går fel. Värden kan till exempel hamna i fel cell, kommatecken kan hamna på fel ställe, och det är lätt att råka skriva fel siffra någonstans. För att minimera dessa risker kan R användas för att exportera tabeller i sin helhet, som sedan kan snyggas till i den ordbehandlare som används. Resten av detta ägnas åt ett exempel som ämnar visa på ett sätt att göra detta. För enkelhetens skull används samma datamaterial som i Kapitel 6. Gå därför tillbaka och kopiera in koden med datamaterialet till ditt nuvarande script, så att du kan följa med i exemplet. För att komplettera en studie är det önskvärt att skapa en tabell som visar stickprovsmedelvärde, stickprovsstandardavvikelse, median, minsta värde och största värde för var och en av de tre variablerna i datamaterialet. En sådan tabell skapas enkelt med koden nedan. # Sammanfattning av variabeln fev fev_summary &lt;- c(mean(fev), sd(fev), median(fev), min(fev), max(fev)) # Sammanfattning av variabeln age age_summary &lt;- c(mean(age), sd(age), median(age), min(age), max(age)) # Sammanfattning av variabeln height height_summary &lt;- c(mean(height), sd(height), median(height), min(height), max(height)) # Gör varje vektor till en rad tab_summary &lt;- rbind(fev_summary, age_summary, height_summary) # Skriver ut matris/tabell tab_summary &gt; [,1] [,2] [,3] [,4] [,5] &gt; fev_summary 2.636780 0.8670591 2.5475 0.791 5.793 &gt; age_summary 9.931193 2.9539352 10.0000 3.000 19.000 &gt; height_summary 61.143578 5.7035128 61.5000 46.000 74.000 Eftersom tabellen ska synas i en rapport är det önsvärt att snygga till den genom att lägga till rad- och kolumnnamn. Detta görs med koden nedan. rownames(tab_summary) &lt;- c(&quot;FEV (liter/sek)&quot;, &quot;Ålder&quot;, &quot;Längd (tum)&quot;) colnames(tab_summary) &lt;- c(&quot;Medelvärde&quot;, &quot;Std. Avv.&quot;, &quot;Median&quot;, &quot;Min&quot;, &quot;Max&quot;) tab_summary &gt; Medelvärde Std. Avv. Median Min Max &gt; FEV (liter/sek) 2.636780 0.8670591 2.5475 0.791 5.793 &gt; Ålder 9.931193 2.9539352 10.0000 3.000 19.000 &gt; Längd (tum) 61.143578 5.7035128 61.5000 46.000 74.000 För att exportera tabellen till en HTML-fil krävs paketet xtable. Installera därför detta paket med koden install.packages(\"xtable\"), och aktivera det sedan med library(\"xtable\"). Koden som används för att exportera tabellen är print(x = xtable(tab_summary), # Anger vilket objekt som ska exporteras type = &quot;html&quot;, # Anger att det ska skrivas i HTML file = &quot;sammanfattning.html&quot;) # Anger namn på HMTL-filen som ska skapas Det finns en del saker som är värda att notera i koden ovan Genom argumentet x anges vilket objekt som ska exporteras, alltså vilken tabell som ska skrivas ut. Notera att objektnamnet inte anges individuellt, genom funktionen xtable(). Detta är mycket viktigt, och argumentet måste alltid specificeras genom xtable(), annars kommer exporten inte att fungera. Argumentet type bör alltid vara specificerat som just \"html\". I argumentet file anges vilket namn HTML-filen som skapas av R kommer att ha. Namnet kan såklart bestämmas på ett lämpligt sätt, men vad som är viktigt är att ändelsen .html (lägg märke till punkten i börjat) alltid måste finnas efter filnamnet. När koden ovan har körts sparas en ny fil i den mapp som är inställd som working directory. Filen har namnet som specificerades i argumentet file ovan, och kan öppnas i en helt vanlig webbläsare (alltså Chrome, Safari, etc). För att föra över tabellen till en ordbehandlare (alltså något i stil med Word eller Pages) är det lättast att först öppna filen i en webbläsare och kopiera innehållet, precis som visas i bilden nedan. När detta är gjort kan tabellen klistras in i vald ordbehandlare och snyggas till enligt önskemål. När nedanstående tabell klistras in i Pages blir resultatet som i bilden nedan. Tabellen kan sedan redigeras som vanligt, med fördelen att risken för felinmatade siffror minskas markant. Notera att objektet som skrivits ut ovan är av typen matrix, se koden nedan. class(tab_summary) &gt; [1] &quot;matrix&quot; &quot;array&quot; Det går även att exportera objekt som har skapats med funktionen table() på samma sätt. Testa gärna själv att som övning exportera en av tabellerna som skapades i Kapitel 5, och sedan klistra in och snygga till den i en ordbehandlare. 7.3 Paket för tabeller Du lär dig på denna kurs det som är nödvändigt för att lösa de uppgifter som krävs utifrån kursens mål och innehåll. Du gör detta utan att använda paket och det enda externa paket för tabeller som vi använder är xtable() som används för att exportera tabeller. För den intresserade kan det efter kursen vara värt att kika närmare på något eller några av följande paket: Table1 summartools gt tables DescTool Det bör också nämnas att en anledningar till att R är populärt är just det stora antalet paket. 7.4 Övningsuppgifter 7.4.1 Uppgift 1 Koden set.seed(152021) s &lt;- sample(x = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;), size = 100, replace = TRUE) kan användas för att skapa en vektor med grupptillhörigheter för 100 olika individer. För varje element i vektorn s väljer funktionen sample() slumpmässigt ett av värdena i vektorn som ges till funktionen genom argumentet x, alltså kommer varje element höra till en av grupperna \"A\", \"B\", \"C\", och \"D\". Funktionen set.seed() används för att säkerställa att alla studenter får samma vektor s. Eftersom sample() tilldelar element slumpmässigt kommer varje student få olika s om set.seed(152021) inte körs direkt innan koden för s. Kopiera och kör de två raderna kod ovan. Skapa sedan en vanlig frekvenstabell som beskriver hur många observationer som finns i varje grupp. Spara tabellen i ett objekt vid namn tab_s. Visa svar set.seed(152021) s &lt;- sample(x = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;), size = 100, replace = TRUE) tab_s &lt;- table(s) # Skapar tabell tab_s # Skriver ut tabell &gt; s &gt; A B C D &gt; 27 18 29 26 Använd xtable(), enligt ovan, för att exportera tab_s till en HTML-fil. Visa svar print(x = xtable(tab_s), # Anger vilket objekt som ska exporteras type = &quot;html&quot;, # Anger att det ska skrivas i HTML file = &quot;tab_s.html&quot;) # Anger namn på HMTL-filen som ska skapas Tabellen som skrivs ut ovan blir inte riktigt som förväntat, utan den skrivs ut som en tabell med två kolumner snarare än två rader. Detta åtgärdas enklast med hjälp av så kallad transponering. Transponering innebär, i korta drag, att varje kolumn i tabellen görs om till en rad (alternativt att varje rad görs om till en kolumn), och implementeras i R med funktionen t(). Kopiera koden från deluppgift b, men använd ändra det första argumentet så att x = xtable( t(tab_s) ). Kom även ihåg att ändra namnet på output-filen. Hur hur ser tabellen som exporteras ut nu? Visa svar print(x = xtable( t(tab_s) ), # Anger vilket objekt som ska exporteras type = &quot;html&quot;, # Anger att det ska skrivas i HTML file = &quot;tab_s_t.html&quot;) # Anger namn på HMTL-filen som ska skapas 7.4.2 Uppgift 2 Återgå nu till tabellen tab_summary som skapades i kapiteltexten. Tabellen som exporterades i kapiteltexten visar två decimaler i varje cell, och detta är default för xtable(). Ibland är det önskvärt att själv kontrollera hur många decimaler som skrivs ut i en tabell, det kan vara nödvändigt att ha färre decimaler för att få in tabellen på ett A4 eller ha fler decimaler för större precision i en skattning. Antalet decimaler som används i tabellen kontrolleras med argumentet digits i funktionen xtable(). Default är, som sagt, att digits = 2, men antalet kan såväl ökas som minskas efter önskemål. Viktigt är att argumentet måste specificeras inom anropet av xtable() för att få efffekt, och det räcker inte att bara sätta det inom print(). Med hjälp av informationen ovan, exportera tab_summary till en HTML-fil, där fyra decimaler används i varje cell i tabellen. Visa svar print(x = xtable(tab_summary, digits = 4), type = &quot;html&quot;, file = &quot;sammanfattning_avrund.html&quot;) 7.4.3 Uppgift 3 Förfarandet i föregående uppgifter kan användas även när det rör sig om korstabeller. För att göra en korstabell krävs som bekant två kategoriska variabler, vilka kan genereras med koden nedan. set.seed(152021) s &lt;- sample(x = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;), size = 100, replace = TRUE) r &lt;- sample(x = 1:6, size = 100, replace = TRUE) Kopiera koden ovan, kör den i RStudio, och skapa en korstabell där r är kolumnvariabel och s är radvariabel. Spara tabellen i ett objekt som heter tab_rs. Visa svar set.seed(152021) s &lt;- sample(x = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;), size = 100, replace = TRUE) r &lt;- sample(x = 1:6, size = 100, replace = TRUE) tab_rs &lt;- table(s, r) tab_rs &gt; r &gt; s 1 2 3 4 5 6 &gt; A 6 4 6 5 5 1 &gt; B 4 1 4 5 1 3 &gt; C 3 6 2 7 6 5 &gt; D 3 9 2 1 3 8 Exportera tab_rs till en HTML-fil. Visa svar print(x = xtable( tab_rs ), # Anger vilket objekt som ska exporteras type = &quot;html&quot;, # Anger att det ska skrivas i HTML file = &quot;tab_rs.html&quot;) # Anger namn på HMTL-filen som ska skapas Använd tab_rs för att skapa en korstabell som visar andelar istället för frekvenser, andelarna ska vara baserade på kolummntotaler. Exportera den nya andelstabellen till en HTML-fil, och se till så att tre decimaler visas i tabellen som exporteras. Visa svar Tabellen med andelar skapas som vanligt med prop.table(), där margin = 2 ger andelar baserade på kolumnsummor. p_tab_rs &lt;- prop.table(tab_rs, margin = 2) p_tab_rs &gt; r &gt; s 1 2 3 4 5 6 &gt; A 0.37500000 0.20000000 0.42857143 0.27777778 0.33333333 0.05882353 &gt; B 0.25000000 0.05000000 0.28571429 0.27777778 0.06666667 0.17647059 &gt; C 0.18750000 0.30000000 0.14285714 0.38888889 0.40000000 0.29411765 &gt; D 0.18750000 0.45000000 0.14285714 0.05555556 0.20000000 0.47058824 Tabellen exporteras sedan med koden nedan. Notera att digits = 3 ger tre decimaler. print(x = xtable(p_tab_rs, digits = 3 ), # Anger vilket objekt som ska exporteras type = &quot;html&quot;, # Anger att det ska skrivas i HTML file = &quot;p_tab_rs.html&quot;) # Anger namn på HMTL-filen som ska skapas 7.4.4 Uppgift 4 Exportera tabellen som skapades i uppgift 6.3.3. till en HTML-fil. "],["figurer-1.html", "Kapitel 8 Figurer 8.1 Estetik 8.2 Grundläggande figurhantering 8.3 Färger och figurer 8.4 Cirkeldigram 8.5 Figurer för fördelningar 8.6 Lådagram 8.7 Spridningsdiagram 8.8 Exportera figurer", " Kapitel 8 Figurer body { text-align: justify} En figur kan vara ett diagram, ett foto, en skiss eller en karta. Syftet är att ge en överskådlig beskrivning av data, eventuellt med avsikt att generalisera till en population. Välgjorda figurer tillgängliggör rapporter, bildspel eller artiklar för läsare. En god figur kan ge den som analyserar data möjlighet att betrakta data på ett sätt som annars inte är möjligt. R ger tillgång till omfattande möjligheter för datavisualisering och en anledning till utvecklingen av R var behovet av ett verktyg för avancerad visualisering. Dels ger basutbudet i R stora möjligheter, dels finns det paket (exempelvis ggplot2 och lattice) som ger ytterligare möjligheter. Det bör nämnas att man ofta får prova sig fram när man skapar figurer i R och nybörjaren bör därför inte misströsta. Övning ger färdighet. Det kan vara bra att veta att figurer kan ta lång tid att skapa. När man ska skapa en figur bör man fundera på om figuren är avsedd att presenteras externt, t ex figurer i en rapport eller bildspel. En sådan figur ska på ett tydligt och korrekt redovisa det väsentliga i en analys och vara estetiskt fullgod. Dessutom måste figuren vara sparad i ett format som fungerar för det medium den ska publiceras i. är avsedd för en intern analys, t ex för dataanalytikern och andra involverade i analysen. Målet kan vara att studera data explorativt vid tvätt av data, kontroll av förutsättningar vid analyser eller förmedla preliminära resultat. Estetiska och pedagogiska aspekter hos sådana figurer är inte av någon större vikt. Däremot måste naturligtvis figurerna på ett korrekt sätt representera data. Eftersom figurer representerar data så är ofta tabeller och figurer utbytbara informationsmässigt. Om så är fallet måste den som analyserar data ta ställning till att redovisa antingen tabellen eller figuren. Men det kan också vara så att det endast är med hjälp av en figur som data kan beskrivas på tillfredställande sätt. 8.1 Estetik Vi kan (krasst sett) klassificera figurer i fyra kategorier: Ok. Oestetisk, men korrekt. Dålig, innebär att figuren är svårtolkad men principellt korrekt. Felaktig. Var och en av kategorierna illustreras med ett diagram i nedanstående figur. Visa figurkod # Läs in data df &lt;- read.csv2(&quot;data/conscriptiondata.csv&quot;) # Skapa kategorier av poängen på Test A df$testa_cat[df$testa &lt; 10] &lt;- 1 df$testa_cat[(df$testa &gt;= 10) &amp; (df$testa &lt; 20)] &lt;- 2 df$testa_cat[(df$testa &gt;= 20) &amp; (df$testa &lt; 30)] &lt;- 3 df$testa_cat[(df$testa &gt;= 30)] &lt;- 4 df$testa_cat &lt;- factor(df$testa_cat) # Skapa ett tabellobjekt freqtable_testa &lt;- table(df$testa_cat) par(mfrow = c(2,2)) # OK figur barplot(freqtable_testa/1000, col=&quot;lightblue&quot;, main=&quot;OK&quot;, ylab=&quot;Antal (tusental)&quot;, xlab = &quot;Poäng test A&quot;, ylim=c(0,350), border=&quot;white&quot;, names.arg = c(&quot;0-9&quot;, &quot;10-19&quot;, &quot;20-29&quot;, &quot;30-40&quot;)) # Oestetisk figur barplot(freqtable_testa/1000, main=&quot;Oestetisk&quot;, col=c(4,7,5,2), xlab = &quot;Poäng test A&quot;, ylab=&quot;Antal (tusental)&quot;, ylim=c(0,350), border=&quot;white&quot;, names.arg = c(&quot;0-9&quot;, &quot;10-19&quot;, &quot;20-29&quot;, &quot;30-40&quot;)) abline(h = c(0, 100, 200, 300), lwd = 2) # Dålig figur barplot(freqtable_testa, main=&quot;Dålig&quot;, col=&quot;lightblue&quot;, ylab=&quot;Antal&quot;, xlab = &quot;Poängkategori test A&quot;, ylim=c(0,350000), border=&quot;white&quot;) # Felaktig figur barplot(freqtable_testa, main=&quot;Felaktig&quot;, col=&quot;lightblue&quot;, ylab=&quot;&quot;, xlab = &quot;Test&quot;, ylim=c(0,800000), border=&quot;white&quot;, xaxt=&#39;n&#39;, yaxt=&#39;n&#39;) Den första figuren är OK eftersom den redovisar stapeldiagramen utan felaktigheter. Den andra figuren är oestetisk beträffande färgval och har hjälplinjer som löper över staplarna istället för bakom. Figuren som klassas som dålig är korrekt, men det är svårt att urskilja detaljer i den. Dessutom är namnen på kategorierna otydliga och kan förväxlas med poäng. Den felaktiga figuren visar staplarna, men det finns ingen information som gör figuren möjlig att tolka. Notera att distinktionen oestetisk-dålig-felaktig är flytande. Att ha olika färger på staplar innebär att läsaren kan föranledas att tro att färgerna tillför ytterligare information som egentligen inte finns. En korrekt figur som är dålig, kanske är så dålig att den kan misstolkas vilket innebär att den egentligen är felaktig. Forskare och andra som regelbundet arbetar med vetenskapliga rapporter brukar ofta ha en ganska bra uppfattning om vad som är en korrekt figur. Däremot saknas en känsla för estetiken i en figur. Å andra sidan är det inte ovanligt att se grafiker som skapar vackra figurer, men som inte på ett tillfredställande korrekt sätt redovisar data. 8.2 Grundläggande figurhantering Det finns en uppsättning figurer som ofta används. Vi kommer gå igenom de vanligaste figurtyperna som räcker för de absolut flesta situationerna. Utöver dessa finns till exempel figurer som visar 3-dimensionella samband, kartor och specialdiagram. Innan vi presenterar några vanliga typer av figurer ska vi gå igenom ett några grundläggande funktioner som en användare ska känna till när man konstruerar figurer. För det första bygger R på att man med hjälp av en figur-funktion, t ex plot(), skapar en canvas/målarduk. Det går sedan att med olika argument i flera steg måla på denna målarduk. Vi illusterar detta sätt att arbeta med figurer genom att först med funktionen plot() skapa en figur. Sedan används funktionen lines() för rita en regressionslinje i figuren. # Läs in data för figurer x1 &lt;- c(10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5) x2 &lt;- c(10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5) x3 &lt;- c(10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5) x4 &lt;- c(8, 8, 13, 8, 8, 8, 8, 8, 8, 8, 8) y1 &lt;- c(8.04, 6.95, 7.58, 8.81, 8.33, 9.96, 7.24, 4.26, 10.84, 4.82, 5.68) y2 &lt;- c(9.14, 8.14, 8.74, 8.77, 9.26, 8.10, 6.13, 3.10, 9.13, 7.26, 4.74) y3 &lt;- c(7.46, 6.77, 12.74, 7.11, 7.81, 8.84, 6.08, 5.39, 8.15, 6.42, 5.73) y4 &lt;- c(6.58, 5.76, 7.71, 8.84, 8.47, 7.04, 5.25, 12.50, 5.56, 7.91, 6.89) # Regressionlinje x &lt;- 4:14 Ey &lt;- 3.00 + 0.500*x # Skapa en figur för x1 och y1. Ritar sedan en regressionslinje med lines() plot(x1, y1) lines(x, Ey) För det andra omges målarduken av en ram, så kallade marginaler. Genom att använda funktionen par(mar = c(5.1, 4.1, 4.1, 2.1)), värdena är default-inställningen på marginalernas storlek, kan vi enkelt ändra marginalernas storlek. Figuren nedan illusterar målarduken i mitten med marginalerna omkring. Ordningen på värdena korresponderar till respektive marginals position. Det finns en nedre marginal (1), en vänstermarginal (2), en övre marginal (3) och en högermarginal (4). Genom att ändra värdena ser vi att marginalernas storlek ändras. Det är mycket vanligt att justera marginalernas storlek eftersom onödiga vita ytor inte är önsvärda i en figur. Det kan också vara så att marginalers storlek måste utökas på grund att delar i figuren, t ex kategori- och/eller variabelnamn, annars inte får plats. Ett sådant exempel återges i Kapitel 5, närmare bestämt i avsnittet om Likert-figurer. För det tredje är det vanligt att kombinera flera diagram i en figur. Detta är möjligt med funktionen par(), fast nu med argumentet mfrow = c(antalrader, antalkolumner). Argumentet består av en vektor med två värden, et som anger antalet rader och ett som anger antalet kolumner som önskas i figuren. Exemplet nedan visar hur fyra diagram över samband kan illustereras i en och samma figur. De fyra datamaterialen kallas för Anscombes kvartett (Anscombe, 1973), och är grund för en berömd illustration av hur viktig datavisualisering är. Alla fyra datamaterial har nämligen samma medelvärde, standardavvikelse, korrelation och regressionlinje. Men en grafisk jämförelse visar hur olika egenskaper de olika datamaterialen har! # Skapa fyra diagram i en figur, 2 rader och 2 kolumner. Fyller på med lines i varje diagram. par(mfrow = c(2, 2)) plot(x1, y1, xlim = c(4,15), ylim = c(4,13)) lines(x, Ey, col = &quot;red&quot;) plot(x2, y2, xlim = c(4,15), ylim = c(4,13)) lines(x, Ey, col = &quot;red&quot;) plot(x3, y3, xlim = c(4,15), ylim = c(4,13)) lines(x, Ey, col = &quot;red&quot;) plot(x4, y4, xlim = c(4,15), ylim = c(4,13)) lines(x, Ey, col = &quot;red&quot;) Vi är dock inte helt nöjda med ovanstående figur, utan vi tycker det finns för mycket vit yta mellan diagrammen. Vi kombineras de bägge argumenten i par() med målet att ha fyra diagram i en figur, men med mindre marginaler. Nu ser det bättre ut! # Skapa fyra diagram i en figur. Fyller på med en linje med lines() par(mfrow = c(2, 2), mar = c(4, 4, 1, 1)) plot(x1, y1, xlim = c(4,15), ylim = c(4,13)) lines(x, Ey, col = &quot;red&quot;) plot(x2, y2, xlim = c(4,15), ylim = c(4,13)) lines(x, Ey, col = &quot;red&quot;) plot(x3, y3, xlim = c(4,15), ylim = c(4,13)) lines(x, Ey, col = &quot;red&quot;) plot(x4, y4, xlim = c(4,15), ylim = c(4,13)) lines(x, Ey, col = &quot;red&quot;) 8.3 Färger och figurer Som visats i tidigare kapitel kan färger användas för att lägga till extra information i figurer. Det är dock sällan önskvärt att använda olika färger om de inte tillför någon information som inte redan finns i diagrammet. I ett stapeldiagram som illustrerar antalet respondenter som hör till en viss åldersgrupp, till exempel, finns det ingen poäng i att ha olikfärgade staplar, då färskillnaderna kan vara förvirrande för läsaren. Eftersom varje ålderskategori redan har sin egen stapel finns ingen anledning att ytterligare skilja dem åt med hjälp av olika färger. Generellt sett rekommenderas följande Om färgen representerar olika kategorier som inte går att rangordna bör det vara olika färger Om färgen regresenterar en kvantitativ variabel kan man ha olika nyanser på samma färger för att visa magnituden på variabeln. 8.3.1 Presentation av aggregerade data Aggregerade data (summor, antal, medelvärden, andelar) presenteras ofta i stapeldiagram, där R använder funktionen barplot(). punktdiagram, där R använder funktionen dotchart(). I princip kan samma information redovisas i en tabell men en grafisk presentation kan vara att föredra, detta är lite olika från person till person. På grund av relationen mellan stapeldiagram och tabeller används i R ofta skapat tabellobjekt, men det går också att använda enskilda variabler från en data frame. Vad som dock är viktigt när man skapar figurer i R är att användaren först måste skapa data i ett format som kan analyseras, sedan skapa figuren. Vi ska nu skapa en figur för filmers intäkter 2019. Jämför de olika figurerna nedan och fundera på varför den ena är bättre än den andra. boxoffice2019 &lt;- data.frame(title = c(&quot;Aladdin&quot;, &quot;Avengers: Endgame&quot;, &quot;Captain Marvel&quot;, &quot;Frozen II&quot;, &quot;IT Chapter Two&quot;, &quot;Joker&quot;, &quot;Spider-Man: Far from Home&quot;, &quot;Star Wars: Episode IX&quot;, &quot;The Lion King&quot;, &quot;Toy Story 4&quot;), amount = c(355772511, 858373000, 426829839, 430144682, 211593228,333772511,390532085, 390706234,543638043,434038008)) barplot(boxoffice2019$amount, names.arg=boxoffice2019$title) barplot(boxoffice2019$amount, names.arg=boxoffice2019$title, las=2) par(mar = c(4, 12, 1, 2)) barplot(boxoffice2019$amount, names.arg=boxoffice2019$title, horiz = TRUE, las=1) par(mfrow = c(1, 1)) boxoffice2019_decreasing &lt;- boxoffice2019[order(boxoffice2019[,2], decreasing=FALSE), ] par(mar = c(4, 12, 4, 2)) barplot(boxoffice2019_decreasing$amount/1000000, names.arg=boxoffice2019_decreasing$title, horiz = TRUE, las=1, xlab = &quot;Miljoner USD&quot;, col = &quot;lightblue&quot;, border =&quot;white&quot;) När man har mångra kategorier lämpar sig dotcharts bättre. Vi ska se ett exempel på detta. I paketet dslabs finns datasetet gapminder. Vi läser in detta dataset för att jämföra europeiska länders förväntade livslängd. Vi ser också här ett exempel på när olika färger kan tillföra information gällande kategoritillhörighet. library(&quot;dslabs&quot;) gapminderEurope2015 &lt;- gapminder[(gapminder$continent == &quot;Europe&quot; &amp; gapminder$year == 2015), ] gapminderEurope2015$color &lt;- factor(gapminderEurope2015$region) levels(gapminderEurope2015$color)[levels(gapminderEurope2015$color) == &quot;Eastern Europe&quot;] &lt;- &quot;coral2&quot; levels(gapminderEurope2015$color)[levels(gapminderEurope2015$color) == &quot;Western Europe&quot;] &lt;- &quot;palegreen2&quot; levels(gapminderEurope2015$color)[levels(gapminderEurope2015$color) == &quot;Southern Europe&quot;] &lt;- &quot;tan2&quot; levels(gapminderEurope2015$color)[levels(gapminderEurope2015$color) == &quot;Northern Europe&quot;] &lt;- &quot;deepskyblue2&quot; gapminderEurope2015decreasing &lt;- gapminderEurope2015[order(gapminderEurope2015$life_expectancy),] par(mar = c(4, 12, 1, 2)) barplot(gapminderEurope2015decreasing$life_expectancy, names.arg = gapminderEurope2015decreasing$country, horiz = TRUE, las = 2, xlim = c(0, 90), xlab = &quot;Life expectancy (years)&quot;, col = as.character(gapminderEurope2015$color), border =&quot;white&quot;) par(mfrow = c(1,2)) dotchart(gapminderEurope2015$life_expectancy, labels= gapminderEurope2015$country, las = 2, cex = 0.8, xlim = c(0, 90), xlab = &quot;Life expectancy (years)&quot;) dotchart(gapminderEurope2015decreasing$life_expectancy, labels= gapminderEurope2015decreasing$country, las = 2, cex = 0.8, xlim = c(0, 90), xlab = &quot;Life expectancy (years)&quot;) dotchart(gapminderEurope2015decreasing$life_expectancy, labels= gapminderEurope2015decreasing$country, las = 2, cex = 0.8, xlab = &quot;Life expectancy (years)&quot;,col = as.character(gapminderEurope2015$color)) 8.4 Cirkeldigram R-manualen avråder från cirkeldiagram. 8.5 Figurer för fördelningar Histogram används för att visualisera en kontinuerlig variabel. Funktionen hist() skapar ett histogram. Nackdelen med histogram är att den är känslig för antalet klasser. Testa därför olika antal klasser. par(mfrow = c(2,2)) hist(df$gripstrength, xlab=&quot;Greppstyrka (Newton)&quot;, ylab=&quot;Antal&quot;, breaks=7, main=&quot;7 klasser&quot;) hist(df$gripstrength, xlab=&quot;Greppstyrka (Newton)&quot;, ylab=&quot;Antal&quot;, breaks=14, main=&quot;14 klasser&quot;) hist(df$gripstrength, xlab=&quot;Greppstyrka (Newton)&quot;, ylab=&quot;Antal&quot;, breaks=28, main=&quot;28 klasser&quot;) hist(df$gripstrength, xlab=&quot;Greppstyrka (Newton)&quot;, ylab=&quot;Antal&quot;, breaks=56, main=&quot;56 klasser&quot;) 8.6 Lådagram Lådagram används främst när vi ska jämföra fördelningar uppdelat på kategorier. Att använda lådagram för en enda variabel är inte optimalt, utan histogram ger då mer information. Vi vill studera testresultat uppdelat på psykologisk bedämning boxplot(df$gripstrength~df$psych, xlab=&quot;Psykologisk bedömning (1-9)&quot;, ylab=&quot;Greppstyrka (Newton)&quot;) 8.7 Spridningsdiagram Den vanligaste funktionen i R för att skapa figurer är plot(). Det finns många argument och i det närmaste obegränsade möjligher att anpassa figurerna. Nedan visar vi ett problem som kan uppkomma med spridningsdiagram, nämligen när vi har väldigt många datapunkter. Det första diagrammet redovisar de 500 första individerna i INSARK. Det andra diagrammet redovisar data från alla 709869 individer. plot(df$legstrength[1:500], df$armstrength[1:500], xlab = &quot;Benstyrka (Newton)&quot;, ylab = &quot;Armstyrka (Newton)&quot;) plot(df$legstrength, df$armstrength, xlab = &quot;Benstyrka (Newton)&quot;, ylab = &quot;Armstyrka (Newton)&quot;) Det blir, i det senare diagrammet, svårt att urskilja mönster eller trender i diagrammet, eftersom punkterna är så många. Denna problematik kommer lyftas fram mer under senare delar av kursen. 8.8 Exportera figurer Det finns ett antal olika format att exportera figurer till. Det absolut enklaste är använda Export i fliken Plots. Här väljer du antingen Save as image eller Save as PDF PDF är ett bra format om man ska skriva ut. Det är vektorbaserat vilket innebär att det går bra att zooma in i bilden utan att upplösningen blir dålig. Figuren tar inte mycket minne. Formatet png är bitmap-baserat format som är utmärkt för webben. Ofta krävs, tyvärr, också png för ordbehandlingsprogram, vilket gör export av figurer med hög kvalitet krångligare, jämfört med PDF. Använd aldrig jpg, som är alternativet. Det finns dock ganska få inställningar i Export. Ett alternativ som ger mer flexibilitet är att skapa en PDF eller png från R och sen rita figuren på denna. Vi tittar på två exempel nedan, först ett för PDF och sedan ett för png. # Skapa en PDF att rita. Storleken anges med width och height och dimensionen är tum. pdf(&quot;data/rplot.pdf&quot;, width = 8, height = 6) # Börja rita figuren på filen par(mfrow = c(2, 2), mar = c(4, 4, 1, 1)) plot(x1, y1, xlim = c(4,15), ylim = c(4,13)) lines(x, Ey, col = &quot;red&quot;) plot(x2, y2, xlim = c(4,15), ylim = c(4,13)) lines(x, Ey, col = &quot;red&quot;) plot(x3, y3, xlim = c(4,15), ylim = c(4,13)) lines(x, Ey, col = &quot;red&quot;) plot(x4, y4, xlim = c(4,15), ylim = c(4,13)) lines(x, Ey, col = &quot;red&quot;) # Stänger plot och sparar. Den sparas enligt sökvägen ovan. dev.off() # Skapar en png att rita på. Storleken anges med width och height och dimensionen är cm (units). # Upplösningen (dpi) är viktig för en bitmap-baserad fil. Förslagsvis används res = 1200 för utskrift och res = 72 webben eller skärmen. type = &quot;cairo&quot; anger att kantutjämning (antialias) ska användas, vilket ger snyggare utseende. png(&quot;data/rplot.png&quot;, width = 18, height = 14, units = &quot;cm&quot;, res = 1200, type=&#39;cairo&#39;) par(mfrow = c(2, 2), mar = c(4, 4, 1, 1)) plot(x1, y1, xlim = c(4,15), ylim = c(4,13)) lines(x, Ey, col = &quot;red&quot;) plot(x2, y2, xlim = c(4,15), ylim = c(4,13)) lines(x, Ey, col = &quot;red&quot;) plot(x3, y3, xlim = c(4,15), ylim = c(4,13)) lines(x, Ey, col = &quot;red&quot;) plot(x4, y4, xlim = c(4,15), ylim = c(4,13)) lines(x, Ey, col = &quot;red&quot;) dev.off() Avslutningsvis några tips: Bestäm bredd-höjd-relationen (aspect ratio) redan när du skapar figuren i R. Stretcha inte figuren efter att du skapat den! Kvaliteten kan försämras betydligt. Du kan dock eventuellt förminska och förstora figuren, så länge bredd-höjd-relationen bibehålls. Om det finns mycket vit yta, minska marginalerna med argumentet mar i par()funktionen. Om du skapar en stor figur, då måste du med t ex cex-argument i figuren, för att öka storleken på text. Ofta måste man prova sig fram. Var beredd på att ändra storlek på text och siffror i figuren. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
